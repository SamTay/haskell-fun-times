<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="https://necolas.github.io/normalize.css/latest/normalize.css" type="text/css" />
  <link rel="stylesheet" href="https://gist.githubusercontent.com/dashed/6714393/raw/ae966d9d0806eb1e24462d88082a0264438adc50/github-pandoc.css" type="text/css" />
  <link rel="stylesheet" href="/haskell-fun-times/css/custom.css" type="text/css" />
</head>
<body>
<h1 id="haskell-programming-from-first-principles">Haskell Programming From First Principles</h1>
<p>This directory contains notes &amp; exercises from <a href="http://haskellbook.com/">Haskell Programming From First Principles</a>. Thanks <a href="https://github.com/bitemyapp">@bitemyapp</a>!</p>
<p>I don't expect many people to end up here, but if you do, I would recommend not reading my solutions and figuring out the exercises on your own. The subreddit <a href="https://www.reddit.com/r/HaskellBook/">r/HaskellBook</a> is also a great place to ask questions and get feedback/advice on the material and specific exercises.</p>
<h1 id="all-you-need-is-lambda">All You Need Is Lambda</h1>
<p>The labmda calulus is a model of computation devised in the 1930s by Alonzo Church. All functional<br />
programming languages are based on the lambda calculus, but Haskell is <em>pure</em> and consequentially<br />
<em>referentially transparent</em>.</p>
<p><strong>pure</strong>: all features of the language are translatable into lambda expressions</p>
<p><strong>referentially transparent</strong>: the same function, given the same values to evaluate, will always<br />
return the same result</p>
<h3 id="lambda-stuffs">Lambda Stuffs</h3>
<p>I am already familiar with the lambda calculus and its method of computation. On with the equivalence<br />
exercises.</p>
<ol>
<li><em>λxy.xz</em></li>
</ol>
<ul>
<li>[ ] <em>λxz.xz</em></li>
<li>[x] <em>λmn.mz</em></li>
<li>[ ] <em>λz(λx.xz)</em></li>
</ul>
<ol>
<li><em>λxy.xxy</em></li>
</ol>
<ul>
<li>[ ] <em>λmn.mnp</em></li>
<li>[ ] <em>λx(λy.xy)</em></li>
<li>[x] <em>λa(λb.aab)</em></li>
</ul>
<ol>
<li><em>λxyz.zx</em></li>
</ol>
<ul>
<li>[ ] <em>λx.(λy.(λz.z))</em></li>
<li>[x] <em>λtos.st</em></li>
<li>[ ] <em>λmnp.mn</em></li>
</ul>
<h3 id="evaluation-is-simplification">Evaluation is Simplification</h3>
<p>For our purposes, normal form is <em>beta normal form</em>, which is when an expression cannot be beta reduced any further. <strong>A fully executed Haskell program is equivalent to a lambda expression evaluated into beta normal form</strong>.</p>
<p>To be precise, for a function such as division <code>d</code>, <code>d(100, 50)</code> is not yet in normal form, it is simply saturated (applied). The normal form is <code>2</code>. Analogously, for the function <code>(/) :: Fractional a =&gt; a -&gt; a -&gt; a</code>, <code>100/5</code> is <code>(/)</code> applied to <code>100</code> and <code>5</code>. The function is only evaluated to <code>2</code> when the program is executed.</p>
<h3 id="combinators">Combinators</h3>
<p>A combinator is a lambda term with no free variables. Combinators,<br />
as the name suggests, serve only to <em>combine</em> the arguments they are<br />
given.</p>
<h3 id="divergence">Divergence</h3>
<p>Sometimes reducible lambda terms cannot reduce to beta normal form. Instead of converging, they diverge. Once such example is <em>(λx.xx)(λx.xx)</em>.</p>
<h2 id="exercises">Exercises</h2>
<h5 id="determine-if-each-of-the-following-are-combinators">Determine if each of the following are combinators</h5>
<ol>
<li>Yes - <em>λx.xxx</em></li>
<li>No - <em>λxy.zx</em></li>
<li>Yes - <em>λxyz.xy(zx)</em></li>
<li>Yes - <em>λxyz.xy(zxy)</em></li>
<li>No - <em>λxy.xy(zxy)</em></li>
</ol>
<h5 id="determine-if-each-of-the-following-can-be-reduced-to-a-normal-form-or-if-they-diverge.">Determine if each of the following can be reduced to a normal form or if they diverge.</h5>
<ol>
<li>Converge - <em>λx.xxx</em></li>
<li>Diverge - <em>(λz.zz)(λy.yy)</em></li>
<li>Converge - <em>(λx.xxx)z</em></li>
</ol>
<h5 id="evaluate-that-is-beta-reduce-each-of-the-following-expressions-to-normal-form.">Evaluate (that is, beta reduce) each of the following expressions to normal form.</h5>
<ol>
<li><em>(λabc.cba)zz(λwv.w) = (λwv.w)zz = z</em></li>
<li><em>(λx.λy.xyy)(λa.a)b = (λa.a)bb = bb</em></li>
<li><em>(λy.y)(λx.xx)(λz.zq) = (λx.xx)(λz.zq) = (λz.zq)(λz.zq) = (λz.zq)q = qq</em></li>
<li><em>(λz.z)(λz.zz)(λz.zy) = (λz.zy)(λz.zy) = (λz.zy)y = yy</em></li>
<li><em>(λx.λy.xyy)(λy.y)y = (λy.(λy.y)yy)y = yy</em></li>
<li><em>(λa.aa)(λb.ba)c = (λb.ba)(λb.ba)c = (λb.ba)ac = aac</em></li>
<li><em>(λxyz.xz(yz))(λx.z)(λx.a) = (λxyz.xz(yz))(λ_.z)(λ_.a) = λz.(λ_.z)z((λ_.a)z)</em><br />
<em>= λz.za</em></li>
</ol>
<p>Damn! I screwed up alpha equivalence. The correct answer to (7) is <em>λz1.za</em>, which means the <em>z</em> in the body is a free variable. Of course, this would have been clear if I had renamed the initial <em>xyz</em> arguments to <em>jki</em>. Good exercises.</p>
<h1 id="hello-haskell">Hello Haskell!</h1>
<p>This chapter is largely just about syntax and using the REPL, which I already know. One key take-away is below.</p>
<h3 id="weak-head-normal-form">Weak Head Normal Form</h3>
<p>Recall our definition of <em>normal form</em> in <a href="../1_Lambda-Calculus">Chapter 1</a>. Due to Haskell's laziness, it does <strong>not</strong> evaluate everything to normal form by default, and instead evaluates to <em>weak head normal form</em> (WHNF). Details to follow in later chapters. As an example,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(\f <span class="ot">-&gt;</span> (<span class="dv">1</span>, <span class="dv">2</span> <span class="fu">+</span> f)) <span class="dv">2</span></code></pre></div>
<p>reduces to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dv">1</span>, <span class="dv">2</span> <span class="fu">+</span> <span class="dv">2</span>)</code></pre></div>
<p>in WHNF.</p>
<h1 id="because-pigs-cant-fly">Because Pigs Can't Fly</h1>
<h3 id="given-the-following-datatype-answer-the-following-questions">4.3 Given the following datatype, answer the following questions:</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Mood</span> <span class="fu">=</span> <span class="dt">Blah</span> <span class="fu">|</span> <span class="dt">Woot</span> <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<ol>
<li>What is the type constructor, or name of this type?</li>
</ol>
<p><strong>Mood</strong></p>
<ol>
<li>If the function requires a <code>Mood</code> value, what are the values you could possibly use there?</li>
</ol>
<p><strong>Blah, Woot</strong></p>
<ol>
<li>We are trying to write a function <code>changeMood</code> to change Chris’s mood instantaneously. It should act like <code>not</code> in that, given one value, it returns the other value of the same type. So far, we’ve written a type signature <code>changeMood :: Mood -&gt; Woot</code>. What’s wrong with that?</li>
</ol>
<p><strong>Woot is not a type, just a data constructor. Furthermore only returning Woot wouldn't solve returning opposites.</strong></p>
<ol>
<li>Now we want to write the function that changes his mood. Given an input mood, it gives us the other one. Fix any mistakes and complete the function:</li>
</ol>
<p><code>haskell   changeMood Mood = Woot   changeMood   _ = Blah</code><br />
<strong>Corrected:</strong><br />
<code>haskell   changeMood :: Mood -&gt; Mood   changeMood Blah = Woot   changeMood Woot = Blah</code></p>
<h3 id="tuples">4.7 Tuples</h3>
<p>The difference between <code>data Bool = True | False</code> and <code>data (,) a b = (,) a b</code> is that the former is a <em>sum type</em> representing logical disjunction, while the latter is <em>product type</em> representing logical conjunction. In other words, that pipe means that <code>Bool</code> is <em>either</em> <code>True</code> or <code>False</code>, while <code>(a,b)</code> is both <code>a</code> <em>and</em> <code>b</code>.</p>
<p>With the following type signatures:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fst<span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> a
snd<span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> b</code></pre></div>
<p>we can argue that there's really no way these functions could do something other than simply return the first or second value.</p>
<h3 id="exercises-1">4.9 Exercises</h3>
<p>Assume the following functions are defined:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">awesome <span class="fu">=</span> [<span class="st">&quot;Papuchon&quot;</span>, <span class="st">&quot;curry&quot;</span>, <span class="st">&quot;:)&quot;</span>]
alsoAwesome <span class="fu">=</span> [<span class="st">&quot;Quake&quot;</span>, <span class="st">&quot;The Simons&quot;</span>]
allAwesome <span class="fu">=</span> [awesome, alsoAwesome]</code></pre></div>
<h5 id="given-what-we-know-about-numeric-types-and-the-type-signature-of-length-look-at-these-two-expressions.-one-works-and-one-returns-an-error.-determine-which-will-return-an-error-and-why.">3. Given what we know about numeric types and the type signature of length, look at these two expressions. One works and one returns an error. Determine which will return an error and why.</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">6</span> <span class="fu">/</span> <span class="dv">3</span>
<span class="co">-- and</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">6</span> <span class="fu">/</span> length [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre></div>
<p>The second returns an error because <code>length</code> specifically returns type <code>Int</code>, which doesn't implement <code>Fractional</code> whereas the compiler can infer that <code>3</code> should be a type implementing <code>Fractional</code> in the expression <code>6 / 3</code>.</p>
<h5 id="how-can-you-fix-the-broken-code-from-the-preceding-exercise-using-a-different-division-functionoperator">4. How can you fix the broken code from the preceding exercise using a different division function/operator?</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">6</span> <span class="ot">`div`</span> length [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre></div>
<h5 id="what-is-the-type-of-the-expression-2-3-5-what-would-we-expect-as-a-result">5. What is the type of the expression 2 + 3 == 5? What would we expect as a result?</h5>
<p>Type: <strong>Bool</strong> and value <strong>True</strong></p>
<h5 id="below-are-some-bits-of-code.-which-will-work-why-or-why-not-if-they-will-work-what-value-would-these-reduce-to">7. Below are some bits of code. Which will work? Why or why not? If they will work, what value would these reduce to?</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> length allAwesome <span class="fu">==</span> <span class="dv">2</span> <span class="co">-- True</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> length [<span class="dv">1</span>, <span class="ch">&#39;a&#39;</span>, <span class="dv">3</span>, <span class="ch">&#39;b&#39;</span>] <span class="co">-- FAILS: list contains values of varying type</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> length allAwesome <span class="fu">+</span> length awesome <span class="co">-- 5</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dv">8</span> <span class="fu">==</span> <span class="dv">8</span>) <span class="fu">&amp;&amp;</span> (<span class="ch">&#39;b&#39;</span> <span class="fu">&lt;</span> <span class="ch">&#39;a&#39;</span>) <span class="co">-- False</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dv">8</span> <span class="fu">==</span> <span class="dv">8</span>) <span class="fu">&amp;&amp;</span> <span class="dv">9</span> <span class="co">-- FAILS: 9 is not of type Bool and (&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool</span></code></pre></div>
<h5 id="write-a-function-that-tells-you-whether-or-not-a-given-string-or-list-is-a-palindrome.-here-youll-want-to-use-a-function-called-reverse-a-predefined-function-that-does-just-what-it-sounds-like.">8. Write a function that tells you whether or not a given String (or list) is a palindrome. Here you’ll want to use a function called ’reverse,’ a predefined function that does just what it sounds like.</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isPalindrome ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isPalindrome x <span class="fu">=</span> x <span class="fu">==</span> reverse x</code></pre></div>
<h5 id="write-a-function-to-return-the-absolute-value-of-a-number-using-if-then-else">9. Write a function to return the absolute value of a number using if-then-else</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myAbs ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> myAbs <span class="fu">=</span> undefined
myAbs x <span class="fu">=</span> <span class="kw">if</span> (x <span class="fu">&gt;=</span> <span class="dv">0</span>) <span class="kw">then</span> x <span class="kw">else</span> <span class="fu">-</span>x</code></pre></div>
<h5 id="fill-in-the-definition-of-the-following-function-using-fst-and-snd">10. Fill in the definition of the following function, using fst and snd:</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> (a, b) <span class="ot">-&gt;</span> (c, d) <span class="ot">-&gt;</span> ((b, d), (a, c))
f x y <span class="fu">=</span> ((snd x, snd y), (fst x, fst y))</code></pre></div>
<h5 id="match-the-functions-to-their-types">Match the functions to their types</h5>
<ol>
<li>Which of the following types is the type of <code>show</code>?</li>
</ol>
<ul>
<li>[ ] <code>show a =&gt; a -&gt; String</code></li>
<li>[ ] <code>Show a -&gt; a -&gt; String</code></li>
<li>[x] <code>Show a =&gt; a -&gt; String</code></li>
</ul>
<ol>
<li>Which of the following types is the type of <code>(==)</code>?</li>
</ol>
<ul>
<li>[ ] a -&gt; a -&gt; Bool`</li>
<li>[x] Eq a =&gt; a -&gt; a -&gt; Bool`</li>
<li>[ ] Eq a -&gt; a -&gt; a -&gt; Bool`</li>
<li>[ ] Eq a =&gt; A -&gt; Bool`</li>
</ul>
<ol>
<li>Which of the following types is the type of <code>fst</code>?</li>
</ol>
<ul>
<li>[x] <code>(a, b) -&gt; a</code></li>
<li>[ ] <code>b -&gt; a</code></li>
<li>[ ] <code>(a, b) -&gt; b</code></li>
</ul>
<ol>
<li>Which of the following types is the type of <code>(+)</code>?</li>
</ol>
<ul>
<li>[ ] <code>(+) :: Num a -&gt; a -&gt; a -&gt; Bool</code></li>
<li>[ ] <code>(+) :: Num a =&gt; a -&gt; a -&gt; Bool</code></li>
<li>[ ] <code>(+) :: num a =&gt; a -&gt; a -&gt; a</code></li>
<li>[x] <code>(+) :: Num a =&gt; a -&gt; a -&gt; a</code></li>
<li>[ ] <code>(+) :: a -&gt; a -&gt; a</code></li>
</ul>
<h3 id="definitions">4.10 Definitions</h3>
<p><em>Arity</em> is the number of arguments a function accepts</p>
<p><em>Polymorphism</em> in Haskell means being able to write code in terms of values which may be one of several, or any, type.<br />
Polymorphism in Haskell is either parametric or constrained.<br />
The identity function, <code>id</code>, is an example of a parametrically polymorphic function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class="ot"> ::</span> a <span class="ot">-&gt;</span> a
id x <span class="fu">=</span> x</code></pre></div>
<p>Here <code>id</code> works for a value of any type because it doesn’t use any information specific to a given type or set of types.<br />
Whereas,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isEqual ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isEqual x y <span class="fu">=</span> x <span class="fu">==</span> y</code></pre></div>
<p>is polymorphic, but constrained or bounded to the set of types which have an instance of the <code>Eq</code> typeclass.<br />
(To be discussed more in later chapters.)</p>
<h1 id="types">Types</h1>
<h3 id="reading-type-signatures">5.3 Reading type signatures</h3>
<h4 id="understanding-the-function-type">Understanding the function type</h4>
<p><code>(-&gt;)</code> is the type constructor for functions. It takes arguments, but has no data constructors. See it compared to others:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>info (,)
<span class="kw">data</span> (,) a b <span class="fu">=</span> (,) a b  <span class="co">-- Defined in ‘GHC.Tuple’</span>

λ<span class="fu">:</span> <span class="fu">:</span>info <span class="dt">Bool</span>
<span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> <span class="dt">True</span>  <span class="co">-- Defined in ‘GHC.Types’</span>

λ<span class="fu">:</span> <span class="fu">:</span>info (<span class="ot">-&gt;</span>)
<span class="kw">data</span> (<span class="ot">-&gt;</span>) a b   <span class="co">-- Defined in ‘GHC.Prim’</span></code></pre></div>
<p>The tuple constructor needs two values to construct a tuple. A function similarly has two arguments (input &amp; result), however there are no data constructors. The value at the term level is the function - <em>functions are values</em>.</p>
<p>The unique hallmark of a function is that it can be <em>applied</em>. The array type constructor is an <em>infix</em> operator associating to the right (even though application is left associative).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fst<span class="ot"> ::</span> (a, b)   <span class="ot">-&gt;</span>   a
<span class="co">--       [1]    [2] [3]</span></code></pre></div>
<ol>
<li>First parameter has type <code>(a,b)</code></li>
<li>The infix type constructor accepting two parameters: <code>(a,b)</code> and <code>a</code></li>
<li>The result of type <code>a</code> -- the same <code>a</code> from <code>(a,b)</code></li>
</ol>
<p>That <code>a</code> is literally the same value, as the type signature shows us that nothing can possibly happen between input and output to that value with type <code>a</code>. Again -- formal explanation coming later on.</p>
<h4 id="exercises-type-matching">Exercises: Type Matching</h4>
<ul>
<li>Functions:</li>
</ul>
<ol>
<li><code>not</code></li>
<li><code>length</code></li>
<li><code>concat</code></li>
<li><code>head</code></li>
<li><code>(&lt;)</code></li>
</ol>
<ul>
<li>Type signatures:</li>
</ul>
<ol>
<li><code>_ :: [a] -&gt; a</code></li>
<li><code>_ :: [[a]] -&gt; [a]</code></li>
<li><code>_ :: Bool -&gt; Bool</code></li>
<li><code>_ :: [a] -&gt; Int</code></li>
<li><code>_ :: Ord a =&gt; a -&gt; a -&gt; Bool</code></li>
</ol>
<p><strong>i -&gt; iii | ii -&gt; iv | iii -&gt; ii | iv -&gt; i | v -&gt; v</strong></p>
<h3 id="currying">5.4 Currying</h3>
<p>Just like the lambda calculus, all Haskell functions are curried, meaning there are no functions that accept multiple arguments. There are just nested functions that intermediately return a function accepting a single parameter.</p>
<p>The way the type constructor <code>(-&gt;)</code> is defined makes currying the default. It is infix and right associative -- so</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="co">-- associates to</span>
<span class="ot">f ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a)</code></pre></div>
<p>which demonstrates currying very clearly. When we pass a single value to this function of type <code>a</code>, we get back a function of type <code>(a -&gt; a)</code>.</p>
<h4 id="manual-currying-and-uncurrying">Manual currying and uncurrying</h4>
<p><em>Uncurrying</em> means un-nesting functions by replacing nested functions with tuples. For example, to uncurry <code>(+)</code>, we'd define it as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">uncAdd ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> (a, a) <span class="ot">-&gt;</span> a
uncAdd (x, y) <span class="fu">=</span> x <span class="fu">+</span> y</code></pre></div>
<p>To automate this for functions with two args, we can define</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">curry<span class="ot"> ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c
curry f a b <span class="fu">=</span> f (a, b)

uncurry<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a, b) <span class="ot">-&gt;</span> c
uncurry f (a, b) <span class="fu">=</span> f a b</code></pre></div>
<p><strong>TODO</strong> Investigate automating this for all functions, for my own edification.</p>
<h4 id="sectioning">Sectioning</h4>
<p><em>Sectioning</em> is the partial application of infix operators which allows you to specify whether you are partially applying the first or second argument:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">5</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> twoToThe <span class="fu">=</span> (<span class="dv">2</span><span class="fu">^</span>)
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> square <span class="fu">=</span> (<span class="fu">^</span><span class="dv">2</span>)
<span class="dt">Prelude</span><span class="fu">&gt;</span> twoToThe <span class="dv">5</span>
<span class="dv">32</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> square <span class="dv">5</span>
<span class="dv">25</span></code></pre></div>
<p>Utilizing higher order functions, this can be used on functions of any arity. For instance</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="kw">let</span> f a b c d <span class="fu">=</span> (a <span class="fu">+</span> b <span class="fu">+</span> c) <span class="fu">-</span> d
λ<span class="fu">:</span> <span class="kw">let</span> add10 <span class="fu">=</span> (<span class="dv">10</span> <span class="ot">`f`</span>)
λ<span class="fu">:</span> <span class="kw">let</span> sub10 <span class="fu">=</span> (<span class="ot">`f`</span> <span class="dv">10</span>)</code></pre></div>
<p>will result in <code>add10</code> and <code>sub10</code> both of types <code>Num a =&gt; a -&gt; a -&gt; a -&gt; a</code>. But <code>add10</code> will add <code>10</code> to the first two args and subtract the last arg, whereas <code>sub10</code> will add all three of its args and then subtract <code>10</code>.</p>
<h4 id="exercises-type-arguments">Exercises: Type Arguments</h4>
<p>Given a function and its type, tell us what type results from applying some or all of the arguments.</p>
<ol>
<li>If the type of <code>f</code> is <code>a -&gt; a -&gt; a -&gt; a</code>, and the type of <code>x</code> is <code>Char</code> then the type of <code>f x</code> is</li>
</ol>
<ul>
<li>[x] <code>Char -&gt; Char -&gt; Char</code></li>
<li>[ ] <code>x -&gt; x -&gt; x -&gt; x</code></li>
<li>[ ] <code>a -&gt; a -&gt; a</code></li>
<li>[ ] <code>a -&gt; a -&gt; a -&gt; Char</code></li>
</ul>
<ol>
<li>If the type of <code>g</code> is <code>a -&gt; b -&gt; c -&gt; b</code>, then the type of <code>g 0 'c' &quot;woot&quot;</code> is</li>
</ol>
<ul>
<li>[ ] <code>String</code></li>
<li>[ ] <code>Char -&gt; String</code></li>
<li>[ ] <code>Int</code></li>
<li>[x] <code>Char</code></li>
</ul>
<ol>
<li>If the type of <code>h</code> is <code>(Num a, Num b) =&gt; a -&gt; b -&gt; b</code>, then the type of <code>h 1.0 2</code> is</li>
</ol>
<ul>
<li>[ ] <code>Double</code></li>
<li>[ ] <code>Integer</code></li>
<li>[ ] <code>Integral b =&gt; b</code></li>
<li>[x] <code>Num b =&gt; b</code></li>
</ul>
<ol>
<li>If the type of <code>kessel</code> is <code>(Ord a, Num b) =&gt; a -&gt; b -&gt; a</code>, then the type of <code>kessel (1 :: Integer) 2</code> is</li>
</ol>
<ul>
<li>[ ] <code>Num a =&gt; a</code></li>
<li>[ ] <code>Ord a =&gt; a</code></li>
<li>[x] <code>Integer</code></li>
<li>[ ] <code>(Num a, Ord a) =&gt; a</code></li>
<li>[ ] <code>a</code></li>
</ul>
<h3 id="polymorphism">5.5 Polymorphism</h3>
<p>Type signatures may have three kinds of types: <em>concrete</em>, <em>constrained polymorphic</em>, or <em>parametrically polymorphic</em>.</p>
<p><strong>Constrained polymorphism</strong> is what it sounds like -- constraining type variables via typeclasses such as <code>Num</code> or <code>Ord</code></p>
<p><strong>Parametric polymorphism</strong> is broader and refers to fully polymorphic type variables.</p>
<p>Constrained polymorphism decreases the number of concrete types a type variable can be, but increases what we can actually do with them by bringing into scope a set of operations from those typeclass constraints.</p>
<p>We can reason a <em>lot</em> about the type signatures of parametrically polymorphic functions. For instance <code>id :: a -&gt; a</code> can do nothing other than return <code>a</code> because there is no information or method attached to its parameter at all -- nothing can be done <em>with</em> <code>a</code>. If instead it had a typeclass constraint such as <code>negate :: (Num a) -&gt; a -&gt; a</code>, now <code>a</code> has fewer concrete types that it could be, but there is now a set of functions that can be used on <code>a</code> at the term level, so things <em>can</em> be done with <code>a</code>.</p>
<p>Simply, if a variable can be <em>anything</em>, then there's very little that can be done to it because it has no methods. If it can be <em>some</em> types such as a type that is an instance of typeclass <code>Num</code>, then it has some methods.</p>
<h4 id="exercises-parametricity">Exercises: Parametricity</h4>
<h5 id="we-can-get-a-more-comfortable-appreciation-of-parametricity-by-looking-at-a---a---a.-this-hypothetical-function-a---a---a-has-twoand-only-twoimplementations.-write-both-possible-versions-of-a---a---a.">2. We can get a more comfortable appreciation of parametricity by looking at <code>a -&gt; a -&gt; a</code>. This hypothetical function <code>a -&gt; a -&gt; a</code> has two–and only two–implementations. Write both possible versions of <code>a -&gt; a -&gt; a</code>.</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">x ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
x j k <span class="fu">=</span> j

<span class="ot">y ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
y j k <span class="fu">=</span> k</code></pre></div>
<h5 id="implement-a---b---b.-how-many-implementations-can-it-have-does-the-behavior-change-when-the-types-of-a-and-b-change">3. Implement <code>a -&gt; b -&gt; b</code>. How many implementations can it have? Does the behavior change when the types of <code>a</code> and <code>b</code> change?</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">x ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b
x j k <span class="fu">=</span> k</code></pre></div>
<p>Just <strong>1</strong> implementation. Defined parametrically, the behavior stays the same for all types.</p>
<h4 id="polymorphic-constants">Polymorphic Constants</h4>
<p>All values are given <em>maximum polymorphism</em>: <code>(-10)</code> has type <code>Num a =&gt; a</code>, which is as broad as Haskell can be in evaluating its type. This is called a <em>polymorphic constant</em> (<strong>why?</strong>). It will only resolve to a concrete type when it is forced to evaluate.</p>
<h3 id="type-inference">5.6 Type inference</h3>
<p>Haskell’s type inference is an algorithm built on an extended version of the Damas-Hindley-Milner type system. Haskell will infer the most generally applicable (polymorphic) type that is still correct.</p>
<h4 id="exercises-determine-inferred-types">Exercises: Determine inferred types</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Type signature of general function</span>
<span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="co">-- How might that change when we apply</span>
<span class="co">-- it to the following value?</span>
myConcat x <span class="fu">=</span> x <span class="fu">++</span> <span class="st">&quot; yo&quot;</span></code></pre></div>
<p>Changes to <code>[Char] -&gt; [Char] -&gt; [Char]</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- General function</span>
<span class="ot">(*) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="co">-- Applied to a value</span>
myMult x <span class="fu">=</span> (x <span class="fu">/</span> <span class="dv">3</span>) <span class="fu">*</span> <span class="dv">5</span></code></pre></div>
<p>Changes to `(Fractional a) =&gt; a -&gt; a -&gt; a</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">take<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
myTake x <span class="fu">=</span> take x <span class="st">&quot;hey you&quot;</span></code></pre></div>
<p>Changes to <code>Int -&gt; [Char] -&gt; [Char]</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
myCom x <span class="fu">=</span> x <span class="fu">&gt;</span> (length [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>])</code></pre></div>
<p>Changes to <code>Int -&gt; Int -&gt; Bool</code></p>
<h3 id="chapter-exercises">5.8 Chapter Exercises</h3>
<h4 id="type-kwon-do">Type-Kwon-Do</h4>
<p>Manipulate terms in order to get the types to fit.</p>
<h5 id="section">1.</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
f <span class="fu">=</span> undefined

<span class="ot">g ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
g <span class="fu">=</span> undefined

<span class="ot">h ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
h <span class="fu">=</span> g <span class="fu">.</span> f <span class="co">-- answer</span></code></pre></div>
<h5 id="section-1">2.</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">A</span>
<span class="kw">data</span> <span class="dt">B</span>
<span class="kw">data</span> <span class="dt">C</span>

<span class="ot">q ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span>
q <span class="fu">=</span> undefined

<span class="ot">w ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">C</span>
w <span class="fu">=</span> undefined

<span class="ot">e ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">C</span>
e <span class="fu">=</span> w <span class="fu">.</span> q <span class="co">-- answer</span></code></pre></div>
<h5 id="section-2">4.</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">munge ::</span> (x <span class="ot">-&gt;</span> y) <span class="ot">-&gt;</span> (y <span class="ot">-&gt;</span> (w, z)) <span class="ot">-&gt;</span> x <span class="ot">-&gt;</span> w
munge xToy yTowz a <span class="fu">=</span> fst <span class="fu">$</span> yTowz (xToy a)</code></pre></div>
<h1 id="typeclasses">Typeclasses</h1>
<h3 id="eq">6.4 Eq</h3>
<h4 id="typeclass-deriving">Typeclass deriving</h4>
<p>Typeclass instances we can magically derive are Eq, Ord, Enum, Bounded, Read, and Show, though there are some constraints on deriving some of these.</p>
<h4 id="partial-functions">Partial functions</h4>
<p>A <em>partial function</em> is one that doesn't handle all the possible cases of input, such as</p>
<pre><code>addOne :: Int -&gt; Int
addOne 0 = 1
addOne 1 = 2</code></pre>
<p>We can catch these <strong>at compile time</strong> if we enable all warnings via GHC flag <code>Wall</code>.</p>
<h4 id="exercises-write-the-eq-instance-for-each-datatype">Exercises: Write the <code>Eq</code> instance for each datatype</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TwoIntegers</span> <span class="fu">=</span>
  <span class="dt">Two</span> <span class="dt">Integer</span> <span class="dt">Integer</span>

<span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">TwoIntegers</span> <span class="kw">where</span>
  (<span class="dt">Two</span> j k) <span class="fu">==</span> (<span class="dt">Two</span> l m) <span class="fu">=</span> j <span class="fu">==</span> l <span class="fu">&amp;&amp;</span> k <span class="fu">==</span> m
  _ <span class="fu">==</span> _ <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">data</span> <span class="dt">StringOrInt</span> <span class="fu">=</span>
    <span class="dt">TisAnInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">TisAString</span> <span class="dt">String</span>

<span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">StringOrInt</span> <span class="kw">where</span>
  <span class="dt">TisAnInt</span> x <span class="fu">==</span> <span class="dt">TisAnInt</span> y <span class="fu">=</span> x <span class="fu">==</span> y
  <span class="dt">TisAString</span> s <span class="fu">==</span> <span class="dt">TisAString</span> t <span class="fu">=</span> s <span class="fu">==</span> t
  _ <span class="fu">==</span> _ <span class="fu">=</span> <span class="dt">False</span>


<span class="kw">data</span> <span class="dt">Pair</span> a <span class="fu">=</span>
  <span class="dt">Pair</span> a a

<span class="kw">instance</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Pair</span> a) <span class="kw">where</span>
  <span class="dt">Pair</span> j k <span class="fu">==</span> <span class="dt">Pair</span> l m <span class="fu">=</span> j <span class="fu">==</span> l <span class="fu">&amp;&amp;</span> k <span class="fu">==</span> m
  _ <span class="fu">==</span> _ <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">data</span> <span class="dt">EitherOr</span> a b <span class="fu">=</span>
  <span class="dt">Hello</span> a
  <span class="fu">|</span> <span class="dt">Goodbye</span> b

<span class="kw">instance</span> (<span class="dt">Eq</span> a, <span class="dt">Eq</span> b) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">EitherOr</span> a b) <span class="kw">where</span>
  <span class="dt">Hello</span> x <span class="fu">==</span> <span class="dt">Hello</span> y <span class="fu">=</span> x <span class="fu">==</span> y
  <span class="dt">Goodbye</span> x <span class="fu">==</span> <span class="dt">Goodbye</span> y <span class="fu">=</span> x <span class="fu">==</span> y
  _ <span class="fu">==</span> _ <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<h3 id="chapter-exercises-1">6.14 Chapter Exercises</h3>
<h4 id="does-it-typecheck">Does it typecheck?</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> <span class="dt">Bool</span>
<span class="ot">printPerson ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
printPerson person <span class="fu">=</span> putStrLn (show person)</code></pre></div>
<p><strong>No</strong>, <code>Person</code> has no instance of the <code>Show</code> typeclass.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Mood</span> <span class="fu">=</span> <span class="dt">Blah</span> <span class="fu">|</span> <span class="dt">Woot</span> <span class="kw">deriving</span> <span class="dt">Show</span>
settleDown x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">==</span> <span class="dt">Woot</span>
                 <span class="kw">then</span> <span class="dt">Blah</span>
                 <span class="kw">else</span> x</code></pre></div>
<p><strong>No</strong>, <code>Mood</code> has no instance of the <code>Eq</code> typeclass.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Subject</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Verb</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Object</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">data</span> <span class="dt">Sentence</span> <span class="fu">=</span>
<span class="dt">Sentence</span> <span class="dt">Subject</span> <span class="dt">Verb</span> <span class="dt">Object</span>
<span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
s1 <span class="fu">=</span> <span class="dt">Sentence</span> <span class="st">&quot;dogs&quot;</span> <span class="st">&quot;drool&quot;</span>
s2 <span class="fu">=</span> <span class="dt">Sentence</span> <span class="st">&quot;Julie&quot;</span> <span class="st">&quot;loves&quot;</span> <span class="st">&quot;dogs&quot;</span></code></pre></div>
<p><strong>Yes</strong>, nothing wrong with this, but <code>s1</code> is a partially applied data constructor of type <code>Object -&gt; Sentence</code>.</p>
<h4 id="typechecking-datatypes">Typechecking datatypes</h4>
<p>Given</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Rocks</span> <span class="fu">=</span> <span class="dt">Rocks</span> <span class="dt">String</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Yeah</span> <span class="fu">=</span> <span class="dt">Yeah</span> <span class="dt">Bool</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Papu</span> <span class="fu">=</span> <span class="dt">Papu</span> <span class="dt">Rocks</span> <span class="dt">Yeah</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>which of the following typechecks?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">phew <span class="fu">=</span> <span class="dt">Papu</span> <span class="st">&quot;chases&quot;</span> <span class="dt">True</span>
<span class="co">-- No, this is missing data construtors for Rocks and Yeah</span>

truth <span class="fu">=</span> <span class="dt">Papu</span> (<span class="dt">Rocks</span> <span class="st">&quot;chomskydoz&quot;</span>) (<span class="dt">Yeah</span> <span class="dt">True</span>)
<span class="co">-- Yes this is fine</span>

<span class="ot">equalityForall ::</span> <span class="dt">Papu</span> <span class="ot">-&gt;</span> <span class="dt">Papu</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
equalityForall p p&#39; <span class="fu">=</span> p <span class="fu">==</span> p&#39;
<span class="co">-- This is fine but unnecessary since it is equivalent to ==</span>

<span class="ot">comparePapus ::</span> <span class="dt">Papu</span> <span class="ot">-&gt;</span> <span class="dt">Papu</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
comparePapus p p&#39; <span class="fu">=</span> p <span class="fu">&gt;</span> p&#39;
<span class="co">-- No, there is no instance of the Ord typeclass</span></code></pre></div>
<h1 id="more-functional-patterns">More Functional Patterns</h1>
<h3 id="arguments-and-parameters">7.2 Arguments and parameters</h3>
<h4 id="binding-variables-to-values">Binding variables to values</h4>
<p>Binding of variables can occur through function application, and <code>let</code> and <code>where</code> expressions. Parameters are bound to the values applied to a function throughout the entire scope of the function body, while variables bound by <code>let</code> and <code>where</code> expressions are only in scope <em>inside</em> the given expression.</p>
<p>In some cases, function arguments are not visible in the function if they have been <strong>shadowed</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bindExp ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
bindExp x <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">10</span>; y <span class="fu">=</span> <span class="dv">5</span> <span class="kw">in</span>
  <span class="st">&quot;the integer was: &quot;</span> <span class="fu">++</span> show x
  <span class="fu">++</span> <span class="st">&quot; and y was: &quot;</span> <span class="fu">++</span> show y</code></pre></div>
<p>The reference to <code>x</code> arising from the argument <code>x</code> is shadowed by the <code>x</code> in the <code>let</code> binding, because the definition of <code>x</code> that is &quot;innermost&quot; in the code takes precedence. This is because Haskell is <strong>lexically scoped</strong>, meaning that resolving a value for a variable depends on the location in the code and the lexical context, for example in <code>let</code> and <code>where</code> clauses.</p>
<h4 id="exercises-grab-bag">Exercises: Grab Bag</h4>
<h5 id="which-two-or-more-of-the-following-are-equivalent">1. Which (two or more) of the following are equivalent?</h5>
<ul>
<li>[x] <code>mTh x y z = x * y * z</code></li>
<li>[x] <code>mTh x y = \z -&gt; x * y * z</code></li>
<li>[x] <code>mTh x = \y -&gt; \z -&gt; x * y * z</code></li>
<li>[x] <code>mTh = \x -&gt; \y -&gt; \z -&gt; x * y * z</code></li>
</ul>
<h5 id="the-type-of-mth-above-is-num-a-a---a---a---a.-which-is-the-type-of-mth-3">2. The type of <code>mTh</code> (above) is <code>Num a =&gt; a -&gt; a -&gt; a -&gt; a</code>. Which is the type of <code>mTh 3</code>?</h5>
<ul>
<li>[ ] <code>Integer -&gt; Integer -&gt; Integer</code></li>
<li>[ ] <code>Num a =&gt; a -&gt; a -&gt; a -&gt; a</code></li>
<li>[ ] <code>Num a =&gt; a -&gt; a</code></li>
<li>[x] <code>Num a =&gt; a -&gt; a -&gt; a</code></li>
</ul>
<h4 id="utility-of-lambda-syntax">Utility of lambda syntax</h4>
<p><strong>Keep in mind</strong> that named entities and anonymous entities evaluate differently in Haskell: <strong>details to follow</strong>.</p>
<h3 id="pattern-matching">7.4 Pattern matching</h3>
<p>Remember <strong>always handle all cases</strong>. Partial functions are a <strong>no go</strong>. Eventually, they will fail and return <em>bottom</em>, a non-value that will result in an exception. Remember <code>-Wall</code> GHCi setting will help catch these.</p>
<h3 id="case-expressions">7.5 Case expressions</h3>
<h4 id="exercises-case-practice">Exercises: Case Practice</h4>
<h5 id="rewrite-functionc-x-y-if-x-y-then-x-else-y-using-case-expressions">1. Rewrite <code>functionC x y = if (x &gt; y) then x else y</code> using case expressions</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">functionC x y <span class="fu">=</span> <span class="kw">case</span> (x <span class="fu">&gt;</span> y) <span class="kw">of</span>
  <span class="dt">True</span>  <span class="ot">-&gt;</span> x
  <span class="dt">False</span> <span class="ot">-&gt;</span> y</code></pre></div>
<h5 id="rewrite-ifevenadd2-n-if-even-n-then-n2-else-n-using-case-expressions">2. Rewrite <code>ifEvenAdd2 n = if even n then (n+2) else n</code> using case expressions</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ifEvenAdd2 n <span class="fu">=</span> <span class="kw">case</span> (even n) <span class="kw">of</span>
  <span class="dt">True</span>  <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dv">2</span>
  <span class="dt">False</span> <span class="ot">-&gt;</span> n</code></pre></div>
<h5 id="fix-the-following-function-to-cover-all-cases">3. Fix the following function to cover all cases</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">nums x <span class="fu">=</span>
  <span class="kw">case</span> compare x <span class="dv">0</span> <span class="kw">of</span>
    <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="fu">-</span><span class="dv">1</span>
    <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dv">1</span>
    <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dv">0</span> <span class="co">-- added EQ case, which covers all data constructors of type Ordering</span></code></pre></div>
<h3 id="higher-order-functions">7.6 Higher-order functions</h3>
<p>When we want to express a function argument within a function type, we must use parentheses to nest it, such as <code>flip</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">flip<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
flip f x y <span class="fu">=</span> f y x</code></pre></div>
<h4 id="exercises-artful-dodgy">Exercises: Artful Dodgy</h4>
<p>Given</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dodgy x y <span class="fu">=</span> x <span class="fu">+</span> y <span class="fu">*</span> <span class="dv">10</span>
oneIsOne <span class="fu">=</span> dodgy <span class="dv">1</span>
oneIsTwo <span class="fu">=</span> (flip dodgy) <span class="dv">2</span></code></pre></div>
<p>give normalized values for the following</p>
<ol>
<li><code>dodgy 1 2</code> <strong>= 21</strong></li>
<li><code>oneIsTwo 2</code> <strong>= 22</strong></li>
<li><code>oneIsOne 3</code> <strong>= 31</strong></li>
</ol>
<h3 id="guards">7.7 Guards</h3>
<p>Guard syntax allows us to write compact functions that allow for two or more possible outcomes depending on the truth of the conditions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myAbs ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
myAbs x
  <span class="fu">|</span> x <span class="fu">&lt;</span> <span class="dv">0</span>     <span class="fu">=</span> (<span class="fu">-</span>x)
  <span class="fu">|</span> otherwise <span class="fu">=</span> x</code></pre></div>
<h3 id="function-composition">7.8 Function composition</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</code></pre></div>
<p>Just keep in mind <strong>precedence</strong> of function application (10/10) is greater than composition operator (9/10). Consequentially:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- works</span>
negate <span class="fu">.</span> sum <span class="fu">$</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>] <span class="co">-- -15</span>

<span class="co">--works</span>
(negate <span class="fu">.</span> sum) [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>] <span class="co">-- -15</span>

<span class="co">--TYPE ERROR</span>
negate <span class="fu">.</span> sum [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]
negate <span class="fu">.</span> <span class="dv">15</span> <span class="co">-- composing (Num a =&gt; a -&gt; a) with (Num a =&gt; a)</span></code></pre></div>
<p>When composing more and more functions, the lack of parentheses is more and more useful:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> take <span class="dv">5</span> <span class="fu">.</span> filter odd <span class="fu">.</span> enumFrom <span class="fu">$</span> <span class="dv">3</span>
[<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>]</code></pre></div>
<h3 id="pointfree-style">7.9 Pointfree style</h3>
<p>Pointfree refers to a style of composing functions without specifying their arguments. This let's us focus on <em>functions</em> rather than <em>data</em>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f xs <span class="fu">=</span> negate <span class="fu">.</span> sum <span class="fu">$</span> xs
f <span class="fu">=</span> negate <span class="fu">.</span> sum

g z xs <span class="fu">=</span> foldr (<span class="fu">+</span>) z xs
g <span class="fu">=</span> foldr (<span class="fu">+</span>)

print a <span class="fu">=</span> putStrLn (show a)
print <span class="fu">=</span> putStrLn <span class="fu">.</span> show</code></pre></div>
<h3 id="chapter-exercises-2">7.11 Chapter Exercises</h3>
<h4 id="multiple-choice">Multiple choice</h4>
<h5 id="two-functions-named-f-and-g-have-types-char---string-and-string---string-respectively.-the-composed-function-g-.-f-has-the-type">2. Two functions named <code>f</code> and <code>g</code> have types <code>Char -&gt; String</code> and <code>String -&gt; [String]</code> respectively. The composed function <code>g . f</code> has the type</h5>
<ul>
<li>[ ] <code>Char -&gt; String</code></li>
<li>[x] <code>Char -&gt; [String]</code></li>
<li>[ ] <code>[[String]]</code></li>
<li>[ ] <code>Char -&gt; String -&gt; [String]</code></li>
</ul>
<h5 id="a-function-f-has-the-type-ord-a-a---a---bool-and-we-apply-it-to-one-numeric-value.-what-is-the-type-now">3. A function <code>f</code> has the type <code>Ord a =&gt; a -&gt; a -&gt; Bool</code> and we apply it to one numeric value. What is the type now?</h5>
<ul>
<li>[ ] <code>Ord a =&gt; a -&gt; Bool</code></li>
<li>[ ] <code>Num -&gt; Num -&gt; Bool</code></li>
<li>[ ] <code>Ord a =&gt; a -&gt; a -&gt; Integer</code></li>
<li>[x] <code>(Ord a, Num a) =&gt; a -&gt; Bool</code></li>
</ul>
<h5 id="a-function-with-the-type-a---b---c">4. A function with the type <code>(a -&gt; b) -&gt; c</code></h5>
<ul>
<li>[ ] requires values of three different types</li>
<li>[x] is a higher-order function</li>
<li>[ ] must take a tuple as its first argument</li>
<li><p>[ ] has its parameters in alphabetical order (the type variables in signature are <strong>not parameters</strong>)</p>
<h1 id="recursion">Recursion</h1>
<p><strong>Recursion</strong> is defining a function in terms of itself via self-referential expressions. But the lambda calculus does not appear on the surface to have any means of recursion, because of the anonymity of expressions. Being able to write recursive functions, though, is essential to Turing completeness.</p></li>
</ul>
<p>We use a combinator – known as the <em>Y combinator</em> or fixed-point combinator – to write recursive functions in the lambda calculus. Haskell has native recursion ability based on the same principle as the Y combinator. <a href="http://mvanier.livejournal.com/2897.html">[Reference]</a></p>
<h4 id="another-way-to-look-at-recursion">Another way to look at recursion</h4>
<p>Recall composition</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</code></pre></div>
<p>Recursion is simply <em>self-referential composition</em>. The difference between recursion and <code>(.)</code> is that instead of a fixed number of function applications, recursivce functions rely on inputs to determine when to stop applying functions to successive results.</p>
<h3 id="bottom">8.3 Bottom</h3>
<p>⊥ or <strong>bottom</strong> is a term used in Haskell to refer to computations that do not successfully result in a value. The main forms of bottom are computations that failed with an error or those that failed to terminate.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Exception: blah</span>
<span class="ot">f ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f <span class="dt">True</span> <span class="fu">=</span> error <span class="st">&quot;blah&quot;</span>
f <span class="dt">False</span> <span class="fu">=</span> <span class="dv">0</span>

<span class="co">-- Exception: Non-exhaustive patterns in function f</span>
<span class="ot">f ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f <span class="dt">False</span> <span class="fu">=</span> <span class="dv">0</span></code></pre></div>
<h3 id="integral-division-from-scratch">8.5 Integral division from scratch</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dividedBy ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
dividedBy num denom <span class="fu">=</span> fst <span class="fu">$</span> go num denom <span class="dv">0</span>
  <span class="kw">where</span> go n d i
          <span class="fu">|</span> n <span class="fu">&lt;</span> d     <span class="fu">=</span> (i, n)
          <span class="fu">|</span> otherwise <span class="fu">=</span> go (n <span class="fu">-</span> d) d (i <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<p>This <code>go</code> function is a common Haskell idiom to define an intermediary function in a <code>where</code> clause to accept more arguments than the top level function -- here, this is done to keep track of the recursion count.</p>
<h3 id="chapter-exercises-3">8.6 Chapter Exercises</h3>
<p>Located in <code>.hs</code> files of this directory. See <a href="./WordNumber.hs">WordNumber</a> for the first nontrivial exercise of this book.</p>
<h1 id="lists">Lists</h1>
<p>Lists serve two purposes:</p>
<ul>
<li>as collection/purality of values</li>
<li>as infinite series acting as stream datatype</li>
</ul>
<h3 id="the-list-datatype">9.2 The list datatype</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> [] a <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> [a]</code></pre></div>
<ul>
<li>So <code>[]</code> is the type constructor for lists and the data constructor for the empty list.</li>
<li>The <code>[]</code> data constructor is a <em>nullary</em> constructor as it takes no arguments.</li>
<li>The <code>:</code> data constructor is an infix operator called <em>cons</em>, taking a value of type <code>a</code> and a list of type <code>[a]</code> (recursive definition).</li>
<li>The list datatype itself is a sum type, but the data constructor <code>:</code> is a product type since it takes two arguments.</li>
</ul>
<h3 id="lists-syntactic-sugar">9.4 List's syntactic sugar</h3>
<p>Lists are often discussed in terms of <em>cons cells</em> and <em>spines</em>. The cons cell is the conceptual space that values may inhabit, while the spine is the connectice structure holding the cons cells together and in place. This structure actually nests cons cells rather them ordering them horizontally. The syntactic sugar for <code>(1 : 2 : 3 : []) == [1,2,3,4]</code> obscures this construction, but diferent functions treat the spine / cons cells differently, so it's important to keep in mind.</p>
<h3 id="using-ranges-to-construct-lists">9.5 Using ranges to construct lists</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]

λ<span class="fu">&gt;</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">10</span>]
[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]

<span class="co">-- Using three numbers [x,y..z] will go from x to z, in gaps of (y - z)</span>
λ<span class="fu">&gt;</span> [<span class="dv">2</span>,<span class="dv">4</span><span class="fu">..</span><span class="dv">10</span>]
[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>]

λ<span class="fu">&gt;</span> [<span class="dv">1</span>,<span class="dv">3</span><span class="fu">..</span><span class="dv">10</span>]
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>]</code></pre></div>
<p>Underlying functions of range syntax are:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- infinite starting at x</span>
<span class="co">-- [x..]</span>
enumFrom<span class="ot"> ::</span> <span class="dt">Enum</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a]

<span class="co">-- infinite  starting at x in gaps of y - x</span>
<span class="co">-- [x,y..]</span>
enumFromThen<span class="ot"> ::</span> <span class="dt">Enum</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]

<span class="co">-- finite from x to z</span>
<span class="co">-- [x..z]</span>
enumFromTo<span class="ot"> ::</span> <span class="dt">Enum</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]

<span class="co">-- finite from x to z in gaps of (y - x)</span>
<span class="co">-- [x,y..z]</span>
enumFromThenTo<span class="ot"> ::</span> <span class="dt">Enum</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</code></pre></div>
<h3 id="list-comprehensions">9.7 List comprehensions</h3>
<p>My favorite. Just keep in mind multiple lists are exhausted from the right first:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[x<span class="fu">^</span>y <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>], y <span class="ot">&lt;-</span> [<span class="dv">2</span>, <span class="dv">3</span>]]
<span class="co">-- = [1^2, 1^3, 2^2, 2^3, 3^2, 3^3]</span>
[(x,y) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>], y <span class="ot">&lt;-</span> [<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;b&#39;</span>]]
<span class="co">-- = [(1,&#39;a&#39;), (1,&#39;b&#39;), (2,&#39;a&#39;), (2,&#39;b&#39;)]</span></code></pre></div>
<h4 id="exercises-square-cube">Exercises: Square Cube</h4>
<p>Given the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> mySqr <span class="fu">=</span> [x<span class="fu">^</span><span class="dv">2</span> <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]]
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> myCube <span class="fu">=</span> [y<span class="fu">^</span><span class="dv">3</span> <span class="fu">|</span> y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]]</code></pre></div>
<h5 id="first-write-an-expression-that-will-make-tuples-of-the-outputs-of-mysqr-and-mycube.">1. First write an expression that will make tuples of the outputs of <code>mySqr</code> and <code>myCube</code>.</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[(s,c) <span class="fu">|</span> s <span class="ot">&lt;-</span> mySqr, c <span class="ot">&lt;-</span> myCube]</code></pre></div>
<h5 id="now-alter-that-expression-so-that-it-only-uses-the-x-and-y-values-that-are-less-than-50.">2. Now alter that expression so that it only uses the <code>x</code> and <code>y</code> values that are less than 50.</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[(s,c) <span class="fu">|</span> s <span class="ot">&lt;-</span> mySqr, c <span class="ot">&lt;-</span> myCube, s <span class="fu">&lt;</span> <span class="dv">50</span>, c <span class="fu">&lt;</span> <span class="dv">50</span>]</code></pre></div>
<h5 id="apply-another-function-to-that-list-comprehension-to-determine-how-many-tuples-inhabit-your-output-list.">3. Apply another function to that list comprehension to determine how many tuples inhabit your output list.</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">length [(s,c) <span class="fu">|</span> s <span class="ot">&lt;-</span> mySqr, c <span class="ot">&lt;-</span> myCube, s <span class="fu">&lt;</span> <span class="dv">50</span>, c <span class="fu">&lt;</span> <span class="dv">50</span>]</code></pre></div>
<h3 id="spines-and-nonstrict-evaluation">9.8 Spines and nonstrict evaluation</h3>
<p>When we talk about data structures in Haskell, particularly lists, sequences, and trees, we talk about them having a <strong>spine</strong>.</p>
<pre><code>   : &lt;------|
  / \       |
_    : &lt;----| This is the &quot;spine&quot;
    / \     |
   _   : &lt;--|
      / \
     _   []</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dv">1</span> <span class="fu">:</span> (<span class="dv">2</span> <span class="fu">:</span> (<span class="dv">3</span> <span class="fu">:</span> []))</code></pre></div>
<p>Note that <code>1</code> is not <em>before</em> the cons cell <code>(:)</code>; the cons cells contain the value. Because of this and the way nonstrict evaluation works, you can evaluate cons cells independently of what they contain.</p>
<p>Evaluation goes <em>down</em> the spine from <code>1</code> to <code>3</code> while construction goes <em>up</em> the spine from <code>3</code> to <code>1</code>.</p>
<p>Remember that due to laziness, the list isn't constructed until consumed. Up until then, it's just a series of placeholders. This is easily verified using <code>:spine</code> in GHCi.</p>
<h4 id="spines-are-evaluated-independently-of-values">Spines are evaluated independently of values</h4>
<p>Values in Haskell get reduced to weak head normal form by default, which is just enough evaluation necessary to reach a data constructor or await a function argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">\x <span class="ot">-&gt;</span> x <span class="fu">*</span> <span class="dv">10</span> <span class="co">-- WHNF &amp; NF</span>
(<span class="dv">1</span>, <span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="co">-- WHNF &amp; ! NF</span>
<span class="st">&quot;Papu&quot;</span> <span class="fu">++</span> <span class="st">&quot;chon&quot;</span> <span class="co">-- ! WHNF &amp; ! NF</span>
(<span class="dv">1</span>, <span class="st">&quot;Papu&quot;</span> <span class="fu">++</span> <span class="st">&quot;chon&quot;</span>) <span class="co">-- WHNF &amp; ! NF</span></code></pre></div>
<p>However, functions that are <em>spine strict</em> can force complete evaluation of the spine of the list even if they don’t force evaluation of each value. Pattern matching is strict by default, so pattern matching on cons cells can mean forcing spine strictness if your function doesn’t stop recursing the list. For example <code>length</code> is strict in the spine but not the values:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> length [<span class="dv">1</span>, undefined, <span class="dv">3</span>]
<span class="dv">3</span></code></pre></div>
<p>A common mantra for performance sensitive code in Haskell is <strong>lazy in the spine, strict in the leaves</strong>.</p>
<h4 id="bottom-madness-will-it-blow-up">Bottom Madness: will it blow up?</h4>
<h5 id="take-1-xy-x---1..5-y---2-undefined">2. <code>take 1 $ [x^y | x &lt;- [1..5], y &lt;- [2, undefined]]</code></h5>
<p>No</p>
<h5 id="sum-1-undefined-3">3. <code>sum [1, undefined, 3]</code></h5>
<p>Yes</p>
<h5 id="length-1-2-undefined">4. <code>length [1, 2, undefined]</code></h5>
<p>No</p>
<h5 id="length-1-2-3-undefined">5. <code>length $ [1, 2, 3] ++ undefined</code></h5>
<p>Yes</p>
<h5 id="take-1-filter-even-1-2-3-undefined">6. <code>take 1 $ filter even [1, 2, 3, undefined]</code></h5>
<p>No! Interesting, <code>filter</code> is lazy as well.. or at least contextually knows that it is being applied before <code>take</code>?</p>
<h5 id="take-1-filter-even-1-3-undefined">7. <code>take 1 $ filter even [1, 3, undefined]</code></h5>
<p>Yes</p>
<h5 id="take-1-filter-odd-1-3-undefined">8. <code>take 1 $ filter odd [1, 3, undefined]</code></h5>
<p>No</p>
<h5 id="take-2-filter-odd-1-3-undefined">9. <code>take 2 $ filter odd [1, 3, undefined]</code></h5>
<p>No</p>
<h5 id="take-3-filter-odd-1-3-undefined">10. <code>take 3 $ filter odd [1, 3, undefined]</code></h5>
<p>Yes</p>
<h4 id="intermission-is-it-in-normal-form">Intermission: Is it in normal form?</h4>
<ol>
<li><code>[1, 2, 3, 4, 5]</code></li>
</ol>
<p>NF</p>
<ol>
<li><code>1 : 2 : 3 : 4 : _</code></li>
</ol>
<p>WHNF</p>
<ol>
<li><code>enumFromTo 1 10</code></li>
</ol>
<p>Neither</p>
<ol>
<li><code>length [1, 2, 3, 4, 5]</code></li>
</ol>
<p>Neither</p>
<ol>
<li><code>sum (enumFromTo 1 10)</code></li>
</ol>
<p>Neither</p>
<ol>
<li><code>['a'..'m'] ++ ['n'..'z']</code></li>
</ol>
<p>Neither</p>
<ol>
<li><code>(_, 'b')</code></li>
</ol>
<p>WHNF</p>
<p>I say neither for the above cases because they have functions (that are not data constructors) with arguments applied yet not evaluated.</p>
<h3 id="transforming-lists-of-values">9.9 Transforming lists of values</h3>
<h4 id="exercises-more-bottoms">Exercises: More Bottoms</h4>
<h5 id="what-is-the-result-of-take-1-map-1-undefined-2-3">1. What is the result of <code>take 1 $ map (+1) [undefined, 2, 3]</code>?</h5>
<p>Blows up</p>
<h5 id="what-is-the-result-of-take-1-map-1-1-undefined-3">2. What is the result of <code>take 1 $ map (+1) [1, undefined, 3]</code>?</h5>
<p>returns [2]</p>
<h5 id="what-does-this-do-what-is-the-type-itismystery-xs-map-x---elem-x-aeiou-xs">4. What does this do? What is the type? <code>itIsMystery xs = map (\x -&gt; elem x &quot;aeiou&quot;) xs</code></h5>
<p>This takes a string and returns an array with a <code>Bool</code> value for each character depending on whether it is a vowel or not. The type is <code>itIsMystery :: [Char] -&gt; [Bool]</code>.</p>
<h3 id="filtering-lists-of-values">9.10 Filtering lists of values</h3>
<h5 id="given-the-above-how-might-we-write-a-filter-function-that-would-give-us-all-the-multiples-of-3-out-of-a-list-from-1-30">1. Given the above, how might we write a filter function that would give us all the multiples of 3 out of a list from 1-30?</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">filter ((<span class="fu">==</span><span class="dv">0</span>) <span class="fu">.</span> (<span class="ot">`mod`</span><span class="dv">3</span>)) [<span class="dv">1</span><span class="fu">..</span><span class="dv">30</span>] <span class="co">-- nice</span></code></pre></div>
<h5 id="recalling-what-we-learned-about-function-composition-how-could-we-compose-the-above-function-with-the-length-function-to-tell-us-how-many-multiples-of-3-there-are-between-1-and-30">2. Recalling what we learned about function composition, how could we compose the above function with the length function to tell us <em>how many</em> multiples of 3 there are between 1 and 30?</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">length <span class="fu">$</span> filter ((<span class="fu">==</span><span class="dv">0</span>) <span class="fu">.</span> (<span class="ot">`mod`</span><span class="dv">3</span>)) [<span class="dv">1</span><span class="fu">..</span><span class="dv">30</span>] <span class="co">-- or</span>
(length <span class="fu">.</span> filter ((<span class="fu">==</span><span class="dv">0</span>) <span class="fu">.</span> (<span class="ot">`mod`</span><span class="dv">3</span>))) [<span class="dv">1</span><span class="fu">..</span><span class="dv">30</span>]</code></pre></div>
<h5 id="make-a-function-that-removes-all-articles-the-a-and-an-from-sentences.">3. Make a function that removes all articles (’the’, ’a’, and ’an’) from sentences.</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">filterArticles ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
filterArticles <span class="fu">=</span> filter (\w <span class="ot">-&gt;</span> w <span class="fu">/=</span> <span class="st">&quot;an&quot;</span> <span class="fu">&amp;&amp;</span> w <span class="fu">/=</span> <span class="st">&quot;a&quot;</span> <span class="fu">&amp;&amp;</span> w <span class="fu">/=</span> <span class="st">&quot;the&quot;</span>) <span class="fu">.</span> words</code></pre></div>
<h3 id="zipping-lists">9.11 Zipping lists</h3>
<h4 id="zipping-exercises">Zipping exercises</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 1. Write your own version of zip :: [a] -&gt; [b] -&gt; [(a, b)] and</span>
<span class="co">--    ensure it behaves the same as the original.</span>
<span class="ot">zip&#39; ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a, b)]
zip&#39; _ []          <span class="fu">=</span> []
zip&#39; [] _          <span class="fu">=</span> []
zip&#39; (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y)<span class="fu">:</span>(zip&#39; xs ys)

<span class="co">-- 2. Do what you did for zip, but now for zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span>
<span class="ot">zipWith&#39; ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]
zipWith&#39; _ _ []          <span class="fu">=</span> []
zipWith&#39; _ [] _          <span class="fu">=</span> []
zipWith&#39; f (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (f x y)<span class="fu">:</span>(zipWith&#39; f xs ys)

<span class="co">-- 3. Rewrite your zip in terms of the zipWith you wrote.</span>

<span class="ot">zip&#39;&#39; ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a, b)]
zip&#39;&#39; <span class="fu">=</span> zipWith&#39; (,)</code></pre></div>
<h1 id="data-structure-origami">Data structure origami</h1>
<p>Similar to <code>reduce</code> in other languages, but way more badass due to laziness. Note that GHC 7.10 abstracted out the list-specific part of folding to a more reusable <code>Foldable</code> typeclass.</p>
<h3 id="recursive-patterns">10.3 Recursive patterns</h3>
<p>Notice the pattern of these definitions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot"> ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sum []     <span class="fu">=</span> <span class="dv">0</span>
sum (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> sum xs

length<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
length []     <span class="fu">=</span> <span class="dv">0</span>
length (_<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> length xs

<span class="co">-- and [myOr, myAny, myElem](../9_Lists/MyStandard.hs)</span></code></pre></div>
<ul>
<li>the base case is the identity for the function</li>
<li>each has a main function with a recursive pattern that <em>associates to the right</em> - the head of the list gets evaluated, set aside, and then the function moves to the right.</li>
</ul>
<p>Enter the fold:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- simple definition</span>
foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
foldr f z []     <span class="fu">=</span> z
foldr f z (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (foldr f z xs)</code></pre></div>
<h3 id="fold-right">10.4 Fold right</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] <span class="fu">=</span>
  <span class="kw">case</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] <span class="kw">of</span>
    []           <span class="ot">-&gt;</span> <span class="dv">0</span>
    (<span class="dv">1</span> <span class="fu">:</span> [<span class="dv">2</span>, <span class="dv">3</span>]) <span class="ot">-&gt;</span> (<span class="fu">+</span>) <span class="dv">1</span> (foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">2</span>, <span class="dv">3</span>])</code></pre></div>
<p>Note that <code>(foldr (+) 0 [2, 3])</code> is evaluated <strong>only</strong> because <code>(+)</code> is strict in both of its arguments. However, see what happens with <code>const</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr const <span class="dv">0</span> [<span class="dv">1</span>, undefined] <span class="fu">=</span>
  <span class="kw">case</span> [<span class="dv">1</span>, undefined] <span class="kw">of</span>
    []                <span class="ot">-&gt;</span> <span class="dv">0</span>
    (<span class="dv">1</span> <span class="fu">:</span> [undefined]) <span class="ot">-&gt;</span> const <span class="dv">1</span> (foldr const <span class="dv">0</span> [undefined])

<span class="co">-- Since const x _ = x, the rest of the fold (spine + folding) is never evaluated.</span></code></pre></div>
<p>Folding happens in two stages: traversal and folding. Traversal is the stage in which the fold recurses over the spine. Folding refers to the evaluation or reduction of the folding function applied to the values. The spine is always recursed in the same direction, but left/right folds differ in association of the folding function, and hence which direction the folding, or reduction, proceeds.</p>
<p>Given this two-stage process and non-strict evaluation, if <code>f</code> doesn’t evaluate its second argument (rest of the fold), no more of the spine will be forced -- so this can even be used for infinite lists, like we do with <code>take</code>.</p>
<p>The one part of this that is always strict is the pattern match on the first cons cell, discriminating the <code>[]</code> and <code>(x:xs)</code> cases. So the first cons cell <em>cannot</em> be undefined.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- undefined value is never evaluated</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> foldr (\_ _ <span class="ot">-&gt;</span> <span class="dv">9001</span>) <span class="dv">0</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, undefined]
<span class="dv">9001</span>

<span class="co">-- the cons cell are not bottom, just contain bottom !</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> foldr (\_ _ <span class="ot">-&gt;</span> <span class="dv">9001</span>) <span class="dv">0</span> [undefined, undefined]
<span class="dv">9001</span>

<span class="co">-- undefined cons cells of the spine are never evaluated</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> foldr (\_ _ <span class="ot">-&gt;</span> <span class="dv">9001</span>) <span class="dv">0</span> ([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] <span class="fu">++</span> undefined)
<span class="dv">9001</span>

<span class="co">-- initial cons cell is undefined !</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> foldr (\_ _ <span class="ot">-&gt;</span> <span class="dv">9001</span>) <span class="dv">0</span> (undefined <span class="fu">++</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.undefined</code></pre></div>
<h3 id="fold-left">10.5 Fold left</h3>
<p>The left fold can be defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldl<span class="ot"> ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
foldl f acc []     <span class="fu">=</span> acc
foldl f acc (x<span class="fu">:</span>xs) <span class="fu">=</span> foldl f (f acc x) xs</code></pre></div>
<p>To see the difference that association makes, we need to use a function that isn't associative:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr (<span class="fu">^</span>) <span class="dv">2</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]
(<span class="dv">1</span> <span class="fu">^</span> (<span class="dv">2</span> <span class="fu">^</span> (<span class="dv">3</span> <span class="fu">^</span> <span class="dv">2</span>)))
(<span class="dv">1</span> <span class="fu">^</span> (<span class="dv">2</span> <span class="fu">^</span> <span class="dv">9</span>))
<span class="dv">1</span> <span class="fu">^</span> <span class="dv">512</span>
<span class="dv">1</span>
<span class="co">-- while</span>
foldl (<span class="fu">^</span>) <span class="dv">2</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]
((<span class="dv">2</span> <span class="fu">^</span> <span class="dv">1</span>) <span class="fu">^</span> <span class="dv">2</span>) <span class="fu">^</span> <span class="dv">3</span>
(<span class="dv">2</span> <span class="fu">^</span> <span class="dv">2</span>) <span class="fu">^</span> <span class="dv">3</span>
<span class="dv">4</span> <span class="fu">^</span> <span class="dv">3</span>
<span class="dv">64</span></code></pre></div>
<p>Note that <code>scanr</code> and <code>scanl</code> are parallel to their fold functions, but return a list of intermediate values from the folding function, such that</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">last (scanl f z xs) <span class="fu">=</span> foldl f z xs
head (scanr f z xs) <span class="fu">=</span> foldr f z xs</code></pre></div>
<h4 id="unconditional-spine-recursion">Unconditional spine recursion</h4>
<p>It is important that the left fold has the accumulated steps of the fold as its first argument, not intermediated by the folding function as it is in <code>foldr</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr f acc (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (foldr f acc xs)
foldl f acc (x<span class="fu">:</span>xs) <span class="fu">=</span> foldl f (f acc x) xs</code></pre></div>
<p>In other words, <code>foldl</code> is <strong>tail recursive</strong>. No matter what the folding function is, <strong><code>foldl</code> always recurses the entire spine</strong>, unlike the laziness we saw at play with <code>foldr const</code>. This means that all cons cells must be well defined. However, values in the cons cells can still be undefined depending on the folding function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> foldl (\_ _ <span class="ot">-&gt;</span> <span class="dv">5</span>) <span class="dv">0</span> ([<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>] <span class="fu">++</span> undefined)
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.undefined
λ<span class="fu">&gt;</span> foldl (\_ _ <span class="ot">-&gt;</span> <span class="dv">5</span>) <span class="dv">0</span> ([<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>] <span class="fu">++</span> [undefined])
<span class="dv">5</span></code></pre></div>
<p>In general, don't use <code>foldl</code>. If it is needed, it is probably better to replace with <code>foldl'</code> which is explicitly strict -- explanation forthcoming in efficiency chapter.</p>
<h3 id="exercises-2">Exercises</h3>
<h5 id="what-does-the-following-mystery-function-do">2. What does the following mystery function do?</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">seekritFunc x <span class="fu">=</span>
  div (sum (map length (words x)))
    (length (words x))</code></pre></div>
<p>This gives the average length of word in a sentence (rounded down because <code>div</code> is integral).</p>
<h1 id="rule-the-types-rule-the-universe">Rule the types, rule the universe</h1>
<h3 id="data-declarations-review">11.2 Data declarations review</h3>
<p>Some vocabulary review:</p>
<ul>
<li><strong>nullary</strong> constructors are data or type constructors that take no arguments</li>
<li><strong>sum types</strong> denoted by pipes are types that have more than one constructor</li>
<li><strong>product types</strong> have data constructors with more than one parameter</li>
<li><strong>constants</strong> are just nullary constructors</li>
</ul>
<h3 id="whats-a-type-and-whats-data">11.6 What’s a type and what’s data?</h3>
<p>Some functionality review:</p>
<ul>
<li>types are <em>static</em> and resolve at <em>compile time</em></li>
<li>information about types <strong>does not persist through to runtime</strong></li>
</ul>
<h3 id="data-constructor-arities">11.7 Data constructor arities</h3>
<p><strong>arity</strong> refers to the number of arguments a function or constructor takes</p>
<h3 id="what-makes-these-datatypes-algebraic">11.8 What makes these datatypes algebraic?</h3>
<p>Algebraic datatypes in Haskell are algebraic because we can describe the patterns of argument structures using two basic operations: sum and product.</p>
<p>Just like in set theory, the <strong>cardinality</strong> of a datatype is the number of possible values it defines. Given the cardinality of a type, we can deduce the number of possible implementations of a function with a given type signature.</p>
<h4 id="exercises-cardinality">Exercises: Cardinality</h4>
<ol>
<li><code>data PugType = PugData</code></li>
</ol>
<p>has cardinality 1.</p>
<ol>
<li><code>data Airline = PapuAir | CatapultsR'Us | TakeYourChancesUnited</code></li>
</ol>
<p>has cardinality 3.</p>
<ol>
<li><code>Int16</code></li>
</ol>
<p>has cardinality <code>2^16 = 65536</code>.</p>
<h3 id="exercises-for-example">Exercises: For Example</h3>
<p>Given <code>data Example = MakeExample deriving Show</code>:</p>
<ol>
<li>What is the type of data constructor <code>MakeExample</code>? What happens when you request the type of <code>Example</code>?</li>
</ol>
<p><code>MakeExample :: Example</code>, but <code>Example</code> <em>is</em> a type and thus does not <em>have</em> a type. So GHCi yells at you and says that data constructor <code>Example</code> is not in scope.</p>
<ol>
<li>Try making a new datatype like <code>Example</code> but with a single type argument added to <code>MakeExample</code>, such as <code>Int</code>. What has changed when you query <code>MakeExample</code> with <code>:type</code> in GHCi?</li>
</ol>
<p>Then the type of the data constructor changes to a function <code>MakeExample :: Int -&gt; Example</code></p>
<p>Of course, unary constructors will always have the same cardinality as the type they contain.</p>
<h3 id="newtype">11.9 <code>newtype</code></h3>
<p>A <code>newtype</code> cannot be a product type, sum type, or contain nullary constructors. It can only ever have a single unary data constructor. However, it has a few advantages over <code>data</code> declaration. One advantage is that <strong>newtypes have no runtime overhead</strong> because it reuses the representation of the type it contains.</p>
<p>As an absurd example, if we want to check when we have too many goats or too many cows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tooManyGoats ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
tooManyGoats n <span class="fu">=</span> n <span class="fu">&gt;</span> <span class="dv">42</span>

<span class="ot">tooManyCows ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
tooManyCows n <span class="fu">=</span> n <span class="fu">&gt;</span> <span class="dv">5</span></code></pre></div>
<p>only representing counts with integers can be unsafe. What if an integer value is representing cows but accidentally gets passed to <code>tooManyGoats</code>? We can leverage the type system to be safer, via newtypes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Goats</span> <span class="fu">=</span>
  <span class="dt">Goats</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="kw">newtype</span> <span class="dt">Cows</span> <span class="fu">=</span>
  <span class="dt">Cows</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">tooManyGoats ::</span> <span class="dt">Goats</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
tooManyGoats (<span class="dt">Goats</span> n) <span class="fu">=</span> n <span class="fu">&gt;</span> <span class="dv">42</span>

<span class="co">-- testing it out</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> tooManyGoats (<span class="dt">Goats</span> <span class="dv">43</span>)
<span class="dt">True</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> tooManyGoats (<span class="dt">Cows</span> <span class="dv">43</span>)
<span class="dt">Error</span><span class="fu">:</span> <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> ‘<span class="dt">Goats</span>’ with actual <span class="kw">type</span> ‘<span class="dt">Cows</span>’</code></pre></div>
<h4 id="comparison-to-type-synonym">comparison to type synonym</h4>
<p>A <code>newtype</code> is similar to a type synonym in that they are identical to the type they are extending/representing and distinction between said type is gone at compile time. It can be useful to humans when reading code, but irrelevant to compiler.</p>
<p>One key difference is that you can <strong>define new typeclass instances</strong> for <code>newtype</code>s:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">TooMany</span> a <span class="kw">where</span>
<span class="ot">  tooMany ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="kw">instance</span> <span class="dt">TooMany</span> <span class="dt">Int</span> <span class="kw">where</span>
  tooMany n <span class="fu">=</span> n <span class="fu">&gt;</span> <span class="dv">42</span>

<span class="kw">newtype</span> <span class="dt">Goats</span> <span class="fu">=</span> <span class="dt">Goats</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="kw">instance</span> <span class="dt">TooMany</span> <span class="dt">Goats</span> <span class="kw">where</span>
  tooMany (<span class="dt">Goats</span> n) <span class="fu">=</span> n <span class="fu">&gt;</span> <span class="dv">43</span></code></pre></div>
<p>To reuse the typeclass instance of the underlying type we can use a <em>language pragma</em>, aka <em>extension</em>, called <code>GeneralizedNewtypeDeriving</code>. This allows us to specify user defined typeclass derivations, e.g.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="kw">newtype</span> <span class="dt">Goats</span> <span class="fu">=</span> <span class="dt">Goats</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">TooMany</span>)</code></pre></div>
<h3 id="sum-types">11.10 Sum types</h3>
<p>The cardinality of a <em>sum type</em> is the <em>sum</em> of the cardinalities of its data constructors.</p>
<h4 id="exercises-pity-the-bool">Exercises: Pity the Bool</h4>
<h5 id="what-is-the-cardinality-of-the-datatype-bigsmall">1. What is the cardinality of the datatype <code>BigSmall</code>:</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BigSmall</span> <span class="fu">=</span> <span class="dt">Big</span> <span class="dt">Bool</span> <span class="fu">|</span> <span class="dt">Small</span> <span class="dt">Bool</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Cardinality is 4.</p>
<h5 id="what-is-the-cardinality-of-the-datatype-numberorbool">1. What is the cardinality of the datatype <code>NumberOrBool</code>:</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NumberOrBool</span> <span class="fu">=</span> <span class="dt">Numba</span> <span class="dt">Int8</span> <span class="fu">|</span> <span class="dt">BoolyBool</span> <span class="dt">Bool</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Cardinality is 258 (256 + 2).</p>
<h3 id="product-types">11.11 Product types</h3>
<p>The cardinality of a <em>product type</em> is the <em>product</em> of the cardinalities of its inhabitants. This is very straightforward.</p>
<h4 id="record-syntax">Record syntax</h4>
<p>Records are just product types but provide syntax that desugars into defining convenient accessor methods. They are also very straightforward.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> {<span class="ot"> name ::</span> <span class="dt">String</span>
                     ,<span class="ot"> age ::</span> <span class="dt">Int</span> }
                     <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="co">-- name :: Person -&gt; String</span>
λ<span class="fu">&gt;</span> name (<span class="dt">Person</span> <span class="st">&quot;Papu&quot;</span> <span class="dv">5</span>)
<span class="st">&quot;Papu&quot;</span></code></pre></div>
<h3 id="normal-form">11.12 Normal form</h3>
<p>Another aspect of algebra that applies to datatypes in Haskell is the <em>distributive</em> property. We say that a type declaration is in <em>normal form</em> if the product is distributed over sums.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- not normal form</span>
<span class="kw">data</span> <span class="dt">SumType</span> <span class="fu">=</span> <span class="dt">Option1</span> <span class="fu">|</span> <span class="dt">Option2</span> <span class="fu">|</span> <span class="dt">Option3</span>
<span class="kw">data</span> <span class="dt">ProductType</span> <span class="fu">=</span> <span class="dt">ProductType</span> <span class="dt">String</span> <span class="dt">SumType</span>

<span class="co">-- normal form, product has been distributed over sum</span>
<span class="kw">data</span> <span class="dt">ProductType</span> <span class="fu">=</span> <span class="dt">Option1</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Option2</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Option3</span> <span class="dt">String</span></code></pre></div>
<h4 id="exercise-how-does-your-garden-grow">Exercise: How Does Your Garden Grow?</h4>
<p>What is the normal form of <code>Garden</code> where</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">FlowerType</span> <span class="fu">=</span> <span class="dt">Gardenia</span> <span class="fu">|</span> <span class="dt">Daisy</span> <span class="fu">|</span> <span class="dt">Rose</span> <span class="fu">|</span> <span class="dt">Lilac</span> <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="kw">type</span> <span class="dt">Gardener</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">data</span> <span class="dt">Garden</span> <span class="fu">=</span> <span class="dt">Garden</span> <span class="dt">Gardener</span> <span class="dt">FlowerType</span> <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>This is just like my custom example above. Normal form is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Gardener</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">data</span> <span class="dt">Garden</span> <span class="fu">=</span> <span class="dt">Gardenia</span> <span class="dt">Gardener</span> <span class="fu">|</span> <span class="dt">Daisy</span> <span class="dt">Gardener</span> <span class="fu">|</span> <span class="dt">Rose</span> <span class="dt">Gardener</span> <span class="fu">|</span> <span class="dt">Lilac</span> <span class="dt">Gardener</span>
  <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<h3 id="constructing-and-deconstructing-values">11.13 Constructing and deconstructing values</h3>
<h4 id="accidental-bottoms-from-records">Accidental bottoms from records</h4>
<p>Do <strong>not</strong> progagate bottoms through record types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Automobile</span> <span class="fu">=</span> <span class="dt">Null</span>
                <span class="fu">|</span> <span class="dt">Car</span> {<span class="ot"> make ::</span> <span class="dt">String</span>
                ,<span class="ot"> model ::</span> <span class="dt">String</span>
                ,<span class="ot"> year ::</span> <span class="dt">Integer</span> }
<span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

λ<span class="fu">&gt;</span> make <span class="dt">Null</span>
<span class="co">-- *** Exception: No match in record selector make</span></code></pre></div>
<p><strong>Instead</strong> whenever we have a product that uses record accessors, keep it separate of any sum type that is wrapping it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Split out the record/product</span>
<span class="kw">data</span> <span class="dt">Car</span> <span class="fu">=</span> <span class="dt">Car</span> {<span class="ot"> make ::</span> <span class="dt">String</span>
               ,<span class="ot"> model ::</span> <span class="dt">String</span>
               ,<span class="ot"> year ::</span> <span class="dt">Integer</span> }
               <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="co">-- The Null is still not great, but</span>
<span class="co">-- we&#39;re leaving it in to make a point</span>
<span class="kw">data</span> <span class="dt">Automobile</span> <span class="fu">=</span> <span class="dt">Null</span>
                <span class="fu">|</span> <span class="dt">Automobile</span> <span class="dt">Car</span>
                <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
λ<span class="fu">&gt;</span> make <span class="dt">Null</span>
<span class="co">-- Type system error, at compile time</span></code></pre></div>
<p>Yay for intiution! This is what I ended up deciding to do with the octohook payload types.</p>
<h3 id="function-type-is-exponential">11.14 Function type is exponential</h3>
<p>Given a function <code>a -&gt; b</code>, the number of implementations is <code>|b|</code><sup><code>|a|</code></sup>.</p>
<h3 id="higher-kinded-datatypes">11.15 Higher-kinded datatypes</h3>
<p>Getting comfortable with writing these is the next step in the evolution of a Haskell programmer. For example, in the <code>bloodhound</code> package for Elasticsearch:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">EsResultFound</span> a <span class="fu">=</span>
  <span class="dt">EsResultFound</span> {<span class="ot"> _version ::</span> <span class="dt">DocVersion</span>
                ,<span class="ot"> _source ::</span> a
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<h3 id="lists-are-polymorphic">11.16 Lists are polymorphic</h3>
<p>As we've seen, nonalphanumeric operators are infix by default. Furthermore</p>
<ul>
<li>any operator starting with <code>:</code> must be an infix type or data constructor</li>
<li>all infix data constructors <strong>must</strong> start with a colon</li>
<li>the type constructor for functions <code>-&gt;</code> is the only infix type constructor that doesn't start with a colon</li>
<li>of course, <code>::</code> is reserved for type assertions</li>
</ul>
<p>This appears to allow us shortcuts:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Product</span> a b <span class="fu">=</span>
  a <span class="fu">:&amp;:</span> b
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dv">1</span> <span class="fu">:&amp;:</span> <span class="dv">2</span>
<span class="dv">1</span> <span class="fu">:&amp;:</span> <span class="dv">2</span><span class="ot"> ::</span> (<span class="dt">Num</span> a, <span class="dt">Num</span> b) <span class="ot">=&gt;</span> <span class="dt">Product</span> a b</code></pre></div>
<h3 id="binary-tree">11.17 Binary Tree</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BinaryTree</span> a <span class="fu">=</span>
    <span class="dt">Leaf</span>
  <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BinaryTree</span> a) a (<span class="dt">BinaryTree</span> a)
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<h1 id="signaling-adversity">Signaling adversity</h1>
<p>Our first look at monads! I already know <code>Maybe</code> and <code>Either</code> very well from LYAH, so the notes will be brief.</p>
<h3 id="bleating-either">12.3 Bleating either</h3>
<p>A primitive attempt at catching errors for inputs when creating &quot;People&quot;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Age</span> <span class="fu">=</span> <span class="dt">Integer</span>
<span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> <span class="dt">Name</span> <span class="dt">Age</span> <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="kw">data</span> <span class="dt">PersonInvalid</span> <span class="fu">=</span> <span class="dt">NameEmpty</span> <span class="fu">|</span> <span class="dt">AgeTooLow</span>
                     <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="ot">mkPerson ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Age</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">PersonInvalid</span> <span class="dt">Person</span>
mkPerson name age
  <span class="fu">|</span> name <span class="fu">/=</span> <span class="st">&quot;&quot;</span> <span class="fu">&amp;&amp;</span> age <span class="fu">&gt;=</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Right</span> <span class="fu">$</span> <span class="dt">Person</span> name age <span class="co">-- success</span>
  <span class="fu">|</span> name <span class="fu">==</span> <span class="st">&quot;&quot;</span> <span class="fu">=</span> <span class="dt">Left</span> <span class="dt">NameEmpty</span> <span class="co">-- name error</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Left</span> <span class="dt">AgeTooLow</span> <span class="co">-- age error</span></code></pre></div>
<p>Next let's adapt to catch multiple errors. Notice that instead of checking for valid data all at once, we make separate checking functions and then combine results:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Keep types from above, but add the following type alias:</span>
<span class="kw">type</span> <span class="dt">ValidatePerson</span> a <span class="fu">=</span> <span class="dt">Either</span> [<span class="dt">PersonInvalid</span>] a

<span class="co">-- Checking functions</span>
<span class="ot">ageOkay ::</span> <span class="dt">Age</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">PersonInvalid</span>] <span class="dt">Age</span>
ageOkay age <span class="fu">=</span> <span class="kw">case</span> age <span class="fu">&gt;=</span> <span class="dv">0</span> <span class="kw">of</span>
  <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="dt">Right</span> age
  <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> [<span class="dt">AgeTooLow</span>]

<span class="ot">nameOkay ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">PersonInvalid</span>] <span class="dt">Name</span>
nameOkay name <span class="fu">=</span> <span class="kw">case</span> name <span class="fu">/=</span> <span class="st">&quot;&quot;</span> <span class="kw">of</span>
  <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="dt">Right</span> name
  <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> [<span class="dt">NameEmpty</span>]</code></pre></div>
<p>Now, since we haven't learned how to combine monadic functions, let's naiively use all of these checks via some ugly pattern matching:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkPerson ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Age</span> <span class="ot">-&gt;</span> <span class="dt">ValidatePerson</span> <span class="dt">Person</span>
mkPerson name age <span class="fu">=</span>
  mkPerson&#39; (nameOkay name) (ageOkay age)

<span class="ot">mkPerson&#39; ::</span> <span class="dt">ValidatePerson</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">ValidatePerson</span> <span class="dt">Age</span> <span class="ot">-&gt;</span> <span class="dt">ValidatePerson</span> <span class="dt">Person</span>
mkPerson&#39; (<span class="dt">Right</span> nameOk) (<span class="dt">Right</span> ageOk) <span class="fu">=</span> <span class="dt">Right</span> (<span class="dt">Person</span> nameOk ageOk)
mkPerson&#39; (<span class="dt">Left</span> badName) (<span class="dt">Left</span> badAge) <span class="fu">=</span> <span class="dt">Left</span> (badName <span class="fu">++</span> badAge)
mkPerson&#39; (<span class="dt">Left</span> badName) _             <span class="fu">=</span> <span class="dt">Left</span> badName
mkPerson&#39; _ (<span class="dt">Left</span> badAge)              <span class="fu">=</span> <span class="dt">Left</span> badAg</code></pre></div>
<p>Later on, we'll get more elegant:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkPerson ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Age</span> <span class="ot">-&gt;</span> <span class="dt">Validation</span> [<span class="dt">PersonInvalid</span>] <span class="dt">Person</span>
mkPerson name age <span class="fu">=</span> liftA2 <span class="dt">Person</span> (nameOkay name) (ageOkay age)</code></pre></div>
<h3 id="kinds-a-thousand-stars-in-your-types">12.4 Kinds, a thousand stars in your types</h3>
<p>One noteworthy feature of Haskell is that it has <em>higher-kinded</em> types (term is analogous to higher-order functions), which take more types as arguments. <code>Maybe</code> and <code>Either</code> are obvious examples, while <code>Int</code> is not higher-kinded, but just a simple type constant.</p>
<h4 id="lifted-and-unlifted-types">Lifted and unlifted types</h4>
<p>Kind <code>*</code> is the kind of all standard lifted types, while types that have the kind <code>#</code> are unlifted. A <strong>lifted datatype</strong> is any that can be inhabited by <em>bottom</em> (this includes any datatypes that we can define as Haskell developers). <strong>Unlifted types</strong> are any type which <em>cannot</em> be inhabited by bottom. Examples include native machine types and raw pointers.</p>
<p>Interestingly, <code>newtype</code> is a special case having kind <code>*</code> while being unlifted. This is because their representation is identical to the type they contain, hence not creating any new pointer. Therefore the newtype itself is not inhabited by bottom, only the type it contains is.</p>
<h3 id="chapter-exercises-4">12.5 Chapter Exercises</h3>
<ol>
<li>What is the kind of <code>a</code> in <code>id :: a -&gt; a</code>?</li>
</ol>
<p><code>:kind a === * 2. What are the kinds of</code>a<code>and</code>f<code>in</code>r :: a -&gt; f a`?</p>
<p><code>:kind a === *</code><br />
<code>:kind f === * -&gt; *</code></p>
<h1 id="testing">Testing</h1>
<ul>
<li><strong>unit tests</strong> test the smallest atomic units of software independently</li>
<li><strong>spec tests</strong> test specific functions independently as well, but is<br />
often written in terms of human-readable assertions</li>
<li><strong>property tests</strong> test the formal properties of programs without requiring formal proofs</li>
</ul>
<p>In Haskell, the Hspec is the usual choice for spec testing and<br />
QuickCheck library is the usual choice for property testing.<br />
It relies on the type system to randomly generate values that get passed to functions.<br />
Property testing really shines by ensuring you've met the laws of monads and other algebraic structures.</p>
<h3 id="hspec">hspec</h3>
<p>A small example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> hspec <span class="fu">$</span> <span class="kw">do</span>
  describe <span class="st">&quot;Addition&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    it <span class="st">&quot;1 + 1 is greater than 1&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      <span class="kw">let</span> one <span class="fu">=</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Integer</span>
       <span class="kw">in</span> (one <span class="fu">+</span> one) <span class="fu">&gt;</span> one <span class="ot">`shouldBe`</span> <span class="dt">True</span>

<span class="ot">shouldBe ::</span> (<span class="dt">Eq</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Expectation</span>
<span class="ot">(==) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div>
<p>Notice how <code>shouldBe</code> is like a super saiyan <code>==</code>.</p>
<h3 id="quickcheck">QuickCheck</h3>
<p>QuickCheck gets us closer to <em>proofs</em>, by bombing property assertions with data values for a given type. The default number of values is 100. See example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Test.QuickCheck</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> hspec <span class="fu">$</span> <span class="kw">do</span>
  describe <span class="st">&quot;Addition&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    it <span class="st">&quot;x + 1 is always greater than x&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      property <span class="fu">$</span> \x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&gt;</span> (<span class="ot">x ::</span> <span class="dt">Int</span>)</code></pre></div>
<p>QuickCheck will feed that function 100 random <code>Int</code> values to see if the property is ever false.</p>
<h4 id="arbitrary-instances">Arbitrary instances</h4>
<p>QuickCheck relies on a typeclass called <code>Arbitrary</code> and a newtype called <code>Gen</code> for generating its random data.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">arbitrary ::</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Gen</span> a</code></pre></div>
<p>This is just to set a default generator for a type; note that you still have to specify the type to dispatch the right typeclass instance. We get lists of these arbitrary values using <code>sample</code> and <code>sample'</code>, defined in <code>Test.QuickCheck</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sample ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">sample&#39; ::</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> [a]

<span class="dt">Prelude</span><span class="fu">&gt;</span> sample (<span class="ot">arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Int</span>)
<span class="dv">0</span>
<span class="fu">-</span><span class="dv">2</span>
<span class="fu">-</span><span class="dv">1</span>
<span class="dv">4</span>
<span class="fu">-</span><span class="dv">3</span>
<span class="dv">4</span>
<span class="dv">2</span>
<span class="dv">4</span>
<span class="fu">-</span><span class="dv">3</span>
<span class="dv">2</span>
<span class="fu">-</span><span class="dv">4</span></code></pre></div>
<p>Note the <code>IO</code> monad, which is necessary because it's using a global resource of random values to generate data (i.e., impure!). Here are some other examples:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- concrete types</span>
<span class="ot">genOrdering ::</span> <span class="dt">Gen</span> <span class="dt">Ordering</span>
genOrdering <span class="fu">=</span> elements [<span class="dt">LT</span>, <span class="dt">EQ</span>, <span class="dt">GT</span>]
<span class="ot">genChar ::</span> <span class="dt">Gen</span> <span class="dt">Char</span>
genChar <span class="fu">=</span> elements [<span class="ch">&#39;a&#39;</span><span class="fu">..</span><span class="ch">&#39;z&#39;</span>]
<span class="co">-- higher kinded types</span>
<span class="ot">genTuple ::</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Gen</span> (a, b)
genTuple <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> arbitrary
  b <span class="ot">&lt;-</span> arbitrary
  return (a, b)
<span class="co">-- equal probability</span>
<span class="ot">genMaybe ::</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Gen</span> (<span class="dt">Maybe</span> a)
genMaybe <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> arbitrary
  elements [<span class="dt">Nothing</span>, <span class="dt">Just</span> a]
<span class="co">-- What QuickCheck actually does so you get more Just values</span>
<span class="ot">genMaybe&#39; ::</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Gen</span> (<span class="dt">Maybe</span> a)
genMaybe&#39; <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> arbitrary
  frequency [ (<span class="dv">1</span>, return <span class="dt">Nothing</span>)
            , (<span class="dv">3</span>, return (<span class="dt">Just</span> a))]</code></pre></div>
<p>Here's what QuickCheck looks like without Hspec:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prop_additionGreater ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_additionGreater x <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&gt;</span> x

<span class="ot">runQc ::</span> <span class="dt">IO</span> ()
runQc <span class="fu">=</span> quickCheck prop_additionGreater</code></pre></div>
<p>See the <a href="./Babby.hs">Babby.hs</a> file for more extensive examples of QuickCheck features, such as Gen, Arbitrary, CoArbitrary.</p>
<h1 id="monoids-and-semigroups">Monoids and semigroups</h1>
<p>Of course one of the main reasons I've come to love Haskell is for the community's propensity for recognizing abstract patterns in code which have well-defined, lawful representations in mathematics.</p>
<h3 id="what-we-talk-about-when-we-talk-about-algebras">15.2 What we talk about when we talk about algebras</h3>
<p>In mathematics, algebra generally refers to a set with some operations defined on it. In Haskell, an algebra refers to a type (set of values) along with a typeclass (operations). The instance defines how each of a typeclass's operations will perform on a given type.</p>
<h3 id="monoid">15.3 Monoid</h3>
<p>A <strong>monoid</strong> is a set with a binary associative operation with an identity.</p>
<h3 id="how-monoid-is-defined-in-haskell">15.4 How Monoid is defined in Haskell</h3>
<p>Typeclasses give us a way to recognize, organize, and use common functionalities and patterns across types that differ in some ways but also have things in common. We think of types as <em>having</em> an instance of a typeclass. When we represent abstract operations that can be reused across a set of types, we usually represent them as a typeclass. The typeclass <code>Monoid</code> is defined:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span>
<span class="ot">  mempty ::</span> m
<span class="ot">  mappend ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m
<span class="ot">  mconcat ::</span> [m] <span class="ot">-&gt;</span> m
  mconcat <span class="fu">=</span> foldr mappend mempty</code></pre></div>
<p>An example instance is <code>List</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> [a] <span class="kw">where</span>
  mempty <span class="fu">=</span> []
  mappend <span class="fu">=</span> (<span class="fu">++</span>)

<span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>] <span class="ot">`mappend`</span> [<span class="dv">3</span>,<span class="dv">4</span>]
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</code></pre></div>
<h3 id="why-integer-doesnt-have-a-monoid">15.6 Why Integer doesn't have a Monoid</h3>
<p>Remember that a type's instance of a typeclass is <strong>unique</strong> for that type. We don't want to give <code>Integer</code> a direct instance of <code>Monoid</code> because there are multiple possible interpretations, e.g. addition and multiplaction. This is a classic use case for newtypes, so the <code>Monoid</code> library exports <code>Sum</code> and <code>Product</code> newtypes that defined <code>instance Num a =&gt; Monoid (NewType a)</code>.</p>
<h4 id="why-newtype-an-aside">Why newtype? (an aside)</h4>
<p>Of course, one obvious difference between</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Server</span> <span class="fu">=</span> <span class="dt">Server</span> <span class="dt">String</span>
<span class="kw">newtype</span> <span class="dt">Server</span> <span class="fu">=</span> <span class="dt">Server</span> <span class="dt">String</span></code></pre></div>
<p>from a <em>developer</em> perspective is that <code>newtype</code> <strong>constrains</strong> the datatype to a single unary data constructor. Furthermore, <code>newtype</code> guarantees no additional runtime overhead from wrapping the original type, since the runtime representation is identical to the original type.</p>
<p>In summary, some uses cases are:</p>
<ol>
<li>Signaling intent that you are simply wrapping a type, and that the type will not eventually grow into a more complicated sum or product type.</li>
<li>Improve type safety by avoiding mixing up many values of the same representation.</li>
<li>Add different typeclass instances to a type that is otherwise unchanged representationally.</li>
</ol>
<h3 id="laws">15.8 Laws</h3>
<p>These algebras that we define in Haskell are defined not just by the functions we implement, but by laws that come from mathematics. Laws are what really define these algebras and what makes them so useful to us as repeatable patterns. Here are the laws for <code>Monoid</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- left identity</span>
mappend mempty x <span class="fu">=</span> x

<span class="co">-- right identity</span>
mappend x mempty <span class="fu">=</span> x

<span class="co">-- associativity</span>
mappend x (mappend y z) <span class="fu">=</span> mappend (mappend x y) z
mconcat <span class="fu">=</span> foldr mappend mempty</code></pre></div>
<h3 id="different-instance-same-representation">15.9 Different instance, same representation</h3>
<h4 id="bool">Bool</h4>
<p>Similar to numbers having more than one possible <code>Monoid</code> instance, so does <code>Bool</code>. So we have newtypes <code>All</code> for which <code>mappend</code> returns <code>True</code> iff all inputs are <code>True</code> and <code>Any</code> for which <code>mappend</code> returns <code>True</code> iff at least one input is <code>True</code>.</p>
<h4 id="maybe">Maybe</h4>
<p><code>Maybe</code> actually has three possible monoid interpretations. <code>Nothing</code> is the obvious choice for <code>mempty</code> in all situations:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- First prioritizes the leftmost non-Nothing value</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">First</span> (<span class="dt">Just</span> <span class="dv">1</span>) <span class="ot">`mappend`</span> <span class="dt">First</span> (<span class="dt">Just</span> <span class="dv">2</span>)
<span class="dt">First</span> {getFirst <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">1</span>}

<span class="co">--Second prioritizes the rightmost non-Nothing value</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Last</span> (<span class="dt">Just</span> <span class="dv">1</span>) <span class="ot">`mappend`</span> <span class="dt">Last</span> (<span class="dt">Just</span> <span class="dv">2</span>)
<span class="dt">Last</span> {getLast <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">2</span>}</code></pre></div>
<p>The third interpretation uses the general pattern of reusing Monoid instances in the components of larger types.</p>
<h3 id="reusing-algebras-by-asking-for-algebras">15.10 Reusing algebras by asking for algebras</h3>
<h4 id="exercise-write-the-maybe-monoid-instance-renamed-to-optional">Exercise: Write the Maybe Monoid instance renamed to Optional:</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Optional</span> a <span class="fu">=</span> <span class="dt">Nada</span> <span class="fu">|</span> <span class="dt">Only</span> a
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Optional</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Nada</span>
  mappend <span class="dt">Nada</span> (<span class="dt">Only</span> x)     <span class="fu">=</span> <span class="dt">Only</span> x
  mappend (<span class="dt">Only</span> x) <span class="dt">Nada</span>     <span class="fu">=</span> <span class="dt">Only</span> x
  mappend (<span class="dt">Only</span> x) (<span class="dt">Only</span> y) <span class="fu">=</span> <span class="dt">Only</span> (x <span class="ot">`mappend`</span> y)</code></pre></div>
<h4 id="the-problem-of-orphan-instances">The problem of orphan instances</h4>
<p>Recall (again) that typeclasses have <strong>unique</strong> pairings of the class &amp; instance for a given type. Sometimes we end up with multiple instances for a single type when orphan instances are written -- <strong>this should be avoided at all costs</strong>.</p>
<p>An <em>orphan instance</em> is when an instance is defined for a datatype and typeclass, but not in the same module as the declaration of either the typeclass or datatype. (GHC will warn about this.) If you don't &quot;own&quot; the typeclass or datatype, newtype it!</p>
<p>If you</p>
<ol>
<li>Defined the type but not the typeclass: put the instance in the same module as the type so that the type cannot be imported without its instances.</li>
<li>Defined the typeclass but not the type: put the instance in the same module as the typeclass definition so that the typeclass cannot be imported without its instances.</li>
<li>Defined neither the type nor typeclass: define your own newtype to wrap the original type - now it belongs to you.</li>
</ol>
<h3 id="better-living-through-quickcheck">15.12 Better living through QuickCheck</h3>
<p>Proving laws can be tedious -- QuickCheck is a good compromise to get a sense of whether or not the laws are <em>likely</em> obeyed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- You can bind infix names for func arguments! Sick.</span>
<span class="co">-- Test whether the the first function argument treats the last three value arguments associatively.</span>
<span class="ot">asc ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
asc (<span class="fu">&lt;&gt;</span>) a b c <span class="fu">=</span>
  a <span class="fu">&lt;&gt;</span> (b <span class="fu">&lt;&gt;</span> c) <span class="fu">==</span> (a <span class="fu">&lt;&gt;</span> b) <span class="fu">&lt;&gt;</span> c

<span class="co">-- With QuickCheck:</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck</span>

<span class="ot">monoidAssoc ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
monoidAssoc a b c <span class="fu">=</span> (a <span class="fu">&lt;&gt;</span> (b <span class="fu">&lt;&gt;</span> c)) <span class="fu">==</span> ((a <span class="fu">&lt;&gt;</span> b) <span class="fu">&lt;&gt;</span> c)

<span class="ot">monoidLeftIdentity ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
monoidLeftIdentity a <span class="fu">=</span> (mempty <span class="fu">&lt;&gt;</span> a) <span class="fu">==</span> a

<span class="ot">monoidRightIdentity ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
monoidRightIdentity a <span class="fu">=</span> (a <span class="fu">&lt;&gt;</span> mempty) <span class="fu">==</span> a

quickCheck (<span class="ot">monoidAssoc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="co">-- explicit types</span>
<span class="co">-- etc</span></code></pre></div>
<p>See examples in this directory for a <a href="./BadMonoid.hs">bad monoid</a> and a <a href="./AnotherMaybeMonoid.hs">good monoid</a>, both with QuickCheck tests.</p>
<h3 id="semigroup">15.13 Semigroup</h3>
<p>A semigroup is just a more generalized monoid -- specifically it is a set with an associative binary operation, but it need not have an identity:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span>
<span class="ot">  (&lt;&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a

<span class="co">-- Law of associativity</span>
<span class="co">-- (a &lt;&gt; b) &lt;&gt; c = a &lt;&gt; (b &lt;&gt; c)</span></code></pre></div>
<h4 id="nonempty">NonEmpty</h4>
<p>One really useful datatype that can’t have a <code>Monoid</code> instance but does have a <code>Semigroup</code> instance is the <code>NonEmpty</code> list type. It is a list datatype that can never be an empty list:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NonEmpty</span> a <span class="fu">=</span> a <span class="fu">:|</span> [a]
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)

<span class="co">-- It&#39;s just like a list but the first element, which is required,</span>
<span class="co">-- remains visible as the first argument to to the infix data</span>
<span class="co">-- constructor :|</span>

<span class="fu">&gt;&gt;&gt;</span> <span class="kw">let</span> xs <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:|</span> [<span class="dv">2</span>, <span class="dv">3</span>]
<span class="fu">&gt;&gt;&gt;</span> <span class="kw">let</span> ys <span class="fu">=</span> <span class="dv">4</span> <span class="fu">:|</span> [<span class="dv">5</span>, <span class="dv">6</span>]
<span class="fu">&gt;&gt;&gt;</span> xs <span class="fu">&lt;&gt;</span> ys
<span class="dv">1</span> <span class="fu">:|</span> [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
<span class="fu">&gt;&gt;&gt;</span> N.head xs
<span class="dv">1</span></code></pre></div>
<p>Obviously, by construction, there is no canonical empty value that can be used as an identity, making this a natural fit for Semigroup.</p>
<h1 id="functor">Functor</h1>
<h3 id="whats-a-functor">16.2 What's a functor?</h3>
<p>A functor is a way to apply a function over or around some structure that we don't want to alter.<br />
Funtor is implemented in Haskell with a typeclass:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<h3 id="lets-talk-about-f-baby">16.4 Let's talk about <em>f</em>, baby</h3>
<p>We can deduce that <code>f</code> must have kind <code>* -&gt; *</code> by looking at the type signature of <code>fmap</code>; each argument must have kind <code>*</code> (because each argument/return must be inhabitable); since <code>f a</code> and <code>f b</code> both exist as single arguments in the type signature, we know that <code>f a</code> and <code>f b</code> both have kind <code>*</code>, so <code>f</code> has kind <code>* -&gt; *</code>.</p>
<p>Thus, the following are impossible:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Impish</span> v <span class="kw">where</span>
<span class="ot">  impossibleKind ::</span> v <span class="ot">-&gt;</span> v a

<span class="kw">class</span> <span class="dt">AlsoImp</span> v <span class="kw">where</span>
<span class="ot">  nope ::</span> v a <span class="ot">-&gt;</span> v</code></pre></div>
<h4 id="exercises-be-kind">Exercises: Be Kind</h4>
<p>Given a type signature, determine the kinds:</p>
<ol>
<li><code>a -&gt; a</code></li>
</ol>
<p><code>a :: *</code></p>
<ol>
<li><code>a -&gt; b a -&gt; T (b a)</code></li>
</ol>
<p><code>a :: *</code><br />
<code>b :: * -&gt; *</code><br />
<code>T :: * -&gt; *</code></p>
<ol>
<li><code>c a b -&gt; c b a</code></li>
</ol>
<p><code>c :: * -&gt; * -&gt; *</code></p>
<h4 id="functor-is-function-application">Functor is function application</h4>
<p>Functors simply allow us to apply functions within higher kinded types. Notice the similarities:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&lt;$&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">($)   ::</span>              (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span>   a <span class="ot">-&gt;</span>   b</code></pre></div>
<p>This shows how a functor is a way to apply functions over/through/past some structure <code>f</code> that we want to leave untouched. (The leaved untouched bit is where functor laws come into play.)</p>
<h3 id="functor-laws">16.5 Functor Laws</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot"># 1. Identity</span>
fmap id <span class="fu">==</span> id

<span class="ot"># 2. Composition</span>
fmap (f <span class="fu">.</span> g) <span class="fu">==</span> fmap f <span class="fu">.</span> fmap g</code></pre></div>
<p>The law of identity is ensuring that we don't mess with the structure around the values. The law of composition concerns, well, composability. Acting on the values within a structure via two consecutive operations <code>g</code> and <code>f</code> should be the same whether they are composed via single <code>fmap</code> operation or if they are each <code>fmap</code>-ed.</p>
<p>The recurring theme is that we <strong>leave the structure untouched</strong>. The whole purpose of this typeclass is to reuse functions in the presence of more structure and be transparently oblivious to that structure. Don't break the laws. If you want to change the structure around a value, just use a normal function!</p>
<p><strong>Note</strong> that the composition law is redundant... #1 =&gt; #2. But, it's an important thing to keep in mind.</p>
<h3 id="commonly-used-functors">16.7 Commonly used functors</h3>
<h4 id="the-functors-are-stacked-and-thats-a-fact">The functors are stacked and that's a fact</h4>
<p>Let's take a look at nested structures</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">let</span> lms <span class="fu">=</span> [<span class="dt">Just</span> <span class="st">&quot;ave&quot;</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="st">&quot;woohoo&quot;</span>]
<span class="fu">&gt;&gt;&gt;</span> <span class="kw">let</span> replaceWithP <span class="fu">=</span> const <span class="ch">&#39;p&#39;</span>

<span class="fu">&gt;&gt;&gt;</span> replaceWithP lms
<span class="ch">&#39;p&#39;</span>

<span class="fu">&gt;&gt;&gt;</span> fmap replaceWithP lms
[<span class="ch">&#39;p&#39;</span>, <span class="ch">&#39;p&#39;</span>, <span class="ch">&#39;p&#39;</span>]

<span class="fu">&gt;&gt;&gt;</span> (fmap <span class="fu">.</span> fmap) replaceWithP lms
[<span class="dt">Just</span> <span class="ch">&#39;p&#39;</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="ch">&#39;p&#39;</span>]

<span class="fu">&gt;&gt;&gt;</span> (fmap <span class="fu">.</span> fmap <span class="fu">.</span> fmap) replaceWithP lms
[<span class="dt">Just</span> <span class="st">&quot;ppp&quot;</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="st">&quot;pppppp&quot;</span>]</code></pre></div>
<p>Very cool. Here we are composing <code>fmap</code> to access structures within structures.<br />
Playing in GHCi we can verify how this works:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.)  ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c

<span class="co">-- and for Functors f, g</span>
fmap<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b)     <span class="ot">-&gt;</span> f a   <span class="ot">-&gt;</span> f b
fmap<span class="ot"> ::</span> (f a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> g f a <span class="ot">-&gt;</span> g f b

<span class="co">-- recalling that functions associate to the right, composing higher order functions</span>
<span class="co">-- leaves them partially applied: a -&gt; z -&gt; y will compose as a -&gt; (z -&gt; y)</span>
<span class="co">-- hence</span>
<span class="co">-- a ~&gt; a -&gt; b and b ~&gt; f a -&gt; f b</span>
fmap<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b)                    <span class="co">-- as first arg to (.)</span>
<span class="ot">     ::</span> ((a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)
<span class="ot">     ::</span> (b <span class="ot">-&gt;</span> c)                    <span class="co">-- as second arg to (.)</span>
<span class="ot">     ::</span> ((f a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> (g f a <span class="ot">-&gt;</span> g f b))

<span class="co">-- therefore</span>
fmap <span class="fu">.</span><span class="ot"> fmap ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f (g a) <span class="ot">-&gt;</span> f (g b)</code></pre></div>
<h3 id="transforming-the-unapplied-type-argument">16.8 Transforming the unapplied type argument</h3>
<p>Note that for kinds greater than <code>* -&gt; *</code>, such as <code>Either a b</code> and <code>(a,b)</code>, we can only use Functor to act on the last element.<br />
Trying to act on both elements will not typecheck or pass Functor laws.<br />
This is fairly immediate, given that we need to accept a function of type <code>a -&gt; b</code>; how could we generically apply this to both arguments, which can be of different types?</p>
<p>Knowing then that we must partially the type contructors and have Functor instances such as <code>Either a</code> and <code>(,) a</code>, it is clear that trying to modify the value of type <code>a</code> will fail Functor laws, as that will mess with the &quot;structure&quot; which includes the type <code>a</code>.</p>
<h3 id="a-somewhat-surprising-functor">16.12 A somewhat surprising functor</h3>
<p>Recall the <code>const</code> function: <code>const :: a -&gt; b -&gt; a</code>.<br />
Similar to this, there is a <code>Constant</code> datatype:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Constant</span> a b <span class="fu">=</span>
  <span class="dt">Constant</span> {<span class="ot"> getConstant ::</span> a }
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Here <code>b</code> is a <em>phantom</em> type, as it has no corresponding witness at the value/term level.<br />
Since we need to partially apply the first argument to get kind <code>* -&gt; *</code>, the functor has to work on the phantom type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Constant</span> m) <span class="kw">where</span>
  fmap _ (<span class="dt">Constant</span> v) <span class="fu">=</span> <span class="dt">Constant</span> v</code></pre></div>
<p>Now we can <code>fmap</code> over this and always get the same thing back, no matter what function we are mapping.</p>
<h3 id="more-structure-more-functors">16.13 More structure, more functors</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Wrap</span> f a <span class="fu">=</span>
  <span class="dt">Wrap</span> (f a)
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Wrap</span> f) <span class="kw">where</span>
  fmap f (<span class="dt">Wrap</span> fa) <span class="fu">=</span> <span class="dt">Wrap</span> (fmap f fa)</code></pre></div>
<p>The only way to work out these types and get a result <code>Wrap f b</code> from <code>f :: a -&gt; b</code> is to &quot;access&quot; and apply <code>f</code> to the inner <code>a</code>. Hence we must impose a Functor constraint on <code>f</code>.</p>
<h3 id="io-functor">16.14 IO Functor</h3>
<p>An initial glance at <code>IO</code>.<br />
Note that <code>IO</code> is an abstract datatype; there are no data constructors that we can match on.<br />
This means that its typeclasses are the only way we can work with values of type <code>IO a</code>. Functor is one such typeclass:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> fmap (<span class="fu">++</span> <span class="st">&quot; world&quot;</span>) getLine
hello
<span class="st">&quot;hello world&quot;</span></code></pre></div>
<h3 id="what-if-we-want-something-different">16.15 What if we want something different?</h3>
<p>As discussed earlier, Functors are used to to lift functions over structure, so that we can transform only the contents and not the structure.<br />
What about the opposite?<br />
Transform only the structure and leave the type argument alone? Something like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nat ::</span> (f <span class="ot">-&gt;</span> g) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g a</code></pre></div>
<p>This is known as a <em>natural transformation</em>. First, note that the above type signature is impossible: <code>f</code> and <code>g</code> are higher-kinded types as indicated by the <code>f a</code> and <code>g a</code>, so they can't appear &quot;alone&quot; as <code>f</code> and <code>g</code> respectively in a function type signature.</p>
<p>We can use a language pragma to allow this sort of thing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="kw">type</span> <span class="dt">Nat</span> f g <span class="fu">=</span> forall a<span class="fu">.</span> f a <span class="ot">-&gt;</span> g a</code></pre></div>
<p>Note: the quantification <code>forall</code> of type <code>a</code> forces all functions of this type to be oblivious to the contents of the structures <code>f</code> and <code>g</code>. This is precisely what we want for a natural transformation. Without the language pragma, we could define something like <code>type Nat f g a = f a -&gt; g a</code>, however this will not be as strict; the compiler will let us &quot;mess&quot; with the <code>a</code> value, and for a natural transformation, we'd rather it yell at us.</p>
<p>We'll return to natural transformations later.</p>
<h3 id="functors-are-unique-to-a-datatype">16.16 Functors are unique to a datatype</h3>
<p>In Haskell, Functor instances are unique for a given datatype, unlike Monoids. This is due to parametricity and because arguments to type constructors are applied in the order they are defined. The proof is sadly omitted...</p>
<h3 id="chapter-exercises-5">16.17 Chapter Exercises</h3>
<h4 id="determine-if-the-following-can-have-functor-instances">Determine if the following can have Functor instances:</h4>
<h5 id="data-bool-false-true">1. <code>data Bool = False | True</code></h5>
<p>No, <code>Bool</code> has kind <code>*</code>.</p>
<h5 id="data-boolandsomethingelse-a-false-a-true-a">2. <code>data BoolAndSomethingElse a = False' a | True' a</code></h5>
<p>Yes</p>
<h5 id="data-boolandmaybesomethingelse-a-falsish-truish-a">3. <code>data BoolAndMaybeSomethingElse a = Falsish | Truish a</code></h5>
<p>Yes, this is isomorphic to <code>Maybe</code>.</p>
<h5 id="newtype-mu-f-inf-outf-f-mu-f">4. <code>newtype Mu f = InF { outF :: f (Mu f) }</code></h5>
<p>I think so.. the kind is correct. Let's try:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Mu</span> <span class="kw">where</span>
  fmap g (<span class="dt">InF</span> fx) <span class="fu">=</span> <span class="dt">InF</span> <span class="fu">$</span> fmap g fx

<span class="co">-- No, that fails because Mu has type (* -&gt; *) -&gt; *</span>

<span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> <span class="dt">Mu</span> f <span class="kw">where</span>
  fmap g (<span class="dt">InF</span> fx) <span class="fu">=</span> <span class="dt">InF</span> <span class="fu">$</span> fmap g fx</code></pre></div>
<p>No, this doesn't work either.<br />
Actually after playing in the REPL I think this is impossible.<br />
The problem is that <code>Mu</code> has type <code>(* -&gt; *) -&gt; *</code>; on its own, <code>Mu</code> clearly cannot be a Functor.<br />
However, if we partially apply it as <code>M f</code> we have to pass it a type of kind <code>* -&gt; *</code>, and then we are left with kind <code>*</code>.<br />
Thus, there is no way to form a type <code>* -&gt; *</code> for the functor instance.</p>
<h5 id="data-d-d-array-word-word-int-int">5. <code>data D = D (Array Word Word) Int Int</code></h5>
<p>No, <code>D</code> has kind <code>*</code>.</p>
<h4 id="write-functor-instances-for-the-following-datatypes.">Write Functor instances for the following datatypes.</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 1</span>
<span class="kw">data</span> <span class="dt">Quant</span> a b <span class="fu">=</span> <span class="dt">Finance</span> <span class="fu">|</span> <span class="dt">Desk</span> a <span class="fu">|</span> <span class="dt">Bloor</span> b

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Quant</span> a) <span class="kw">where</span>
  fmap f <span class="dt">Finance</span>   <span class="fu">=</span> <span class="dt">Finance</span>
  fmap f (<span class="dt">Desk</span> a)  <span class="fu">=</span> <span class="dt">Desk</span> a
  fmap f (<span class="dt">Bloor</span> b) <span class="fu">=</span> <span class="dt">Bloor</span> (f b)

<span class="co">-- 2</span>
<span class="kw">data</span> <span class="dt">K</span> a b <span class="fu">=</span> <span class="dt">K</span> a

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">K</span> a) <span class="kw">where</span>
  fmap _ (<span class="dt">K</span> a) <span class="fu">=</span> <span class="dt">K</span> a

<span class="co">-- 3</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="kw">newtype</span> <span class="dt">Flip</span> f a b <span class="fu">=</span>
  <span class="dt">Flip</span> (f b a)
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">newtype</span> <span class="dt">K</span> a b <span class="fu">=</span> <span class="dt">K</span> a

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Flip</span> <span class="dt">K</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">Flip</span> (<span class="dt">K</span> b)) <span class="fu">=</span> <span class="dt">Flip</span> <span class="fu">$</span> <span class="dt">K</span> (f b)

<span class="co">-- 4</span>
<span class="kw">data</span> <span class="dt">EvilGoateeConst</span> a b <span class="fu">=</span>
  <span class="dt">GoatyConst</span> b

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">EvilGoateeConst</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">GoatyConst</span> x) <span class="fu">=</span> <span class="dt">GoatyConst</span> <span class="fu">$</span> f x

<span class="co">-- 5</span>
<span class="kw">data</span> <span class="dt">LiftItOut</span> f a <span class="fu">=</span>
  <span class="dt">LiftItOut</span> (f a)

<span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">LiftItOut</span> f) <span class="kw">where</span>
  fmap g (<span class="dt">LiftItOut</span> fx) <span class="fu">=</span> <span class="dt">LiftItOut</span> <span class="fu">$</span> fmap g fx

<span class="co">-- 6</span>
<span class="kw">data</span> <span class="dt">Parappa</span> f g a <span class="fu">=</span>
  <span class="dt">DaWrappa</span> (f a) (g a)

<span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Parappa</span> f g) <span class="kw">where</span>
  fmap z (<span class="dt">DaWrappa</span> fx gx) <span class="fu">=</span> <span class="dt">DaWrappa</span> (fmap z fx) (fmap z gx)

<span class="co">-- 7</span>
<span class="kw">data</span> <span class="dt">IgnoreOne</span> f g a b <span class="fu">=</span>
  <span class="dt">IgnoringSomething</span> (f a) (g b)

<span class="kw">instance</span> <span class="dt">Functor</span> g <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">IgnoreOne</span> f g a) <span class="kw">where</span>
  fmap z (<span class="dt">IgnoringSomething</span> fx gx) <span class="fu">=</span> <span class="dt">IgnoringSomething</span> fx (fmap z gx)

<span class="co">-- 9</span>
<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">List</span> <span class="kw">where</span>
  fmap _ <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span>
  fmap f (<span class="dt">Cons</span> x xs) <span class="fu">=</span> <span class="dt">Cons</span> (f x) (fmap f xs)

<span class="co">-- 10</span>
<span class="kw">data</span> <span class="dt">GoatLord</span> a <span class="fu">=</span>
    <span class="dt">NoGoat</span>
  <span class="fu">|</span> <span class="dt">OneGoat</span> a
  <span class="fu">|</span> <span class="dt">MoreGoats</span> (<span class="dt">GoatLord</span> a) (<span class="dt">GoatLord</span> a) (<span class="dt">GoatLord</span> a)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">GoatLord</span> <span class="kw">where</span>
  fmap _ <span class="dt">NoGoat</span> <span class="fu">=</span> <span class="dt">NoGoat</span>
  fmap f (<span class="dt">OneGoat</span> x) <span class="fu">=</span> <span class="dt">OneGoat</span> (f x)
  fmap f (<span class="dt">MoreGoats</span> a b c) <span class="fu">=</span>
    <span class="dt">MoreGoats</span> (fmap f a) (fmap f b) (fmap f c)

<span class="co">-- 11</span>
<span class="kw">data</span> <span class="dt">TalkToMe</span> a <span class="fu">=</span>
    <span class="dt">Halt</span>
  <span class="fu">|</span> <span class="dt">Print</span> <span class="dt">String</span> a
  <span class="fu">|</span> <span class="dt">Read</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> a)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">TalkToMe</span> <span class="kw">where</span>
  fmap _ <span class="dt">Halt</span> <span class="fu">=</span> <span class="dt">Halt</span>
  fmap f (<span class="dt">Print</span> s x) <span class="fu">=</span> <span class="dt">Print</span> s (f x)
  fmap f (<span class="dt">Read</span> g) <span class="fu">=</span> <span class="dt">Read</span> <span class="fu">$</span> f <span class="fu">.</span> g</code></pre></div>
<h1 id="applicative">Applicative</h1>
<p>So far we've seen Monoids, a way of joining two values of the same type together, and Functors, a way to apply functions over some structure. Applicativce can be thought of as a <em>monoidal functor</em>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure  ::</span> a <span class="ot">-&gt;</span> f a
<span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>The <code>pure</code> function embeds something into the (functorial, applicative) structure. This will be a <em>bare minimum</em> amount of structure, or structural <em>identity</em>. The <code>&lt;*&gt;</code> infix operator is called 'apply' or 'ap', and is just like <code>fmap</code> except the function argument is also in the structure:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&lt;$&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span>       (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">(&lt;*&gt;) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>Along with these core functions, the Control.Applicative library provides</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftA ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span>
     (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> f a
  <span class="ot">-&gt;</span> f b
<span class="ot">liftA2 ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span>
     (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)
  <span class="ot">-&gt;</span> f a
  <span class="ot">-&gt;</span> f b
  <span class="ot">-&gt;</span> f c
<span class="ot">liftA3 ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span>
     (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d)
  <span class="ot">-&gt;</span> f a
  <span class="ot">-&gt;</span> f b
  <span class="ot">-&gt;</span> f c
  <span class="ot">-&gt;</span> f d</code></pre></div>
<h3 id="functor-vs.-applicative">17.3 Functor vs. Applicative</h3>
<p>The difference between <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> seems small, but has profound impacts.<br />
First of all note that even without the typeclass constraint, any Applicative could be made into a Functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f x <span class="fu">=</span> pure f <span class="fu">&lt;*&gt;</span> x</code></pre></div>
<h3 id="applicative-functors-are-monoidal-functors">17.4 Applicative functors are monoidal functors</h3>
<p>Noticing these similarities:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">($)   ::</span>   (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span>   a <span class="ot">-&gt;</span>   b
<span class="ot">(&lt;$&gt;) ::</span>   (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">(&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="co">--       f          -&gt; f   -&gt; f</span>
<span class="co">--         (a -&gt; b) -&gt;   a -&gt;   b</span></code></pre></div>
<p>we can see that <code>&lt;*&gt;</code> is just like function application <code>&lt;$&gt;</code> but the structure must be maintained throughout. This is where the monoidal aspect comes in - seeing the structure <code>f</code> on its own is reminiscent of <code>mappend :: Monoid a =&gt; a -&gt; a -&gt; a</code>.</p>
<p>To see this in action, let's look at the tuple:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (<span class="st">&quot;blah&quot;</span>, <span class="dv">0</span>)
(<span class="st">&quot;blah&quot;</span>, <span class="dv">1</span>)

<span class="fu">&gt;&gt;&gt;</span> (<span class="st">&quot;Woo&quot;</span>, (<span class="fu">+</span><span class="dv">1</span>)) <span class="fu">&lt;*&gt;</span> (<span class="st">&quot; Hoo!&quot;</span>, <span class="dv">0</span>)
(<span class="st">&quot;Woo Hoo!&quot;</span>, <span class="dv">1</span>)

<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>info (,)
<span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Applicative</span> ((,) a)</code></pre></div>
<h3 id="applicative-in-use">17.5 Applicative in use</h3>
<p>Taking a look at a list example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[(<span class="fu">+</span><span class="dv">1</span>), (<span class="fu">*</span><span class="dv">2</span>)] <span class="fu">&lt;*&gt;</span> [<span class="dv">2</span>, <span class="dv">4</span>]
  <span class="fu">=</span> [ (<span class="fu">+</span><span class="dv">1</span>) <span class="dv">2</span> , (<span class="fu">+</span><span class="dv">1</span>) <span class="dv">4</span> , (<span class="fu">*</span><span class="dv">2</span>) <span class="dv">2</span> , (<span class="fu">*</span><span class="dv">2</span>) <span class="dv">4</span> ]
  <span class="fu">=</span> [<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">8</span>]</code></pre></div>
<p>The fact that it doesn't return two lists or a nested list or some other way in which the list structure would be preserved is the <em>monoidal</em> part. The fact that the functions are not simply concatenated with the values is the <em>function application</em> part.</p>
<p>Another example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> (,) <span class="fu">&lt;$&gt;</span> [<span class="dv">1</span>, <span class="dv">2</span>] <span class="fu">&lt;*&gt;</span> [<span class="dv">3</span>, <span class="dv">4</span>]
[(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>)]

<span class="co">-- or</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> liftA2 (,) [<span class="dv">1</span>, <span class="dv">2</span>] <span class="fu">&lt;*&gt;</span> [<span class="dv">3</span>, <span class="dv">4</span>]
[(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>)]</code></pre></div>
<p>Now, demonstrating utility:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> fmap capitalize <span class="fu">$</span> lookup <span class="dv">3</span> [(<span class="dv">3</span>, <span class="st">&quot;hello&quot;</span>)]
<span class="dt">Prelude</span><span class="fu">&gt;</span> capitalize <span class="fu">&lt;$&gt;</span> lookup <span class="dv">3</span> [(<span class="dv">3</span>, <span class="st">&quot;hello&quot;</span>)]
<span class="dt">Just</span> <span class="st">&quot;Hello&quot;</span>

<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> ls <span class="fu">=</span> [(<span class="dv">3</span>, <span class="st">&quot;hello&quot;</span>), (<span class="dv">4</span>, <span class="st">&quot;world)]</span>
<span class="st">Prelude&gt; (++) &lt;$&gt; lookup 3 ls &lt;*&gt; lookup 4 ls</span>
<span class="st">Just &quot;</span>hello world<span class="st">&quot;</span>

<span class="st">Prelude&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLine</span>
<span class="st">&quot;</span>hello <span class="st">&quot;</span>
<span class="st">&quot;</span>world<span class="st">&quot;</span>
<span class="st">&quot;</span>hello world<span class="st">&quot;</span>

<span class="st">Prelude&gt; fmap length $ (++) &lt;$&gt; getLine &lt;*&gt; getLine</span>
<span class="st">&quot;</span>hello <span class="st">&quot;</span>
<span class="st">&quot;</span>world<span class="st">&quot;</span>
<span class="st">11</span></code></pre></div>
<h4 id="identity">Identity</h4>
<p>Finally, we see a real use case for the <code>Identity</code> type we've been kicking around.<br />
By introducing this &quot;structure&quot; on top of another structure, we can lift functions to map over the Identity instead of an underlying structure.<br />
For instance, if we want to avoid messing with these lists, but still lift <code>const</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> const <span class="fu">&lt;$&gt;</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] <span class="fu">&lt;*&gt;</span> [<span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>]
[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>]
<span class="fu">&gt;&gt;&gt;</span> const <span class="fu">&lt;$&gt;</span> <span class="dt">Identity</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] <span class="fu">&lt;*&gt;</span> <span class="dt">Identity</span> [<span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>]
<span class="dt">Identity</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<p>In the first example, we have the list monoidal effect of <code>&lt;*&gt;</code>.<br />
In the second, we limit the monoidal affects by having them applied to the wrapper structure <code>Identity</code>, where the &quot;effects&quot; are minimal.</p>
<p>See instances of Identity and Constant in <a href="./IdentityConstant.hs">IdentityConstant.hs</a>.</p>
<h3 id="fixer-upper">Fixer Upper</h3>
<h5 id="const-just-hello-world"><code>const &lt;$&gt; Just &quot;Hello&quot; &lt;*&gt; &quot;World&quot;</code></h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> const <span class="fu">&lt;$&gt;</span> <span class="dt">Just</span> <span class="st">&quot;Hello&quot;</span> <span class="fu">&lt;*&gt;</span> pure <span class="st">&quot;World&quot;</span>
<span class="dt">Just</span> <span class="st">&quot;Hello&quot;</span></code></pre></div>
<h5 id="just-90-just-10-just-tierness-123">`(,,,) Just 90 &lt;*&gt; Just 10 Just &quot;Tierness&quot; [1,2,3]</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> (,,,) <span class="fu">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">90</span> <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> <span class="dv">10</span> <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> <span class="st">&quot;Tierness&quot;</span> <span class="fu">&lt;*&gt;</span> pure [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
<span class="dt">Just</span> (<span class="dv">90</span>,<span class="dv">10</span>,<span class="st">&quot;Tierness&quot;</span>,[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])
<span class="co">-- or</span>
λ<span class="fu">&gt;</span> (,,) <span class="fu">&lt;$&gt;</span> (liftA2 (<span class="fu">+</span>) (<span class="dt">Just</span> <span class="dv">90</span>) (<span class="dt">Just</span> <span class="dv">10</span>)) <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> <span class="st">&quot;Tierness&quot;</span> <span class="fu">&lt;*&gt;</span> pure [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
<span class="dt">Just</span> (<span class="dv">100</span>,<span class="st">&quot;Tierness&quot;</span>,[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</code></pre></div>
<h3 id="applicative-laws">17.6 Applicative Laws</h3>
<ol>
<li><strong>Identity</strong></li>
</ol>
<p><code>haskell   pure id &lt;*&gt; v = v   -- Putting 'id' into an applicative structure f via 'pure'   -- should not produce side effects: f id &lt;*&gt; f x = f x</code></p>
<ol>
<li><strong>Composition</strong></li>
</ol>
<p><code>haskell   pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)   -- Putting the act of composition into an applicative structure   -- should not produce side effects</code></p>
<ol>
<li><strong>Homomorphism</strong></li>
</ol>
<p><code>haskell   pure f &lt;*&gt; pure x = pure (f x)   -- Basically assuring that 'pure' is homomorphic, preserving   -- the algebraic isomorphism between categories,   -- such as the normal space and the applicative 'f' space</code></p>
<ol>
<li><strong>Interchange</strong></li>
</ol>
<p><code>haskell   u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u   -- Putting the act of function application into an applicative structure   -- shuld not produce side effects</code></p>
<h3 id="you-knew-this-was-coming">17.7 You knew this was coming</h3>
<p>Of course, <a href="./QuickChecking.hs">quickchecking applicative laws</a>.</p>
<h3 id="ziplist-monoid">17.8 ZipList Monoid</h3>
<p>The default list monoid in Prelude is concatenation, but if we constrain the type of the contents to monoids, here is another instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[x1,x2,x3] <span class="fu">&lt;&gt;</span> [y1,y2,y3]
 <span class="fu">=</span> [x1 <span class="fu">&lt;&gt;</span> y1, x2 <span class="fu">&lt;&gt;</span> y2, x3 <span class="fu">&lt;&gt;</span> y3]</code></pre></div>
<h4 id="list-and-ziplist-applicatives">List and ZipList Applicatives</h4>
<p>See <a href="./ZipList.hs">ZipList.hs</a> for <code>List</code> and <code>ZipList</code> instances, and some quickchecking on them.</p>
<h4 id="either-versus-validation">Either versus Validation</h4>
<p>Since monoids instances are not unique per type, like functors, applicatives can also have more than one valid instance per type. <code>Either</code> has an alternative applicative called <code>Validation</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Validation</span> err a <span class="fu">=</span>
    <span class="dt">Failure</span> err
  <span class="fu">|</span> <span class="dt">Success</span> a
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="co">-- natural transformations for Validation &lt;-&gt; Either</span>

<span class="ot">validToEither ::</span> <span class="dt">Validation</span> e a <span class="ot">-&gt;</span> <span class="dt">Either</span> e a
validToEither (<span class="dt">Failure</span> err) <span class="fu">=</span> <span class="dt">Left</span> err
validToEither (<span class="dt">Success</span> a)   <span class="fu">=</span> <span class="dt">Right</span> a
<span class="co">-- etc</span></code></pre></div>
<p>Validation is just like Either, except instead of short-circuiting on the first <code>Left</code> value, it accumulates <code>Failure</code> values in a monoidal manner. See <a href="./Validation.hs">Validation.hs</a> for instance definitions.</p>
<h1 id="monad">Monad</h1>
<p>The most popular topic in Haskell.</p>
<h3 id="monad-1">18.1 Monad</h3>
<p>Monads are not necessary to Haskell.<br />
While the current standard of the language uses monads for constructing and transforming <code>IO</code> actions, older versions did not.<br />
Monads are fun, but they do not define Haskell.</p>
<h3 id="sorry-----monad-is-not-a-burrito">18.2 Sorry --- Monad is not a burrito</h3>
<p>The monad typeclass is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
<span class="ot">  (&gt;&gt;) ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>These are the core operations, however only <code>(&gt;&gt;=)</code> is necessary for a complete minimal instance definition.<br />
<code>return</code> is not very interesting - it is just like <code>pure</code> from Applicative.<br />
<code>&gt;&gt;</code> is called the sequencing operator, because it sequences two actions, discarding any result from the first action.<br />
<code>&gt;&gt;=</code> is called bind, and is what really makes the monad special.<br />
Even the sequencing action <code>&gt;&gt;</code> has an Applicative counterpart not yet discussed.</p>
<h4 id="applicative-m">Applicative m</h4>
<p>The Applicative superclass of Monad is actually a more recent update to GHC.<br />
Just like how Applicative is stronger than Functor, we can derive both Functor and Applicative instances from Monad, for instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f xs <span class="fu">=</span> xs <span class="fu">&gt;&gt;=</span> return <span class="fu">.</span> f</code></pre></div>
<p>As we'll see, this is actually a law of monads.</p>
<h4 id="the-novel-part-of-monad">The novel part of monad</h4>
<p>The bind function on its own isn't all that magical or surprising. The type is very similar to <code>fmap</code> and <code>&lt;*&gt;</code>. In fact, we can specialize the <code>fmap</code> and get something kind of similar:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- fmap :: (a -&gt; b)   -&gt; f a -&gt; f b</span>
<span class="co">-- fmap :: (a -&gt; f b) -&gt; f a -&gt; f (f b)</span>
λ<span class="fu">&gt;</span> <span class="kw">let</span> andOne x <span class="fu">=</span> [x, <span class="dv">1</span>]
λ<span class="fu">&gt;</span> andOne <span class="dv">10</span>
[<span class="dv">10</span>,<span class="dv">1</span>]

λ<span class="fu">&gt;</span> fmap andOne [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]
[[<span class="dv">4</span>,<span class="dv">1</span>],[<span class="dv">5</span>,<span class="dv">1</span>],[<span class="dv">6</span>,<span class="dv">1</span>]]</code></pre></div>
<p>Except now we have the extra layer of nesting that we saw from the type <code>f (f b)</code>.<br />
For lists, we know that <code>concat</code> can solve that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> concat <span class="fu">$</span> fmap andOne [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]
[<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">1</span>]</code></pre></div>
<p>So, at least for lists, we have accomplished bind <code>&gt;&gt;=</code> via <code>fmap</code> and <code>concat</code>.<br />
As it turns out, Monad is in a sense a generalization of concat.<br />
The unique part of Monad is the <code>join</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">join ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (m a) <span class="ot">-&gt;</span> m a</code></pre></div>
<h4 id="exercise-write-bind-in-terms-of-fmap-and-join">Exercise: Write <code>bind</code> in terms of <code>fmap</code> and <code>join</code></h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bind ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b
bind f <span class="fu">=</span> join <span class="fu">.</span> fmap f</code></pre></div>
<h4 id="what-monad-is-not">What Monad is not</h4>
<p>Many people approach monad from one or two intuitive perspectives, such as restricting their thoughts to the <code>IO Monad</code>.<br />
This leads to limited intuitions for monads and often misconceived notions of what <code>IO</code> is really about.<br />
Luckily, I'm a mathematician, and don't fall for cheap tricks. A monad is precisely what its algebriac definition specifies. Regardless, here are notes of avoiding common pitfalls: a monad is <strong>not</strong></p>
<ol>
<li>Impure. All monadic functions are pure functions. <code>IO</code> is a datatype that allows for impure actions, and it has a <code>Monad</code> instance, but monads themselves are not impure.</li>
<li>An embedded language for imperative programming. Some monads are often used for sequencing actions, but there are plenty of commutative monads that do not order actions.</li>
<li>A value.</li>
<li>About strictness. The monadic operations <code>bind</code> and <code>return</code> are nonstrict.</li>
</ol>
<h4 id="monad-also-lifts">Monad also lifts!</h4>
<p>The <code>Monad</code> class includes a set of <code>lift</code> functions that are the same as those from <code>Applicative</code>, but have been around since before applicatives were discovered.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftA ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a  <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a  <span class="ot">-&gt;</span> f b
<span class="ot">liftM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span>       (a1 <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> m a1 <span class="ot">-&gt;</span> m r</code></pre></div>
<h3 id="do-syntax-and-monads">18.3 Do syntax and monads</h3>
<p>First, consider this function which exists for both applicatives and monads:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(*&gt;) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f b
<span class="ot">(&gt;&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span>       m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</code></pre></div>
<p>Other than the constraints, these should always do the same thing: sequence functions.</p>
<p>Now, consider some do/non-do operations that accomplish the same thing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- sequencing</span>
<span class="ot">sequencing ::</span> <span class="dt">IO</span> ()
sequencing <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;blah&quot;</span>
  putStrLn <span class="st">&quot;another thing&quot;</span>
<span class="ot">sequencing&#39; ::</span> <span class="dt">IO</span> ()
sequencing&#39; <span class="fu">=</span>
  putStrLn <span class="st">&quot;blah&quot;</span> <span class="fu">&gt;&gt;</span>
  putStrLn <span class="st">&quot;another thing&quot;</span>
<span class="ot">sequencing&#39;&#39; ::</span> <span class="dt">IO</span> ()
sequencing&#39;&#39; <span class="fu">=</span>
  putStrLn <span class="st">&quot;blah&quot;</span> <span class="fu">*&gt;</span>
  putStrLn <span class="st">&quot;another thing&quot;</span>

<span class="co">-- binding</span>
<span class="ot">binding ::</span> <span class="dt">IO</span> ()
binding <span class="fu">=</span> <span class="kw">do</span>
  name <span class="ot">&lt;-</span> getLine
  putStrLn name
<span class="ot">binding&#39; ::</span> <span class="dt">IO</span> ()
binding&#39; <span class="fu">=</span>
  getLine <span class="fu">&gt;&gt;=</span> putStrLn</code></pre></div>
<h3 id="when-fmap-alone-isnt-enough">When fmap alone isn't enough</h3>
<p>Notice that this doesn't work:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> putStrLn <span class="fu">&lt;$&gt;</span> getLine</code></pre></div>
<p>or at least, it doesn't output anything.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>t putStrLn <span class="fu">&lt;$&gt;</span> getLine
<span class="dt">IO</span> (<span class="dt">IO</span> ())</code></pre></div>
<p>To see why printing doesn't work here, first let's note one of Haskell's great strengths: we can refer to, compose, and map over effectful computations without performing them. Such as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> printOne <span class="fu">=</span> putStrLn <span class="st">&quot;1&quot;</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> printTwo <span class="fu">=</span> putStrLn <span class="st">&quot;2&quot;</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> twoActions <span class="fu">=</span> (printOne, printTwo)
<span class="dt">Prelude</span><span class="fu">&gt;</span> fst twoActions
<span class="dv">1</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> snd twoActions
<span class="dv">2</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> fst twoActions
<span class="dv">1</span></code></pre></div>
<p>So, returning to getting and printing the line:</p>
<ol>
<li>First <code>getLine</code> performs <code>IO</code> to get a <code>String</code> resulting in <code>IO String</code>.</li>
<li>And <code>putStrLn</code> takes a <code>String</code> argument, performs <code>IO</code>, and returns &quot;nothing&quot;: <code>String -&gt; IO ()</code>.</li>
<li>Thus <code>putStrLn &lt;$&gt; getLine :: IO (IO ())</code></li>
</ol>
<p>Because the result of <code>putStrLn</code> is wrapped in an extra <code>IO ()</code> layer, its effects do not take place, similar to us nesting print actions in the tuples above. Of course, <code>join</code> will fix this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad</span> (join)
<span class="dt">Prelude</span><span class="fu">&gt;</span> join <span class="fu">$</span> putStrLn <span class="fu">&lt;$&gt;</span> getLine
blah
blah
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t join <span class="fu">$</span> putStrLn <span class="fu">&lt;$&gt;</span> getLine
join <span class="fu">$</span> putStrLn <span class="fu">&lt;$&gt;</span><span class="ot"> getLine ::</span> <span class="dt">IO</span> ()</code></pre></div>
<p>Here, <code>join</code> merged the effects of these two functions into a single <code>IO</code> action - this merged <code>IO</code> action performs the effects in the &quot;order&quot; determined by the nesting of <code>IO</code> actions -- the definition of <code>join</code>! The cleanest way to express &quot;ordering&quot; in a lambda calculus is through nesting of expressions.</p>
<p>Back to equating do/non-do notation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bindingAndSequencing ::</span> <span class="dt">IO</span> ()
bindingAndSequencing <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;name pls:&quot;</span>
  name <span class="ot">&lt;-</span> getLine
  putStrLn (<span class="st">&quot;y helo thar: &quot;</span> <span class="fu">++</span> name)
<span class="ot">bindingAndSequencing&#39; ::</span> <span class="dt">IO</span> ()
bindingAndSequencing&#39; <span class="fu">=</span>
  putStrLn <span class="st">&quot;name pls:&quot;</span> <span class="fu">&gt;&gt;</span>
  getLine <span class="fu">&gt;&gt;=</span>
  \name <span class="ot">-&gt;</span> putStrLn (<span class="st">&quot;y helo thar: &quot;</span> <span class="fu">++</span> name)

<span class="ot">twoBinds ::</span> <span class="dt">IO</span> ()
twoBinds <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;name pls:&quot;</span>
  name <span class="ot">&lt;-</span> getLine
  putStrLn <span class="st">&quot;age pls:&quot;</span>
  age <span class="ot">&lt;-</span> getLine
  putStrLn (<span class="st">&quot;y helo thar: &quot;</span>
            <span class="fu">++</span> name <span class="fu">++</span> <span class="st">&quot; who is: &quot;</span>
            <span class="fu">++</span> age <span class="fu">++</span> <span class="st">&quot; years old.&quot;</span>)
<span class="ot">twoBinds&#39; ::</span> <span class="dt">IO</span> ()
twoBinds&#39; <span class="fu">=</span>
  putStrLn <span class="st">&quot;name pls:&quot;</span> <span class="fu">&gt;&gt;</span>
  getLine <span class="fu">&gt;&gt;=</span>
  \name <span class="ot">-&gt;</span>
  putStrLn <span class="st">&quot;age pls:&quot;</span> <span class="fu">&gt;&gt;</span>
  getLine <span class="fu">&gt;&gt;=</span>
  \age <span class="ot">-&gt;</span>
  putStrLn (<span class="st">&quot;y helo thar: &quot;</span>
            <span class="fu">++</span> name <span class="fu">++</span> <span class="st">&quot; who is: &quot;</span>
            <span class="fu">++</span> age <span class="fu">++</span> <span class="st">&quot; years old.&quot;</span>)</code></pre></div>
<p>Makes you appreciate <code>do</code> syntax.</p>
<h3 id="examples-of-monad-use">18.4 Examples of Monad use</h3>
<h4 id="list">List</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">twiceWhenEven ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
twiceWhenEven xs <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> xs
  <span class="kw">if</span> even x
    <span class="kw">then</span> [x<span class="fu">*</span>x, x<span class="fu">*</span>x]
    <span class="kw">else</span> [x<span class="fu">*</span>x]

λ<span class="fu">&gt;</span> twiceWhenEven [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]
[<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">9</span>]</code></pre></div>
<h4 id="maybe-1">Maybe</h4>
<p>For brevity, I'll just include the types of <code>Cow</code> and its validation methods:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Cow</span> <span class="fu">=</span> <span class="dt">Cow</span> {
<span class="ot">    name ::</span> <span class="dt">String</span>
  ,<span class="ot"> age ::</span> <span class="dt">Int</span>
  ,<span class="ot"> weight ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="ot">noEmpty ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span>
<span class="ot">noNegative ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="ot">weightCheck ::</span> <span class="dt">Cow</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Cow</span>
<span class="co">-- Now when making, let&#39;s use pretty do syntax:</span>
<span class="ot">mkSphericalCow ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Cow</span>
mkSphericalCow&#39; name&#39; age&#39; weight&#39; <span class="fu">=</span> <span class="kw">do</span>
  nammy <span class="ot">&lt;-</span> noEmpty name&#39;
  agey <span class="ot">&lt;-</span> noNegative age&#39;
  weighty <span class="ot">&lt;-</span> noNegative weight&#39;
  weightCheck (<span class="dt">Cow</span> nammy agey weighty)</code></pre></div>
<p>Note that we could <strong>not</strong> accomplish this with an Applicative, because <code>weightCheck</code> needs a <code>Cow</code> instance and returns more monadic structure. In general,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- This can be rewritten using Applicative</span>
doSomething <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> f
  b <span class="ot">&lt;-</span> g
  c <span class="ot">&lt;-</span> h
  pure (a, b, c)
<span class="co">-- This requires monad</span>
doSomething&#39; n <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> f n
  b <span class="ot">&lt;-</span> g a
  c <span class="ot">&lt;-</span> h b
  pure (a, b, c)</code></pre></div>
<p>The second example needs a <code>Monad</code> instance because <code>g</code> and <code>h</code> produce monadic structure, based on values (<code>a</code>, <code>b</code>) that can only be obtained by depending on values generated by monadic structure (<code>f n</code>, <code>g a</code>).</p>
<h3 id="either">Either</h3>
<p>Just going to include the type signatures from the <code>EitherMonad</code> example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">EitherMonad</span> <span class="kw">where</span>

<span class="co">-- years ago</span>
<span class="kw">type</span> <span class="dt">Founded</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="co">-- number of programmers</span>
<span class="kw">type</span> <span class="dt">Coders</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="kw">data</span> <span class="dt">SoftwareShop</span> <span class="fu">=</span>
  <span class="dt">Shop</span> {
<span class="ot">      founded ::</span> <span class="dt">Founded</span>
    ,<span class="ot"> programmers ::</span> <span class="dt">Coders</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">FoundedError</span> <span class="fu">=</span>
    <span class="dt">NegativeYears</span> <span class="dt">Founded</span>
  <span class="fu">|</span> <span class="dt">TooManyYears</span> <span class="dt">Founded</span>
  <span class="fu">|</span> <span class="dt">NegativeCoders</span> <span class="dt">Coders</span>
  <span class="fu">|</span> <span class="dt">TooManyCoders</span> <span class="dt">Coders</span>
  <span class="fu">|</span> <span class="dt">TooManyCodersForYears</span> <span class="dt">Founded</span> <span class="dt">Coders</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="co">-- validating methods</span>
<span class="ot">validateFounded ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">FoundedError</span> <span class="dt">Founded</span> <span class="co">-- year errors</span>
<span class="ot">validateCoders ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">FoundedError</span> <span class="dt">Coders</span>   <span class="co">-- coder errors</span>

<span class="co">-- make softwareshop</span>
<span class="ot">mkSoftware ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">FoundedError</span> <span class="dt">SoftwareShop</span>
mkSoftware years coders <span class="fu">=</span> <span class="kw">do</span>
  founded     <span class="ot">&lt;-</span> validateFounded years
  programmers <span class="ot">&lt;-</span> validateCoders coders
  <span class="kw">if</span> programmers <span class="fu">&gt;</span> div founded <span class="dv">10</span>
    <span class="kw">then</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">TooManyCodersForYears</span> founded programmers
    <span class="kw">else</span> <span class="dt">Right</span> <span class="fu">$</span> <span class="dt">Shop</span> founded programmers</code></pre></div>
<p><strong>Note</strong> <code>Either</code> always short-circuits on the <em>first</em> failure.<br />
This is important because in the monad, later values can depend on previous ones.<br />
So there is no <code>Monad</code> instance for <code>Validation</code>, since <code>Applicative</code> and <code>Monad</code> instances <strong>must</strong> have the same behavior.<br />
That is, the Applicative apply functionality must not change behavior when derived from the Monad instance's bind operation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span> (ap)
(<span class="fu">&lt;*&gt;</span>) <span class="fu">==</span> ap

<span class="co">-- where</span>
<span class="ot">ap ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b
ap g m <span class="fu">=</span> <span class="kw">do</span>
  f <span class="ot">&lt;-</span> g
  x <span class="ot">&lt;-</span> m
  return (f x)</code></pre></div>
<p>So if we tried to make a <code>Monad</code> instance for <code>Validation</code>, we'd end up with one identical to <code>Either</code>'s.</p>
<h4 id="exercise-implement-the-either-monad">Exercise: Implement the Either Monad</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">EitherMonad</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span> (liftA)

<span class="kw">data</span> <span class="dt">Sum</span> a b <span class="fu">=</span>
    <span class="dt">First</span> a
  <span class="fu">|</span> <span class="dt">Second</span> b
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Sum</span> a) <span class="kw">where</span>
  fmap <span class="fu">=</span> liftA

<span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Sum</span> a) <span class="kw">where</span>
  pure      <span class="fu">=</span> return
  (<span class="fu">&lt;*&gt;</span>) f x <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> (\x&#39; <span class="ot">-&gt;</span> f <span class="fu">&gt;&gt;=</span> (\f&#39; <span class="ot">-&gt;</span> return <span class="fu">$</span> f&#39; x&#39;))

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Sum</span> a) <span class="kw">where</span>
  return         <span class="fu">=</span> <span class="dt">Second</span>
  <span class="dt">First</span> x <span class="fu">&gt;&gt;=</span> _  <span class="fu">=</span> <span class="dt">First</span> x
  <span class="dt">Second</span> y <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f y</code></pre></div>
<h3 id="monad-laws">Monad laws</h3>
<h4 id="identity-laws">Identity laws</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- right identity</span>
m <span class="fu">&gt;&gt;=</span> return <span class="fu">=</span> m

<span class="co">-- left identity</span>
return x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x</code></pre></div>
<p>These laws are ensuring that <code>return</code> is neutral and doesn't do anything unexpected to a value <code>x</code> when it puts it into the monad structure as <code>m x</code>.</p>
<h4 id="associativity">Associativity</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(m <span class="fu">&gt;&gt;=</span> f) <span class="fu">&gt;&gt;=</span> g <span class="fu">=</span> m <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&gt;&gt;=</span> g)</code></pre></div>
<h3 id="application-and-composition">18.6 Application and composition</h3>
<p>Recall that in functor and applicative, function composition was guaranteed by the laws:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap id <span class="fu">=</span> id

<span class="co">-- guarantees ==&gt;</span>

fmap f <span class="fu">.</span> fmap g <span class="fu">=</span> fmap (f <span class="fu">.</span> g)</code></pre></div>
<p>It was also a bit simpler to reason about, since the function arguments <code>(a -&gt; b)</code> to <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> were not concerned with the structure <code>f</code>.</p>
<p>With monadic functions we need to worry about chaining around the monad <code>m</code>, since the function arguments are of type <code>(a -&gt; m b)</code>. Luckily <code>(&gt;&gt;=)</code> handles this out of the box:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mcomp ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m c
mcomp f g a <span class="fu">=</span> g a <span class="fu">&gt;&gt;=</span> f</code></pre></div>
<p>Haskell already has this implemented via <em>Kleisli composition</em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Note this is like flip (.), not (.)</span>
<span class="ot">(&gt;=&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m c

<span class="co">-- This one is like (.)</span>
<span class="ot">(&lt;=&lt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m c</code></pre></div>
<h3 id="chapter-exercises-6">18.7 Chapter Exercises</h3>
<p>See exercises in <a href="./Instances.hs">Instances.hs</a> and <a href="./Funcs.hs">Funcs.hs</a>.</p>
<h1 id="monads-gone-wild">Monads gone wild</h1>
<p>This chapter is a brief survey of &quot;how Haskellers write code when they think no one is looking&quot;. Mostly just code samples pasted for future reference.</p>
<h3 id="monoid-1">19.2 Monoid</h3>
<h4 id="templating-content-in-scotty">Templating content in Scotty</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import </span><span class="dt">Web.Scotty</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span> (mconcat)
main <span class="fu">=</span> scotty <span class="dv">3000</span> <span class="fu">$</span> <span class="kw">do</span>
  get <span class="st">&quot;/:word&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    beam <span class="ot">&lt;-</span> param <span class="st">&quot;word&quot;</span>
    html
    (mconcat
      [ <span class="st">&quot;&lt;h1&gt;Scotty, &quot;</span>
      , beam
      , <span class="st">&quot; me up!&lt;/h1&gt;&quot;</span>])</code></pre></div>
<h4 id="concatenating-connection-parameters">Concatenating connection parameters</h4>
<p>From Aditya Bhargava's &quot;Making a Website With Haskell&quot;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runDb ::</span> <span class="dt">SqlPersist</span> (<span class="dt">ResourceT</span> <span class="dt">IO</span>) a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
runDb query <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> connStr <span class="fu">=</span>
    foldr (\(k,v) t <span class="ot">-&gt;</span>
      t <span class="fu">&lt;&gt;</span> (encodeUtf8 <span class="fu">$</span>
      k <span class="fu">&lt;&gt;</span> <span class="st">&quot;=&quot;</span> <span class="fu">&lt;&gt;</span> v <span class="fu">&lt;&gt;</span> <span class="st">&quot; &quot;</span>))
    <span class="st">&quot;&quot;</span> params
  runResourceT <span class="fu">.</span> withPostgresqlConn connStr
    <span class="fu">$</span> runSqlConn query</code></pre></div>
<p>Scotty tutorials will make more sense have exploring monad transformers.</p>
<h4 id="concatenating-key-configurations">Concatenating key configurations</h4>
<p>This example is an Xmonad configuration snippet, to <code>mappend</code> custom keys with the defaults:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">XMonad</span>
<span class="kw">import </span><span class="dt">XMonad.Actions.Volume</span>
<span class="kw">import </span><span class="dt">Data.Map.Lazy</span> (fromList)
<span class="kw">import </span><span class="dt">Data.Monoid</span> (mappend)

main <span class="fu">=</span> <span class="kw">do</span>
  xmonad def { keys <span class="fu">=</span>
    \c <span class="ot">-&gt;</span> fromList [
      ((<span class="dv">0</span>, xK_F7),
        lowerVolume <span class="dv">4</span> <span class="fu">&gt;&gt;</span> return ()),
      ((<span class="dv">0</span>, xK_F8),
        raiseVolume <span class="dv">4</span> <span class="fu">&gt;&gt;</span> return ())
    ] <span class="ot">`mappend`</span> keys defaultConfig c
  }

<span class="co">-- where</span>
<span class="ot">keys ::</span> <span class="fu">!</span>(<span class="dt">XConfig</span> <span class="dt">Layout</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> (<span class="dt">ButtonMask</span>, <span class="dt">KeySym</span>) (<span class="dt">X</span> ()))</code></pre></div>
<p>The exclamation point is syntax for <em>strictness annotation</em> which forces that field of the product record to weak-head normal form. Anyway, the monoid instance above is for functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> b <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (a <span class="ot">-&gt;</span> b)</code></pre></div>
<h3 id="functor-1">19.3 Functor</h3>
<h4 id="lifting-over-io">Lifting over IO</h4>
<p>Lifting a normal time function into IO:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Time.Clock</span>

<span class="ot">addUTCTime ::</span> <span class="dt">NominalDiffTime</span> <span class="ot">-&gt;</span> <span class="dt">UTCTime</span> <span class="ot">-&gt;</span> <span class="dt">UTCTime</span>
<span class="ot">getCurrentTime ::</span> <span class="dt">IO</span> <span class="dt">UTCTime</span>

<span class="ot">offsetCurrentTime ::</span> <span class="dt">NominalDiffTime</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">UTCTime</span>
offsetCurrentTime offset <span class="fu">=</span>
  fmap (addUTCTime (offset <span class="fu">*</span> <span class="dv">24</span> <span class="fu">*</span> <span class="dv">3600</span>)) <span class="fu">$</span>
    getCurrentTime</code></pre></div>
<p>Lifting some text transformation functions over the UUID library touching an outside resource to generate random identifiers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>)
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.UUID</span> <span class="kw">as</span> <span class="dt">UUID</span>
<span class="kw">import qualified</span> <span class="dt">Data.UUID.V4</span> <span class="kw">as</span> <span class="dt">UUIDv4</span>

<span class="ot">textUuid ::</span> <span class="dt">IO</span> <span class="dt">Text</span>
textUuid <span class="fu">=</span>
  fmap (T.pack <span class="fu">.</span> UUID.toString) UUIDv4.nextRandom</code></pre></div>
<h4 id="lifting-over-web-app-monads">Lifting over web app monads</h4>
<p>Often when writing web apps, there is a custom datatype to describe the web app with a <code>Monad</code> instance.<br />
The &quot;app context&quot; will have a type parameter to describe the result of running the web app.<br />
Here is an exammple lifting over both <code>AppHandler</code> and <code>Maybe</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">userAgent ::</span> <span class="dt">AppHandler</span> (<span class="dt">Maybe</span> <span class="dt">UserAgent</span>)
userAgent <span class="fu">=</span> (fmap <span class="fu">.</span> fmap) userAgent&#39; getRequest

<span class="ot">userAgent&#39; ::</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">UserAgent</span>
userAgent&#39; req <span class="fu">=</span>
  getHeader <span class="st">&quot;User-Agent&quot;</span> req</code></pre></div>
<p>The functor is necessary here because we can't pattern match on the <code>AppHandler</code>.<br />
Basically, Snap keeps all of the context in this <code>AppHandler</code>.. it doesn't make sense to do all the legwork of configuration, server initialization, sending a request, etc., every time we need a value that is only obtained during the course of running a web app.<br />
The Functor let's us write functions over this structure to handle all that.<br />
The function is passed to the app handler in a way that says &quot;apply this to a thing that results from an HTTP request, if one comes along&quot;.</p>
<h3 id="applicative-1">19.4 Applicative</h3>
<h4 id="hgrev">hgrev</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">jsonSwitch ::</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a)
jsonSwitch <span class="fu">=</span>
  infoOption <span class="fu">$</span>(hgRevStateTH jsonFormat)
  <span class="fu">$</span> long <span class="st">&quot;json&quot;</span>
  <span class="fu">&lt;&gt;</span> short <span class="ch">&#39;J&#39;</span>
  <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Display JSON version information&quot;</span>

<span class="ot">parserInfo ::</span> <span class="dt">ParserInfo</span> (a <span class="ot">-&gt;</span> a)
parserInfo <span class="fu">=</span> info (helper <span class="fu">&lt;*&gt;</span> verSwitch <span class="fu">&lt;*</span> jsonSwitch) fullDesc

<span class="co">-- where x &lt;* y throws away result of the second action</span>
<span class="ot">(&lt;*) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</code></pre></div>
<h4 id="more-parsing">More parsing</h4>
<p>Here is a very common use case of applicative to lift data constructors over parsers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- JSON</span>
<span class="ot">parseJSON ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
<span class="ot">(.:) ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">Object</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Payload</span> <span class="kw">where</span>
  parseJSON (<span class="dt">Object</span> v) <span class="fu">=</span> <span class="dt">Payload</span> <span class="fu">&lt;$&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;from&quot;</span>
                                 <span class="fu">&lt;*&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;to&quot;</span>
                                 <span class="fu">&lt;*&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;subject&quot;</span>
                                 <span class="fu">&lt;*&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;body&quot;</span>
                                 <span class="fu">&lt;*&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;offset_seconds&quot;</span>
  parseJSON v          <span class="fu">=</span> typeMismatch <span class="st">&quot;Payload&quot;</span> v

<span class="co">-- CSV</span>
<span class="ot">parseRecord ::</span> <span class="dt">Record</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a

<span class="kw">instance</span> <span class="dt">FromRecord</span> <span class="dt">Release</span> <span class="kw">where</span>
  parseRecord v
    <span class="fu">|</span> V.length v <span class="fu">==</span> <span class="dv">5</span> <span class="fu">=</span> <span class="dt">Release</span> <span class="fu">&lt;$&gt;</span> v <span class="fu">.!</span> <span class="dv">0</span>
                                <span class="fu">&lt;*&gt;</span> v <span class="fu">.!</span> <span class="dv">1</span>
                                <span class="fu">&lt;*&gt;</span> v <span class="fu">.!</span> <span class="dv">2</span>
                                <span class="fu">&lt;*&gt;</span> v <span class="fu">.!</span> <span class="dv">3</span>
                                <span class="fu">&lt;*&gt;</span> v <span class="fu">.!</span> <span class="dv">4</span>
    <span class="fu">|</span> otherwise <span class="fu">=</span> mzero</code></pre></div>
<p>A more complex, yet very terse example using functor, applicative, and monad techniques:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Deserializeable</span> <span class="dt">ShowInfoResp</span> <span class="kw">where</span>
  parser <span class="fu">=</span> e2err <span class="fu">=&lt;&lt;</span> convertPairs <span class="fu">.</span> HM.fromList <span class="fu">&lt;$&gt;</span> parsePairs
    <span class="kw">where</span>
<span class="ot">      parsePairs ::</span> <span class="dt">Parser</span> [(<span class="dt">Text</span>, <span class="dt">Text</span>)]
      parsePairs <span class="fu">=</span> parsePair <span class="ot">`sepBy`</span> endOfLine
      parsePair  <span class="fu">=</span> liftA2 (,) parseKey parseValue
      parseKey   <span class="fu">=</span> takeTill (<span class="fu">==</span> <span class="ch">&#39;:&#39;</span>) <span class="fu">&lt;*</span> kvSep
      kvSep      <span class="fu">=</span> string <span class="st">&quot;: &quot;</span>
      parseValue <span class="fu">=</span> takeTill isEndOfLine</code></pre></div>
<p>Lifting into a function space!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Web.Shipping.Utils</span> ((<span class="fu">&lt;||&gt;</span>)) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span> (liftA2)

<span class="ot">(&lt;||&gt;) ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
(<span class="fu">&lt;||&gt;</span>) <span class="fu">=</span> liftA2 (<span class="fu">||</span>)</code></pre></div>
<p>With this utility, we can avoid something like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> (\n <span class="ot">-&gt;</span> f n <span class="fu">||</span> g n) arg</code></pre></div>
<p>and write</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> (f <span class="fu">&lt;||&gt;</span> g) arg</code></pre></div>
<h3 id="monad-2">19.5 Monad</h3>
<p>Since effectful programming is constrained in Haskell in <code>IO</code>, examples of monad usage are abundant. Here are a few different, interesting use cases.</p>
<h4 id="opening-a-network-socket">Opening a network socket</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Network.Socket</span>
<span class="ot">openSocket ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Socket</span>
openSocket p <span class="fu">=</span> <span class="kw">do</span>
  sock <span class="ot">&lt;-</span> socket <span class="dt">AF_UNIX</span> <span class="dt">Stream</span> defaultProtocol
  connect sock sockAddr
  return sock
  <span class="kw">where</span> sockAddr <span class="fu">=</span> <span class="dt">SockAddrUnix</span> <span class="fu">.</span> encodeString <span class="fu">$</span> p</code></pre></div>
<h4 id="binding-over-failure-in-initialization">Binding over failure in initialization</h4>
<p>This <code>main</code> function is more typical; the outermost monad is <code>IO</code> but the monad transformer variant of <code>Either</code>, called <code>EitherT</code>, binds over the possibility of failure to pull up correct configuration in constructing an initialization function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  initAndFp <span class="ot">&lt;-</span> runEitherT <span class="fu">$</span> <span class="kw">do</span>
    fp <span class="ot">&lt;-</span> tryHead <span class="dt">NoConfig</span> <span class="fu">=&lt;&lt;</span> lift getArgs
    initCfg <span class="ot">&lt;-</span> load&#39; fp
    return (initCfg, fp)
  either bail (uncurry boot) initAndFp
  <span class="kw">where</span>
    boot initCfg fp <span class="fu">=</span>
      void <span class="fu">$</span> runMVC mempty
             oracleModel (core initCfg fp)
    bail <span class="dt">NoConfig</span> <span class="fu">=</span>
      errorExit <span class="st">&quot;Please pass a config&quot;</span>
    bail (<span class="dt">InvalidConfig</span> e) <span class="fu">=</span>
      errorExit (<span class="st">&quot;Invalid config &quot;</span> <span class="fu">++</span> show e)
    load&#39; fp <span class="fu">=</span>
      hoistEither
      <span class="fu">.</span> fmapL <span class="dt">InvalidConfig</span> <span class="fu">=&lt;&lt;</span> lift (load fp)</code></pre></div>
<h3 id="an-end-to-end-example-url-shortener">19.6 An end-to-end example: URL shortener</h3>
<p>See <a href="./shawty">shawty</a> for code.</p>
<h4 id="brief-aside-about-polymorphic-literals">Brief aside about polymorphic literals</h4>
<p>We start off <a href="./shawty/src/Main.hs">our code</a> with the language extension<br />
<code>{-# LANGUAGE OverloadedStrings #-}</code>.<br />
This is a way to make <code>String</code> literals polymorphic, just like numeric literals are polymorphic over the <code>Num</code> typeclass. This way we can use string literals as <code>Text</code> and <code>ByteString</code> values. Notice the similarities:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsString</span> a <span class="kw">where</span>
<span class="ot">  fromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a

<span class="kw">class</span> <span class="dt">Num</span> a <span class="kw">where</span>
  <span class="co">-- irrelevant bits elided</span>
<span class="ot">  fromInteger ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a

<span class="kw">class</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> a <span class="kw">where</span>
  <span class="co">-- Elision again</span>
<span class="ot">  fromRational ::</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> a</code></pre></div>
<p>and see the effect:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dv">1</span>
<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="fl">1.0</span>
<span class="fl">1.0</span><span class="ot"> ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="st">&quot;blah&quot;</span>
<span class="st">&quot;blah&quot;</span><span class="ot"> ::</span> <span class="dt">IsString</span> a <span class="ot">=&gt;</span> a</code></pre></div>
<h1 id="foldable">Foldable</h1>
<p>The <code>Foldable</code> typeclass generalizes catamorphisms past the list type. The folding function is always dependent on some Monoid instance.</p>
<h3 id="the-foldable-class">20.2 The Foldable class</h3>
<p>Notice the <code>MINIMAL</code> annotation that allows us to minimally define an instance with either <code>foldMap</code> <strong>or</strong> <code>foldr</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Foldable</span> (<span class="ot">t ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
  <span class="ot">{-# MINIMAL foldMap | foldr #-}</span>
<span class="ot">  fold ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> t m <span class="ot">-&gt;</span> m
<span class="ot">  foldMap ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m
<span class="ot">  foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b
<span class="ot">  foldr&#39; ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b
<span class="ot">  foldl ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b
<span class="ot">  foldl&#39; ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b
<span class="ot">  foldr1 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> a
<span class="ot">  foldl1 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> a
<span class="ot">  toList ::</span> t a <span class="ot">-&gt;</span> [a]
<span class="ot">  null ::</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">  length ::</span> t a <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">  elem ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">  maximum ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a
<span class="ot">  minimum ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a
<span class="ot">  sum ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a
<span class="ot">  product ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a</code></pre></div>
<h3 id="revenge-of-the-monoids">20.3 Revenge of the monoids</h3>
<p>Folding necessarily implies a binary associative operation that has an identity value, which is why the <code>Monoid</code> constraint is explicit in <code>fold</code> and <code>foldMap</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fold ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> t m <span class="ot">-&gt;</span> m
foldMap<span class="ot"> ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m</code></pre></div>
<p>Notice we don't need an explicit constraint in the other class functions, since we specify the binary operation and identities in the usage:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</code></pre></div>
<p>As an example, here's how we'd fold over:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- summation</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> fold [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Sum</span> <span class="dt">Integer</span>]
<span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">15</span>}
<span class="dt">Prelude</span><span class="fu">&gt;</span> foldMap <span class="dt">Sum</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]
<span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">10</span>}

<span class="co">-- boolean conjunction</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> foldMap <span class="dt">All</span> [<span class="dt">True</span>, <span class="dt">False</span>, <span class="dt">True</span>]
<span class="dt">All</span> {getAll <span class="fu">=</span> <span class="dt">False</span>}

<span class="co">-- boolean disjunction</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> foldMap <span class="dt">Any</span> [(<span class="dv">3</span> <span class="fu">==</span> <span class="dv">4</span>), (<span class="dv">9</span> <span class="fu">&gt;</span> <span class="dv">5</span>)]
<span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}</code></pre></div>
<p>Notice <code>foldMap</code> is nice for specifying a data constructor as the function creating a monoid, but it can obviously do more:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> foldMap (<span class="dt">Sum</span> <span class="fu">.</span> (<span class="fu">*</span><span class="dv">2</span>)) [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]
<span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">30</span>}</code></pre></div>
<h3 id="demonstrating-foldable-instances">20.4 Demonstrating Foldable instances</h3>
<h4 id="identity-1">Identity</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Identity</span> a
<span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Identity</span> <span class="kw">where</span>
  foldr f z (<span class="dt">Identity</span> x) <span class="fu">=</span> f x z
  foldl f z (<span class="dt">Identity</span> x) <span class="fu">=</span> f z x <span class="co">-- not necessary to specify</span>
  foldMap f (<span class="dt">Identity</span> x) <span class="fu">=</span> f x <span class="co">-- not necessary to specify</span></code></pre></div>
<p>Usually catamorphisms reduce a bunch of values down to a summary value, but in this case the point is less to <em>reduce</em> and more to <em>consume</em> or <em>use</em> the value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> foldl (<span class="fu">*</span>) <span class="dv">5</span> (<span class="dt">Identity</span> <span class="dv">5</span>)
<span class="dv">25</span></code></pre></div>
<h4 id="maybe-2">Maybe</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Optional</span> a <span class="fu">=</span> <span class="dt">Nada</span> <span class="fu">|</span> <span class="dt">Yep</span> a
<span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Optional</span> <span class="kw">where</span>
  foldr _ z <span class="dt">Nada</span>    <span class="fu">=</span> z
  foldr f z (<span class="dt">Yep</span> x) <span class="fu">=</span> f x z
  <span class="co">-- or</span>
  foldMap _ <span class="dt">Nada</span>    <span class="fu">=</span> mempty
  foldMap f (<span class="dt">Yep</span> a) <span class="fu">=</span> f a</code></pre></div>
<h3 id="some-basic-derived-operations">20.5 Some basic derived operations</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | List of elements of a structure, from left to right.</span>
<span class="ot">toList ::</span> t a <span class="ot">-&gt;</span> [a]

λ<span class="fu">&gt;</span> toList (<span class="dt">Just</span> <span class="dv">1</span>)
[<span class="dv">1</span>]

<span class="co">-- note that the foldable instance used for tuple (a,b) is defined for ((,) a)</span>
<span class="co">-- as we have seen before</span>
λ<span class="fu">&gt;</span> toList (<span class="dv">1</span>, <span class="dv">2</span>)
[<span class="dv">2</span>]

<span class="co">-- | Test whether the structure is empty.</span>
<span class="co">-- The default implementation is</span>
<span class="co">-- optimized for structures that are similar</span>
<span class="co">-- to cons-lists, because there</span>
<span class="co">-- is no general way to do better.</span>
null<span class="ot"> ::</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>

λ<span class="fu">&gt;</span> null (<span class="dt">Left</span> <span class="dv">3</span>)
<span class="dt">True</span>
λ<span class="fu">&gt;</span> null []
<span class="dt">True</span>

<span class="co">-- | Returns the size/length of a finite</span>
<span class="co">-- structure as an &#39;Int&#39;.</span>
<span class="dt">The</span> default
<span class="co">-- implementation is optimized for structures</span>
<span class="co">-- that are similar to cons-lists, because there</span>
<span class="co">-- is no general way to do better.</span>
length<span class="ot"> ::</span> t a <span class="ot">-&gt;</span> <span class="dt">Int</span>

λ<span class="fu">&gt;</span> length (<span class="dv">1</span>, <span class="dv">2</span>)
<span class="dv">1</span>
λ<span class="fu">&gt;</span> length [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">6</span>)]
<span class="dv">3</span>

<span class="co">-- | Does the element occur in the structure?</span>
elem<span class="ot"> ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>

λ<span class="fu">&gt;</span> elem <span class="dv">1</span> (<span class="dt">Just</span> <span class="dv">3</span>)
<span class="dt">False</span>
λ<span class="fu">&gt;</span> elem <span class="dt">True</span> (<span class="dt">Left</span> <span class="dt">True</span>)
<span class="dt">False</span>
λ<span class="fu">&gt;</span> elem <span class="dt">True</span> (<span class="dt">Right</span> <span class="dt">True</span>)
<span class="dt">True</span>

<span class="co">-- | The largest element of a non-empty structure.</span>
maximum<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a
<span class="co">-- | The least element of a non-empty structure.</span>
minimum<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a

λ<span class="fu">&gt;</span> maximum [<span class="dv">10</span>, <span class="dv">12</span>, <span class="dv">33</span>]
<span class="dv">33</span>
λ<span class="fu">&gt;</span> fmap maximum [<span class="dt">Just</span> <span class="dv">10</span>, <span class="dt">Just</span> <span class="dv">12</span>, <span class="dt">Just</span> <span class="dv">33</span>]
[<span class="dv">10</span>, <span class="dv">12</span>, <span class="dv">33</span>]
λ<span class="fu">&gt;</span> fmap maximum <span class="dt">Just</span> [<span class="dv">10</span>, <span class="dv">12</span>, <span class="dv">33</span>]
<span class="dt">Just</span> <span class="dv">33</span>
λ<span class="fu">&gt;</span> fmap minimum [<span class="dt">Just</span> <span class="dv">4</span>, <span class="dt">Just</span> <span class="dv">3</span>, <span class="dt">Nothing</span>]
[<span class="dv">4</span>,<span class="dv">3</span>,<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> minimum<span class="fu">:</span> empty structure

<span class="co">-- | Computes the sum of numbers in a structure</span>
sum<span class="ot"> ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a

<span class="co">-- | Computes the product of numbers in a structure</span>
product<span class="ot"> ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a

λ<span class="fu">&gt;</span> fmap sum [(<span class="dv">7</span>, <span class="dv">5</span>), (<span class="dv">3</span>, <span class="dv">4</span>)]
[<span class="dv">5</span>,<span class="dv">4</span>]
λ<span class="fu">&gt;</span> fmap sum (<span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>])
<span class="dt">Just</span> <span class="dv">15</span>
λ<span class="fu">&gt;</span> fmap product (<span class="dt">Just</span> [])
<span class="dt">Just</span> <span class="dv">1</span>
λ<span class="fu">&gt;</span> fmap product (<span class="dt">Right</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])
<span class="dt">Right</span> <span class="dv">6</span></code></pre></div>
<h4 id="exercises-library-functions">Exercises: Library Functions</h4>
<p>See <a href="./LibraryFuncs.hs">LibraryFuncs.hs</a>.</p>
<h3 id="chapter-exercises-7">20.6 Chapter Exercises</h3>
<p>See <a href="./Instances.hs">Instances.hs</a>.</p>
<h1 id="traversable">21 Traversable</h1>
<p>Traversable was introduced in the same paper as Applicative, and while it's been in the <code>base</code> library for a while, it was only recently added to the Prelude in GHC 7.10. It depends on Applicative, Functor, and is superclassed by Foldable.</p>
<p>Traversable allows the transformation of elements inside a structure like a Functor, producing Applicative results along the way, and lifts those potentially multiple instances of Applicative structure outside of the Traversable structure.</p>
<h3 id="the-traversable-typeclass-definition">21.2 The Traversable typeclass definition</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> t, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> <span class="dt">Traversable</span> t <span class="kw">where</span>
  <span class="ot">{-# MINIMAL traverse | sequenceA #-}</span>

  <span class="co">-- | Map each element of a structure to an action,</span>
  <span class="co">-- evaluate these actions from left to right, and</span>
  <span class="co">-- collect the results. For a version that ignores</span>
  <span class="co">-- the results see &#39;Data.Foldable.traverse_&#39;.</span>
<span class="ot">  traverse ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span>
              (a <span class="ot">-&gt;</span> f b)
           <span class="ot">-&gt;</span> t a
           <span class="ot">-&gt;</span> f (t b)
  traverse f <span class="fu">=</span> sequenceA <span class="fu">.</span> fmap f

  <span class="co">-- | Evaluate each action in the structure from</span>
  <span class="co">-- left to right, and collect the results.</span>
  <span class="co">-- For a version that ignores the results see</span>
  <span class="co">-- &#39;Data.Foldable.sequenceA_&#39;.</span>
<span class="ot">  sequenceA ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f (t a)
  sequenceA <span class="fu">=</span> traverse id</code></pre></div>
<h3 id="sequencea">21.3 <code>sequenceA</code></h3>
<p>We can see from the type signature that <code>sequenceA</code> basically flips the contexts of Applicative and Traversable - there is no function application to the inner type <code>a</code> value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> fmap <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
[<span class="dt">Just</span> <span class="dv">1</span>, <span class="dt">Just</span> <span class="dv">2</span>, <span class="dt">Just</span> <span class="dv">3</span>]

λ<span class="fu">&gt;</span> sequenceA [<span class="dt">Just</span> <span class="dv">1</span>, <span class="dt">Just</span> <span class="dv">2</span>, <span class="dt">Just</span> <span class="dv">3</span>]
<span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]

<span class="co">-- Nothing clobbers the Maybe applicative</span>
λ<span class="fu">&gt;</span> sequenceA [<span class="dt">Just</span> <span class="dv">1</span>, <span class="dt">Just</span> <span class="dv">2</span>, <span class="dt">Nothing</span>]
<span class="dt">Nothing</span>

λ<span class="fu">&gt;</span> fmap sum <span class="fu">$</span> sequenceA [<span class="dt">Just</span> <span class="dv">1</span>, <span class="dt">Just</span> <span class="dv">2</span>, <span class="dt">Just</span> <span class="dv">3</span>]
<span class="dt">Just</span> <span class="dv">6</span>

λ<span class="fu">&gt;</span> fmap sum <span class="fu">$</span> sequenceA [<span class="dt">Just</span> <span class="dv">1</span>, <span class="dt">Just</span> <span class="dv">2</span>, <span class="dt">Nothing</span>]
<span class="dt">Nothing</span></code></pre></div>
<h3 id="traverse">21.4 <code>traverse</code></h3>
<p>Let's compare <code>traverse</code> with a few familiar functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap<span class="ot">     ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">(=&lt;&lt;)    ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b
traverse<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)
   <span class="kw">where</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</code></pre></div>
<p>There is still a mapping of a function over embedded values, like <code>fmap</code>, but similar to <code>flip bind</code>, that function is itself generating more structure (but that structure can be of a different type than the structure we're lifting over to apply the function). Then, the structures are flipped just like <code>sequenceA</code>. This is easily seen from the definition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">traverse f <span class="fu">=</span> sequenceA <span class="fu">.</span> fmap f

λ<span class="fu">&gt;</span> fmap <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
[<span class="dt">Just</span> <span class="dv">1</span>,<span class="dt">Just</span> <span class="dv">2</span>,<span class="dt">Just</span> <span class="dv">3</span>]

λ<span class="fu">&gt;</span> sequenceA <span class="fu">$</span> fmap <span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
<span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]

λ<span class="fu">&gt;</span> sequenceA <span class="fu">.</span> fmap <span class="dt">Just</span> <span class="fu">$</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
<span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]

λ<span class="fu">&gt;</span> traverse <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
<span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<h4 id="mapm-is-just-traverse">mapM is just traverse</h4>
<p>Prior to GHC 7.10, <code>mapM</code> had type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mapM<span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [b]

<span class="co">-- constrasted with</span>

traverse<span class="ot"> ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</code></pre></div>
<p>So we see that <code>traverse</code> abstracts <code>[]</code> to any <code>Traversable t</code> and <code>Monad m</code> to <code>Applicative f</code>.<br />
This way, we can use this pattern across more types.<br />
One specific scenario where this is handy is when squeezing out performance, using the Vector Traversable instance instead of a list.</p>
<p>In the same way, <code>sequenceA</code> is a more useful generalized version of the <code>sequence</code> prior to 7.10:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence<span class="ot">  ::</span> <span class="dt">Monad</span> m                        <span class="ot">=&gt;</span> [m a]   <span class="ot">-&gt;</span> m [a]
sequenceA<span class="ot"> ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f (t a)</code></pre></div>
<h3 id="so-whats-traversable-for">21.5 So, what's traversable for?</h3>
<p>Vaguely, anytime you need to flip two type constructors around, or map something and then flip them around, you can probably use Traversable.<br />
Here are some examples of getting types the way we want them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f        ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
<span class="ot">xs       ::</span> [a]
map f<span class="ot"> xs ::</span> [<span class="dt">Maybe</span> b]

<span class="co">-- if we want Maybe [b]</span>

sequenceA <span class="fu">$</span> map f<span class="ot"> xs ::</span> <span class="dt">Maybe</span> [b]
traverse f<span class="ot"> xs        ::</span> <span class="dt">Maybe</span> [b]</code></pre></div>
<h3 id="morce-code-revisited">21.6 Morce code revisited</h3>
<p>Back in the <a href="../14_Testing/morse/src/Morse.hs">morse code example</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Previously, we fmapped from [Char] to [Maybe Char] and then sequenced to Maybe [Char]</span>
<span class="ot">stringToMorse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Morse</span>]
stringToMorse s <span class="fu">=</span> sequence <span class="fu">$</span> fmap charToMorse s

<span class="co">-- With traverse, this is much cleaner:</span>
<span class="ot">stringToMorse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Morse</span>]
stringToMorse <span class="fu">=</span> traverse charToMorse</code></pre></div>
<p>As an aside: we defined <code>traverse</code> above as <code>traverse f = sequenceA . fmap f</code>. We lift the function <code>f</code> by partially applying <code>fmap</code> and then use composition in the normal fashion. We could eta reduce this by composing <em>twice</em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>t \f <span class="ot">-&gt;</span> sequence <span class="fu">.</span> fmap f
(<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)
λ<span class="fu">&gt;</span> <span class="fu">:</span>t (sequence <span class="fu">.</span>) <span class="fu">.</span> fmap
(<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</code></pre></div>
<p>That double <code>.</code> looks a bit weird; it's because <code>fmap</code> takes <em>two</em> arguments, so we need to compose twice to await a second argument for <code>fmap</code> to get applied to. If only composed once, the second argument would not behave as expected:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- correct</span>
(sequence <span class="fu">.</span>) <span class="fu">.</span> fmap <span class="fu">=</span> \f xs <span class="ot">-&gt;</span> sequence (fmap f xs)

<span class="co">-- incorrect</span>
sequence <span class="fu">.</span> fmap <span class="fu">=</span> \f <span class="ot">-&gt;</span> sequence (fmap f)</code></pre></div>
<p>To recap, <code>sequence</code> is the bit unique to the <code>Traversable</code> class, and <code>traverse</code> is just <code>sequence</code> and <code>fmap</code>, but you end up <code>fmap</code>ing before <code>sequence</code> very often.<br />
This is just like how <code>join</code> is the bit unique to <code>Monad</code>, and <code>&gt;&gt;=</code> is <code>join</code> composed with <code>fmap</code>, but it turns out that's what you need most of the time.</p>
<h3 id="axing-tedious-code">21.7 Axing tedious code</h3>
<p>Let's take a look at some code that needs refactoring:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Query</span>     <span class="fu">=</span> <span class="dt">Query</span>
<span class="kw">data</span> <span class="dt">SomeObj</span>   <span class="fu">=</span> <span class="dt">SomeObj</span>
<span class="kw">data</span> <span class="dt">IoOnlyObj</span> <span class="fu">=</span> <span class="dt">IoOnlyObj</span>
<span class="kw">data</span> <span class="dt">Err</span>       <span class="fu">=</span> <span class="dt">Err</span>

<span class="co">-- There&#39;s a decoder function that makes</span>
<span class="co">-- some object from String</span>
<span class="ot">decodeFn ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Err</span> <span class="dt">SomeObj</span>
decodeFn <span class="fu">=</span> undefined

<span class="co">-- There&#39;s a query, that runs against DB and</span>
<span class="co">-- returns array of strings</span>
<span class="ot">fetchFn ::</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">String</span>]
fetchFn <span class="fu">=</span> undefined

<span class="co">-- there&#39;s some additional &quot;context initializer&quot;,</span>
<span class="co">-- that also has IO side-effects</span>
<span class="ot">makeIoOnlyObj ::</span> [<span class="dt">SomeObj</span>]
              <span class="ot">-&gt;</span> <span class="dt">IO</span> [(<span class="dt">SomeObj</span>, <span class="dt">IoOnlyObj</span>)]
makeIoOnlyObj <span class="fu">=</span> undefined

<span class="co">-- the function we&#39;re examining</span>
<span class="ot">pipelineFn ::</span> <span class="dt">Query</span>
           <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">Err</span> [(<span class="dt">SomeObj</span>, <span class="dt">IoOnlyObj</span>)])
pipelineFn query <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> fetchFn query
  <span class="kw">case</span> sequence (map decodeFn a) <span class="kw">of</span>
    (<span class="dt">Left</span> err) <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">Left</span> <span class="fu">$</span> err
    (<span class="dt">Right</span> res) <span class="ot">-&gt;</span> <span class="kw">do</span>
      a <span class="ot">&lt;-</span> makeIoOnlyObj res
      return <span class="fu">$</span> <span class="dt">Right</span> a</code></pre></div>
<p>There are three things that should stand out in need of refactor:</p>
<ol>
<li>the use of <code>sequence (map ..)</code></li>
<li>manualling casing on the result of <code>sequence (map ..)</code></li>
<li>binding monadically over Either only to perform another monadic (IO) action inside Either</li>
</ol>
<p>The refactored version is much shorter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- the function we&#39;re examining</span>
<span class="ot">pipelineFn ::</span> <span class="dt">Query</span>
           <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">Err</span> [(<span class="dt">SomeObj</span>, <span class="dt">IoOnlyObj</span>)])
pipelineFn query <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> fetchFn query
  traverse makeIoOnlyObj (mapM decodeFn a)
  <span class="co">-- or traverse makeIoOnlyObj (traverse decodeFn a)</span></code></pre></div>
<p>The <code>traverse decodeFn</code> is acting on Traversable list and Either monad, while <code>traverse makeIoOnlyObj</code> is acting on Traversable Either and IO monad.<br />
Or we can go pointfree:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pipelineFn <span class="fu">=</span>
  (traverse makeIoOnlyObj <span class="fu">.</span> traverse decodeFn <span class="fu">=&lt;&lt;</span>) <span class="fu">.</span> fetchFn</code></pre></div>
<h3 id="do-all-the-things">21.8 Do all the things</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">HttpStuff</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.ByteString.Lazy</span> <span class="kw">hiding</span> (map)
<span class="kw">import </span><span class="dt">Network.Wreq</span>

<span class="ot">urls ::</span> [<span class="dt">String</span>]
urls <span class="fu">=</span> [ <span class="st">&quot;http://httpbin.com/ip&quot;</span>
       , <span class="st">&quot;http://httpbin.org/bytes/5&quot;</span>
       ]

<span class="ot">mappingGet ::</span> [<span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">ByteString</span>)]
mappingGet <span class="fu">=</span> map get urls

<span class="ot">traversedUrls ::</span> <span class="dt">IO</span> [<span class="dt">Response</span> <span class="dt">ByteString</span>]
traversedUrls <span class="fu">=</span> traverse get urls</code></pre></div>
<h4 id="strength-for-understanding">Strength for understanding</h4>
<p>Traversable is <em>stronger</em> than both Functor and Foldable. Watch how we can recover their functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- fmap</span>
λ<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Functor.Identity</span>
λ<span class="fu">&gt;</span> <span class="kw">let</span> fmap&#39; f t <span class="fu">=</span> runIdentity <span class="fu">$</span> traverse (<span class="dt">Identity</span> <span class="fu">.</span> f) t
λ<span class="fu">&gt;</span> <span class="fu">:</span>t fmap&#39;
<span class="ot">fmap&#39; ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t b
λ<span class="fu">&gt;</span> fmap&#39; (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]
[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]

<span class="co">-- foldMap</span>
λ<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Monoid</span>
λ<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Functor.Constant</span>
λ<span class="fu">&gt;</span> <span class="kw">let</span> foldMap&#39; f t <span class="fu">=</span> getConstant <span class="fu">$</span> traverse (<span class="dt">Constant</span> <span class="fu">.</span> f) t
λ<span class="fu">&gt;</span> <span class="fu">:</span>t foldMap&#39;
<span class="ot">foldMap&#39; ::</span> (<span class="dt">Monoid</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> (a1 <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t a1 <span class="ot">-&gt;</span> a</code></pre></div>
<h3 id="traversable-instances">21.9 Traversable instances</h3>
<h4 id="either-1">Either</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Traversable</span> (<span class="dt">Either</span> a) <span class="kw">where</span>
  traverse _ (<span class="dt">Left</span> x)  <span class="fu">=</span> pure (<span class="dt">Left</span> x)
  traverse f (<span class="dt">Right</span> y) <span class="fu">=</span> <span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> f y</code></pre></div>
<h4 id="tuple">Tuple</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Traversable</span> ((,) a) <span class="kw">where</span>
  traverse f (x,y)  <span class="fu">=</span> (,) x <span class="fu">&lt;$&gt;</span> f y</code></pre></div>
<h3 id="traversable-laws">21.10 Traversable Laws</h3>
<p>The <strong>traverse</strong> function must satisfy the following:</p>
<ol>
<li>Naturality</li>
</ol>
<p><code>haskell   t . traverse f = traverse (t . f)</code><br />
Function composition behaves in unsurprising ways, whether within the traversed function or on the outer layer, once the traversed function has already generated the applicative structure.</p>
<ol>
<li>Identity</li>
</ol>
<p><code>haskell   traverse Identity = Identity</code><br />
Traversing the data constructor of Identity will produce the same result as just putting the value in Identity.<br />
Hence Identity represents a &quot;structural&quot; identity for traversing data.<br />
That is, the Traversable instance cannot add or inject any structure or unsuspecting &quot;effects&quot;.</p>
<ol>
<li>Composition</li>
</ol>
<p><code>haskell   traverse (Compose . fmap g . f)     = Compose . fmap (traverse g) . traverse f</code><br />
We can collapse sequential traversals into a single traversal</p>
<p>The <strong>sequenceA</strong> function must satisfy the following:</p>
<ol>
<li>Naturality</li>
</ol>
<p><code>haskell   t . sequenceA = sequenceA . fmap t</code></p>
<ol>
<li>Identity</li>
</ol>
<p><code>haskell   sequenceA . fmap Identity = Identity</code></p>
<ol>
<li>Composition</li>
</ol>
<p><code>haskell   sequenceA . fmap Compose     = Compose . fmap sequenceA . sequenceA</code></p>
<h3 id="quality-control">21.11 Quality Control</h3>
<p>See <a href="./QuickChecker.hs">QuickChecker.hs</a> for examples quickchecking Traversable instances.</p>
<h1 id="reader">Reader</h1>
<p>The Reader newtype allows us to pass around information that might be needed intermittently or universally throughout an application.</p>
<h3 id="a-new-beginning">22.2 A new beginning</h3>
<p>Consider the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Applicative</span>

boop <span class="fu">=</span> (<span class="fu">*</span><span class="dv">2</span>)
doop <span class="fu">=</span> (<span class="fu">+</span><span class="dv">10</span>)

<span class="ot">bip ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
bip <span class="fu">=</span> boop <span class="fu">.</span> doop

<span class="ot">bloop ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
bloop <span class="fu">=</span> fmap boop doop</code></pre></div>
<p><code>bip</code> and <code>bloop</code> do the same thing here.<br />
We are fmapping <code>boop</code> over the functorial context of a function <code>doop</code>, which is equivalent to composition.<br />
We can take this further via applicative:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bbop ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
bbop <span class="fu">=</span> (<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> boop <span class="fu">&lt;*&gt;</span> doop

<span class="ot">duwop ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
duwop <span class="fu">=</span> liftA2 (<span class="fu">+</span>) boop doop</code></pre></div>
<p>This adds another function <code>(+)</code> to lift over the context of the functions <code>boop</code> and <code>doop</code>.<br />
Now, an argument will get passed to both <code>boop</code> and <code>doop</code> in parallel, and the results will be passed to <code>(+)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> duwop <span class="dv">3</span>
<span class="dv">19</span></code></pre></div>
<p>To help with the mental type juggling, we can assert a more concrete type for functions like <code>&lt;*&gt;</code> and see if the compiler agrees in the possibility:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>t (<span class="fu">&lt;*&gt;</span>)
<span class="ot">(&lt;*&gt;) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

λ<span class="fu">&gt;</span> <span class="fu">:</span>t<span class="ot"> (&lt;*&gt;) ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)
<span class="ot">(&lt;*&gt;) ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)
<span class="ot">  ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
λ<span class="fu">&gt;</span></code></pre></div>
<p>This is useful when two functions share the same input and we want to apply another function to both results.<br />
Here's a real life example, calculating if either of two predicates is satisfied by a single input:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Web.Shipping.Utils</span> ((<span class="fu">&lt;||&gt;</span>)) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span> (liftA2)

<span class="ot">(&lt;||&gt;) ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
(<span class="fu">&lt;||&gt;</span>) <span class="fu">=</span> liftA2 (<span class="fu">||</span>)</code></pre></div>
<p>These are the main ideas of <em>Reader</em>.<br />
It is a way of stringing functions together when all those functions are awaiting one input from a shared environment.<br />
A common use case is when we have a constant value that is obtained from outside of the program that will be an argument to a whole bunch of functions.<br />
Reader allows us to avoid passing that argument around explicitly.</p>
<h4 id="warming-up">Warming Up</h4>
<p>Given <code>cap</code> and <code>rev</code>, implement <code>composed</code>, <code>fmapped</code>, and <code>tupled</code> below.<br />
Write <code>tupled</code> in applicative, monadic <code>do</code>, and monadic <code>&gt;&gt;=</code> contexts.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span>

<span class="ot">cap ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]
cap xs <span class="fu">=</span> map toUpper xs

<span class="ot">rev ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]
rev xs <span class="fu">=</span> reverse xs

<span class="ot">composed ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]
composed <span class="fu">=</span> rev <span class="fu">.</span> cap

<span class="ot">fmapped ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]
fmapped <span class="fu">=</span> fmap rev cap

<span class="ot">tupled ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> ([<span class="dt">Char</span>], [<span class="dt">Char</span>])
tupled <span class="fu">=</span> liftA2 (,) rev cap
tupled <span class="fu">=</span> rev <span class="fu">&gt;&gt;=</span> (\r <span class="ot">-&gt;</span> cap <span class="fu">&gt;&gt;=</span> (\c <span class="ot">-&gt;</span> return (r,c)))
tupled <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> rev
  c <span class="ot">&lt;-</span> cap
  return (r, c)</code></pre></div>
<h3 id="this-is-reader">22.3 This is Reader</h3>
<p>We use function composition because it lets us compose two functions without explicitly having to recognize the argument that will eventually arrive.<br />
The <em>Functor</em> of functions is function composition;<br />
with this functor, we can map an ordinary function <code>b -&gt; c</code> over another function <code>a -&gt; b</code>,<br />
to create a new function awaiting a final argument of type <code>a</code>.<br />
The <em>Applicative</em> and <em>Monad</em> instances for function allow us to map a function that is awaiting an argument <code>a</code> over <em>another</em> function that is awaiting an argument of type <code>a</code>.</p>
<h3 id="breaking-down-the-functor-of-functions">22.4 Breaking down the Functor of functions</h3>
<p>One thing to keep in mind is that the functor instance is defined for <code>(-&gt;) r</code>,<br />
the partially applied type constructor of functions.<br />
Similar to the functor instances for <code>Either a</code> and <code>(,) a</code>,<br />
this means that given a function type <code>(-&gt;) r b</code>,<br />
we are lifting over <code>(-&gt;) r</code> and only transforming the <code>b</code> value.</p>
<p>So the argument of the function is part of the structure being lifted over,<br />
while the result of the function is the value being transformed.<br />
This lines up with composition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.)  ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)
fmap<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</code></pre></div>
<p>It is clear that substituting <code>f</code> with <code>((-&gt;) a)</code> results in composition.</p>
<h3 id="but-uh-reader">22.5 But uh, Reader?</h3>
<p>Reader is a newtype wrapper for functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Reader</span> r a <span class="fu">=</span>
  <span class="dt">Reader</span> {<span class="ot"> runReader ::</span> r <span class="ot">-&gt;</span> a }

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> r) <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">Reader</span> r b
  fmap f (<span class="dt">Reader</span> ra) <span class="fu">=</span> <span class="dt">Reader</span> <span class="fu">$</span> (f <span class="fu">.</span> ra)</code></pre></div>
<p>And we can see that fmap for Reader is basically</p>
<ol>
<li>unpack <code>g :: r -&gt; a</code> out of Reader</li>
<li>Compose <code>f</code> with <code>g</code></li>
<li>Put <code>f</code> . <code>g</code> back into Reader</li>
</ol>
<h4 id="exercise-ask">Exercise: Ask</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">Reader</span> a a
ask <span class="fu">=</span> <span class="dt">Reader</span> id</code></pre></div>
<h3 id="functions-have-an-applicative-too">22.6 Functions have an Applicative too</h3>
<p>First, let's specialize the types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pure<span class="ot"> ::</span> a <span class="ot">-&gt;</span> f a
pure<span class="ot"> ::</span> a <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a)

<span class="ot">(&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">(&lt;*&gt;) ::</span> (r <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> b)</code></pre></div>
<h4 id="demonstrating-the-function-applicative">Demonstrating the function applicative</h4>
<p>Given the two records:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span>
  <span class="dt">Person</span> {
<span class="ot">    humanName ::</span> <span class="dt">HumanName</span>
  ,<span class="ot"> dogName ::</span> <span class="dt">DogName</span>
  ,<span class="ot"> address ::</span> <span class="dt">Address</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Dog</span> <span class="fu">=</span>
  <span class="dt">Dog</span> {
<span class="ot">    dogsName ::</span> <span class="dt">DogName</span>
  ,<span class="ot"> dogsAddress ::</span> <span class="dt">Address</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>here's an example of avoiding explicitly passing around arguments:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- without Reader</span>
<span class="ot">getDog ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Dog</span>
getDog p <span class="fu">=</span> <span class="dt">Dog</span> (dogName p) (address p)

<span class="co">-- with Reader</span>
<span class="ot">getDog ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Dog</span>
getDog <span class="fu">=</span> <span class="dt">Dog</span> <span class="fu">&lt;$&gt;</span> dogName <span class="fu">&lt;*&gt;</span> address

<span class="co">-- with Reader, alternate</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span> (liftA2)
<span class="ot">getDog ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Dog</span>
getDog <span class="fu">=</span> liftA2 <span class="dt">Dog</span> dogName address</code></pre></div>
<h4 id="exercise-reading-comprehension">Exercise: Reading Comprehension</h4>
<ol>
<li>Write <code>liftA2</code>.</li>
</ol>
<p><code>haskell   myLiftA2 :: Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c   myLiftA2 f x y = f &lt;$&gt; x &lt;*&gt; y</code></p>
<ol>
<li>Write <code>asks</code> based on its type signature.</li>
</ol>
<p><code>haskell   asks :: (r -&gt; a) -&gt; Reader r a   asks = Reader</code></p>
<ol>
<li>Implement Applicative for Reader</li>
</ol>
<p>```haskell<br />
{-# LANGUAGE InstanceSigs #-}<br />
module Test where</p>
<p>newtype Reader r a = Reader { runReader :: (r -&gt; a) }</p>
<p>instance Functor (Reader r) where<br />
fmap f (Reader ra) = Reader $ f . ra</p>
<p>instance Applicative (Reader r) where<br />
pure :: a -&gt; Reader r a<br />
pure a = Reader $ const a</p>
<pre><code>(&lt;*&gt;) :: Reader r (a -&gt; b)
      -&gt; Reader r a
      -&gt; Reader r b
(Reader rab) &lt;*&gt; (Reader ra) =
  Reader $ \r -&gt; rab r (ra r)</code></pre>
<p>```</p>
<h3 id="the-monad-of-functions">22.7 The Monad of functions</h3>
<p>This is a cute example to derive <code>&gt;&gt;=</code>, from specific to abstract:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foo ::</span> (<span class="dt">Functor</span> f, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f a
foo r <span class="fu">=</span> fmap (<span class="fu">+</span><span class="dv">1</span>) r

<span class="ot">bar ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> t <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> (t, <span class="dt">Int</span>)
bar r t <span class="fu">=</span> (r, length t)

<span class="co">-- combined action</span>
<span class="ot">frooty ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> ([a], <span class="dt">Int</span>)
frooty r <span class="fu">=</span> bar (foo r) r

<span class="co">-- abstracted</span>
<span class="ot">fooBind ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> b)
fooBind m k <span class="fu">=</span> \r <span class="ot">-&gt;</span> k (m r) r</code></pre></div>
<h4 id="exercise-implement-the-reader-monad">Exercise: Implement the Reader Monad</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> r) <span class="kw">where</span>
  return <span class="fu">=</span> pure
<span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">Reader</span> r a
        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Reader</span> r b)
        <span class="ot">-&gt;</span> <span class="dt">Reader</span> r b
  (<span class="dt">Reader</span> ra) <span class="fu">&gt;&gt;=</span> aRb <span class="fu">=</span>
    <span class="dt">Reader</span> <span class="fu">$</span> \r <span class="ot">-&gt;</span> runReader (aRb (ra r)) r</code></pre></div>
<h3 id="reader-monad-by-itself-is-kinda-boring">22.8 Reader Monad by itself is kinda boring</h3>
<p>Because it can't do anything that the Applicative can't:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> ((<span class="ot">-&gt;</span>) r) <span class="kw">where</span>
  return <span class="fu">=</span> pure
  m <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> flip k <span class="fu">&lt;*&gt;</span> m</code></pre></div>
<p>Of course this isn't generally true, but we can take advantage of the fact that we're operating on functions (usage of <code>flip</code>).</p>
<h3 id="you-can-change-what-comes-below-but-not-above">22.9 You can change what comes below, but not above</h3>
<p>The &quot;read-only&quot; means that within any given scope (say the body of a function <code>foo</code>),<br />
you can swap in a different type/value for the &quot;read-only&quot; <code>r</code> for subsequent functions that you call,<br />
but not for functions outside the scope, like the function calling <code>foo</code>.<br />
It's kind of painfully obvious, given the natural immutability of Haskell.<br />
However, in the next chapter the State monad will contrast this principle.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">outer <span class="fu">=</span>
  <span class="co">-- foo cannot change r</span>
  foo r
  <span class="co">-- foo cannot change r</span>
  other r

foo r <span class="fu">=</span>
  <span class="co">-- foo can choose to modify r for subsequence funcs</span>
  bar (r<span class="fu">+</span><span class="dv">1</span>)

bar r <span class="fu">=</span> print r</code></pre></div>
<h3 id="you-tend-to-see-readert-not-reader">22.10 You tend to see ReaderT, not Reader</h3>
<p>Usually it's just one Monad in a <strong>stack</strong> of multiple types,<br />
such as the monad transformer ReaderT.<br />
Also, Reader of Int is almost trivial.<br />
Usually the type is a record of several values.</p>
<h3 id="chapter-exercises-8">22.11 Chapter Exercises</h3>
<p>Warm up questions (odd ones, not useful as notes) in <a href="./ReaderPractice.hs">ReaderPractice.hs</a>.<br />
A more meaningful problem is <a href="./shawty-prime/app/Main.hs">rewriting shawty</a><br />
to use ReaderT to make the database connection available,<br />
instead of the <a href="https://github.com/bitemyapp/shawty-prime/blob/master/app/Main.hs">original version</a><br />
which manually passed the database connection to the app.</p>
<h1 id="state">State</h1>
<h3 id="what-is-state">23.2 What is state?</h3>
<p>The concept of state originates in automata theory, with binary &quot;state&quot; of each cell value.<br />
The definition is more broad now, and is essentially the entire stored information within a program.</p>
<p>In most imperative languages, statefulness is pervasive and implicit.<br />
This is obviously forbidden in Haskell, given referential transparency;<br />
all we can do is accept arguments and return a result.<br />
The monadic interface for state is a convenient and clean way of handling potentially changing values<br />
without resorting to mutability.<br />
While the monadic interface is not <em>necessary</em>, it does allow us to have state which</p>
<ol>
<li>does not require IO</li>
<li>is limited only to data in State container</li>
<li>maintains referential transparency</li>
<li>is explicit in type signatures</li>
</ol>
<p>There are other ways to share data within a program as well;<br />
the State datatype is appropriate when you want to express your program in terms of values that<br />
potentially vary with each evaluation step,<br />
which can be read and modified,<br />
but don't otherwise have specific operational constraints.</p>
<h3 id="the-state-newtype">23.4 The State newtype</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span>
  <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }

<span class="co">-- compared to</span>
<span class="kw">newtype</span> <span class="dt">Reader</span> r a <span class="fu">=</span>
  <span class="dt">Reader</span> {<span class="ot"> runReader ::</span> r <span class="ot">-&gt;</span> a }</code></pre></div>
<h4 id="aside-about-isomorphism">Aside about isomorphism</h4>
<p>Since newtypes have the same underlying representation as the type they wrap<br />
(the wrapper disappears at compile time),<br />
the function contained in the newtype must be isomorphic to the type it wraps.<br />
This is clearly true with a function <code>st :: s -&gt; (a, s)</code>,<br />
as we can go into the newtype via the data constructor: <code>State st :: State s a</code><br />
and we can go from the newtype via the accessor: <code>runState (State st) :: s -&gt; (a, s)</code>.<br />
Clearly this is an isomorphism and <code>runState</code> is the inverse of <code>State</code>.</p>
<p>Contrast this with functions of type <code>a -&gt; Maybe b</code>, <code>b -&gt; Maybe a</code> -- these<br />
are not guaranteed isomorphisms, due to the possibilty of failure.</p>
<h3 id="throw-down">23.5 Throw down</h3>
<p>Let's use this and <code>random</code> to generate die (<a href="./RandomExampleV2.hs">source</a>):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">RandomExampleV2</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span> (liftA3)
<span class="kw">import </span><span class="dt">Control.Monad</span> (replicateM)
<span class="kw">import </span><span class="dt">Control.Monad.Trans.State</span>
<span class="kw">import </span><span class="dt">System.Random</span>

<span class="kw">data</span> <span class="dt">Die</span> <span class="fu">=</span>
    <span class="dt">One</span>
  <span class="fu">|</span> <span class="dt">Two</span>
  <span class="fu">|</span> <span class="dt">Three</span>
  <span class="fu">|</span> <span class="dt">Four</span>
  <span class="fu">|</span> <span class="dt">Five</span>
  <span class="fu">|</span> <span class="dt">Six</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">intToDie ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Die</span>
intToDie n <span class="fu">=</span>
  <span class="kw">case</span> n <span class="kw">of</span>
    <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">One</span>
    <span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dt">Two</span>
    <span class="dv">3</span> <span class="ot">-&gt;</span> <span class="dt">Three</span>
    <span class="dv">4</span> <span class="ot">-&gt;</span> <span class="dt">Four</span>
    <span class="dv">5</span> <span class="ot">-&gt;</span> <span class="dt">Five</span>
    <span class="dv">6</span> <span class="ot">-&gt;</span> <span class="dt">Six</span>
    x <span class="ot">-&gt;</span> error <span class="fu">$</span> <span class="st">&quot;intToDie got non 1-6 integer: &quot;</span> <span class="fu">++</span> show x

<span class="co">{-</span>
<span class="co">type State s = StateT s Identity</span>
<span class="co">state :: Monad m =&gt; (s -&gt; (a, s)) -&gt; StateT s m a</span>
<span class="co">      ::            (s -&gt; (a, s)) -&gt; State s a</span>
<span class="co">-}</span>
<span class="ot">rollDie&#39; ::</span> <span class="dt">State</span> <span class="dt">StdGen</span> <span class="dt">Die</span>
rollDie&#39; <span class="fu">=</span> state <span class="fu">$</span> <span class="kw">do</span>
  (n, s) <span class="ot">&lt;-</span> randomR (<span class="dv">1</span>,<span class="dv">6</span>)
  return (intToDie n, s)

<span class="co">-- Nice! Fmapping into the Functor (State StdGen :: * -&gt; *)</span>
<span class="ot">rollDie ::</span> <span class="dt">State</span> <span class="dt">StdGen</span> <span class="dt">Die</span>
rollDie <span class="fu">=</span> intToDie <span class="fu">&lt;$&gt;</span> state (randomR (<span class="dv">1</span>,<span class="dv">6</span>))

<span class="co">-- Nice! Lifting into the Applicative (State StdGen :: * -&gt; *)</span>
<span class="ot">rollDieThrice ::</span> <span class="dt">State</span> <span class="dt">StdGen</span> (<span class="dt">Die</span>, <span class="dt">Die</span>, <span class="dt">Die</span>)
rollDieThrice <span class="fu">=</span> liftA3 (,,) rollDie rollDie rollDie

<span class="co">-- This results in a list of all the same values! We&#39;re repeating a single die value</span>
<span class="ot">infiniteDie ::</span> <span class="dt">State</span> <span class="dt">StdGen</span> [<span class="dt">Die</span>]
infiniteDie <span class="fu">=</span> repeat <span class="fu">&lt;$&gt;</span> rollDie

<span class="co">-- We need to repeat the action that produces a die.</span>
<span class="co">-- replicateM :: Monad m =&gt; Int -&gt; m a -&gt; m [a]</span>
<span class="ot">nDie ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">StdGen</span> [<span class="dt">Die</span>]
nDie n <span class="fu">=</span> replicateM n rollDie

<span class="co">-- Keeping rolling die until we reach 20</span>
<span class="ot">rollsToGetTwenty ::</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
rollsToGetTwenty <span class="fu">=</span> go <span class="dv">0</span> <span class="dv">0</span>
  <span class="kw">where</span><span class="ot"> go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
        go sum count gen
          <span class="fu">|</span> sum <span class="fu">&gt;=</span> <span class="dv">20</span> <span class="fu">=</span> count
          <span class="fu">|</span> otherwise <span class="fu">=</span>
            <span class="kw">let</span> (die, nextG) <span class="fu">=</span> randomR (<span class="dv">1</span>, <span class="dv">6</span>) gen
             <span class="kw">in</span> go (sum <span class="fu">+</span> die) (count <span class="fu">+</span> <span class="dv">1</span>) nextG

λ<span class="fu">&gt;</span> rollsToGetTwenty (mkStdGen <span class="dv">0</span>)
<span class="dv">5</span>
λ<span class="fu">&gt;</span> rollsToGetTwenty (mkStdGen <span class="dv">10</span>)
<span class="dv">6</span>
λ<span class="fu">&gt;</span> rollsToGetTwenty <span class="fu">.</span> mkStdGen <span class="fu">&lt;$&gt;</span> randomIO
<span class="dv">6</span>
λ<span class="fu">&gt;</span> rollsToGetTwenty <span class="fu">.</span> mkStdGen <span class="fu">&lt;$&gt;</span> randomIO
<span class="dv">5</span></code></pre></div>
<h4 id="exercises-roll-your-own">Exercises: Roll Your Own</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 1. Refactor rollsToGetTwenty into having the limit be a function argument.</span>
<span class="ot">rollsToGetN ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
rollsToGetN n <span class="fu">=</span> go <span class="dv">0</span> <span class="dv">0</span>
  <span class="kw">where</span><span class="ot"> go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
        go sum count gen
          <span class="fu">|</span> sum <span class="fu">&gt;=</span> n <span class="fu">=</span> count
          <span class="fu">|</span> otherwise <span class="fu">=</span>
            <span class="kw">let</span> (die, nextG) <span class="fu">=</span> randomR (<span class="dv">1</span>, <span class="dv">6</span>) gen
             <span class="kw">in</span> go (sum <span class="fu">+</span> die) (count <span class="fu">+</span> <span class="dv">1</span>) nextG

<span class="co">-- 2. Change rollsToGetN to recording the series of die that occurred in addition to the count.</span>
<span class="ot">rollsCountLogged ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, [<span class="dt">Die</span>])
rollsCountLogged n <span class="fu">=</span> go <span class="dv">0</span> (<span class="dv">0</span>, [])
  <span class="kw">where</span><span class="ot"> go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, [<span class="dt">Die</span>]) <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, [<span class="dt">Die</span>])
        go sum (count, ds) gen
          <span class="fu">|</span> sum <span class="fu">&gt;=</span> n <span class="fu">=</span> (count, ds)
          <span class="fu">|</span> otherwise <span class="fu">=</span>
            <span class="kw">let</span> (die, nextG) <span class="fu">=</span> randomR (<span class="dv">1</span>, <span class="dv">6</span>) gen
             <span class="kw">in</span> go (sum <span class="fu">+</span> die) (count <span class="fu">+</span> <span class="dv">1</span>, intToDie die <span class="fu">:</span> ds) nextG</code></pre></div>
<h3 id="write-state-for-yourself">23.6 Write State for yourself</h3>
<p>Source <a href="./Moi.hs">here</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span>
<span class="kw">module</span> <span class="dt">Moi</span> <span class="kw">where</span>

<span class="kw">newtype</span> <span class="dt">Moi</span> s a <span class="fu">=</span>
  <span class="dt">Moi</span> {<span class="ot"> runMoi ::</span> s <span class="ot">-&gt;</span> (a, s) }

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Moi</span> s) <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Moi</span> s a <span class="ot">-&gt;</span> <span class="dt">Moi</span> s b
  fmap f (<span class="dt">Moi</span> g) <span class="fu">=</span> <span class="dt">Moi</span> <span class="fu">$</span>
    \s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, sg) <span class="fu">=</span> g s
           <span class="kw">in</span> (f a, sg)

<span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Moi</span> s) <span class="kw">where</span>
<span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Moi</span> s a
  pure a <span class="fu">=</span> <span class="dt">Moi</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (a, s)
<span class="ot">  (&lt;*&gt;) ::</span> <span class="dt">Moi</span> s (a <span class="ot">-&gt;</span> b)
        <span class="ot">-&gt;</span> <span class="dt">Moi</span> s a
        <span class="ot">-&gt;</span> <span class="dt">Moi</span> s b
  (<span class="dt">Moi</span> f) <span class="fu">&lt;*&gt;</span> (<span class="dt">Moi</span> g) <span class="fu">=</span> <span class="dt">Moi</span> <span class="fu">$</span>
    \s <span class="ot">-&gt;</span> <span class="kw">let</span> (fab, sf) <span class="fu">=</span> f s
              (a, sg)   <span class="fu">=</span> g sf
           <span class="kw">in</span> (fab a, sg)

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Moi</span> s) <span class="kw">where</span>
  return <span class="fu">=</span> pure
<span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">Moi</span> s a
        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Moi</span> s b)
        <span class="ot">-&gt;</span> <span class="dt">Moi</span> s b
  (<span class="dt">Moi</span> f) <span class="fu">&gt;&gt;=</span> g <span class="fu">=</span> <span class="dt">Moi</span> <span class="fu">$</span>
    \s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, sf) <span class="fu">=</span> f s
           <span class="kw">in</span> runMoi (g a) sf</code></pre></div>
<h3 id="chapter-exercises-9">23.8 Chapter Exercises</h3>
<p>Source <a href="./Moi.hs">here</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 1</span>
<span class="ot">get ::</span> <span class="dt">Moi</span> s s
get <span class="fu">=</span> <span class="dt">Moi</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (s,s)

<span class="co">-- 2</span>
<span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">Moi</span> s ()
put s <span class="fu">=</span> <span class="dt">Moi</span> <span class="fu">$</span> const ((), s)

<span class="co">-- 3</span>
<span class="ot">exec ::</span> <span class="dt">Moi</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
exec (<span class="dt">Moi</span> sa) s <span class="fu">=</span> snd <span class="fu">$</span> sa s

<span class="co">-- 4</span>
<span class="ot">eval ::</span> <span class="dt">Moi</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
eval (<span class="dt">Moi</span> sa) s <span class="fu">=</span> fst <span class="fu">$</span> sa s

<span class="co">-- 5</span>
<span class="ot">modify ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">Moi</span> s ()
modify f <span class="fu">=</span> <span class="dt">Moi</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> ((), f s)</code></pre></div>
<h1 id="parser-combinators">Parser Combinators</h1>
<p>This chapter doesn't go too in depth into the demonstrated parsing libraries,<br />
or even parsing itself really.<br />
It's just a short practical introduction to enable use of Haskell's parsing libraries.</p>
<h3 id="understanding-the-parsing-process">24.3 Understanding the parsing process</h3>
<p>A <strong>parser</strong> is a function that takes some textual input (String, ByteString, Text, etc.)<br />
and returns some <strong>structure</strong> as an output.</p>
<p>A <strong>parser combinator</strong> is a higher-order function that takes parsers as input<br />
and returns a new parser as output.<br />
(Recall combinators from the lambda calculus: <em>combinators</em> are expressions with no free variables.)<br />
Usually the argument passing is elided,<br />
as the interface for parsers will often be like the State monad, with implicit argument passing.<br />
Combinators allow for parsing data according to complex rules by gluing together parsers in a modular fashion.</p>
<h4 id="the-parsing-process">The parsing process</h4>
<p>The basic idea behind a parser is that you're moving a cursor around a linear stream of text,<br />
and as we progressively build up parsing,<br />
we'll think in <em>chunkier</em> terms than character by character.</p>
<p>One of the hardest problems in writing parsers is expressing things in a human-friendly way,<br />
while maintaining performance.</p>
<p>The following examples use the <a href="http://hackage.haskell.org/package/trifecta-1.5.2">trifecta</a> library.<br />
Let's parse a single character, and then die using <code>unexpected</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">LearnParsers</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Text.Trifecta</span>

<span class="ot">one ::</span> <span class="dt">CharParsing</span> m <span class="ot">=&gt;</span> m <span class="dt">Char</span>
one <span class="fu">=</span> char <span class="ch">&#39;1&#39;</span>

<span class="ot">stop ::</span> <span class="dt">Parser</span> a
stop <span class="fu">=</span> unexpected <span class="st">&quot;stop&quot;</span>

run <span class="fu">=</span> one <span class="fu">&gt;&gt;</span> stop</code></pre></div>
<p>Here <code>unexpected</code> is a way of throwing an error in a parser.<br />
Since we're sequencing via <code>&gt;&gt;</code>, we are throwing out the result from <code>one</code>,<br />
yet any <em>effect</em> upon the monadic context remains.<br />
In other words,<br />
the result value of the parse function is thrown away,<br />
but the effect of &quot;moving the cursor&quot;, or &quot;failure&quot; remains.</p>
<p>So this is a bit like... State. Plus failure. As it turns out...</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>)</code></pre></div>
<p>The idea is:</p>
<ol>
<li>Await a string value</li>
<li>Produce result which may fail</li>
<li>Return a tuple of the desired value and whatever's left of the string</li>
</ol>
<p>Check out some <a href="./LearningParsers.hs">demonstrations</a>.</p>
<h4 id="exercises-parsing-practice">Exercises Parsing Practice</h4>
<ol>
<li>Use <code>eof</code> from Text.Parser.Combinator to make the <code>one</code> and <code>oneTwo</code> parsers fail<br />
for not exhausting the input stream.</li>
</ol>
<p>```haskell<br />
-- Exercises: Parsing Practice</p>
<p>ex1_one :: Parser ()<br />
ex1_one = one &gt;&gt; eof</p>
<p>ex1_oneTwo :: Parser ()<br />
ex1_oneTwo = oneTwo &gt;&gt; eof</p>
<p>ex1_oneTwoThree :: Parser ()<br />
ex1_oneTwoThree = oneTwo &gt;&gt; char '3' &gt;&gt; eof<br />
```</p>
<ol>
<li>Use <code>string</code> to make a Parser that parses &quot;1&quot;, &quot;12&quot;, and &quot;123&quot; out of the example input.<br />
Try combining it with <code>stop</code> too.<br />
That is, a single parser should be able to parse all three of those strings.</li>
</ol>
<p><code>haskell   ex2 :: Parser [String]   -- these all look for &quot;112123&quot;   -- ex2 = traverse string [&quot;1&quot;, &quot;12&quot;, &quot;123&quot;]   -- ex2 = traverse (try . string) [&quot;1&quot;, &quot;12&quot;, &quot;123&quot;]   -- ex2 = sequenceA $ string &lt;$&gt; [&quot;1&quot;, &quot;12&quot;, &quot;123&quot;]   -- goddamn finally   -- ex2 = do   --   r1 &lt;- lookAhead $ string &quot;1&quot;   --   r2 &lt;- lookAhead $ string &quot;12&quot;   --   r3 &lt;- lookAhead $ string &quot;123&quot;   --   return [r1, r2, r3]   --  cleanup   ex2 = traverse (lookAhead . string) [&quot;1&quot;, &quot;12&quot;, &quot;123&quot;]</code></p>
<ol>
<li>Try writing a Parser that does what <code>string</code> does, but using <code>char</code>.</li>
</ol>
<p><code>haskell   ex3 :: CharParsing m =&gt; String -&gt; m String   ex3 = traverse char</code></p>
<h3 id="parsing-fractions">24.4 Parsing fractions</h3>
<p>Look how simple it is to create a fraction parser!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">module</span> <span class="dt">Text.Fractions</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Data.Ratio</span> ((%))
<span class="kw">import </span><span class="dt">Text.Trifecta</span>

<span class="ot">parseFraction ::</span> <span class="dt">Parser</span> <span class="dt">Rational</span>
parseFraction <span class="fu">=</span> <span class="kw">do</span>
  numerator <span class="ot">&lt;-</span> decimal
  char <span class="ch">&#39;/&#39;</span>
  denominator <span class="ot">&lt;-</span> decimal
  return (numerator <span class="fu">%</span> denominator)

<span class="ot">virtuousFraction ::</span> <span class="dt">Parser</span> <span class="dt">Rational</span>
virtuousFraction <span class="fu">=</span> <span class="kw">do</span>
  numerator <span class="ot">&lt;-</span> decimal
  char <span class="ch">&#39;/&#39;</span>
  denominator <span class="ot">&lt;-</span> decimal
  <span class="kw">case</span> denominator <span class="kw">of</span>
    <span class="dv">0</span> <span class="ot">-&gt;</span> fail <span class="st">&quot;Denominator cannot be zero&quot;</span>
    _ <span class="ot">-&gt;</span> return (numerator <span class="fu">%</span> denominator)</code></pre></div>
<p>The <code>virtuousFraction</code> handles a 0 denominator error by using the monad <code>fail</code> function,<br />
which is how we indicate parsing errors in trifecta parsing,<br />
and allows us to handle our errors in the type system.<br />
The initial <code>parseFraction</code> would crash when parsing &quot;1/0&quot; which is amateur hour esque.</p>
<h4 id="exercise-unit-of-success">Exercise: Unit of Success</h4>
<p>Modify the parser <code>integer &gt;&gt; eof</code> to parse the same content (i.e., parse string that ends in integer) but returns the integer instead of <code>()</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- original</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> parseString (integer <span class="fu">&gt;&gt;</span> eof) mempty <span class="st">&quot;123abc&quot;</span>
<span class="dt">Failure</span> (interactive)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">4</span><span class="fu">:</span> error<span class="fu">:</span> expected<span class="fu">:</span> digit,
end <span class="kw">of</span> input
123abc<span class="fu">&lt;</span><span class="dt">EOF</span><span class="fu">&gt;</span>
<span class="fu">^</span>

<span class="dt">Prelude</span><span class="fu">&gt;</span> parseString (integer <span class="fu">&gt;&gt;</span> eof) mempty <span class="st">&quot;123&quot;</span>
<span class="dt">Success</span> ()

<span class="co">-- solution</span>
<span class="ot">inteof ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span>
inteof <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> integer
  eof
  return x

<span class="co">-- or more succinctly (discovered in next section)</span>
inteof <span class="fu">=</span> integer <span class="fu">&lt;*</span> eof</code></pre></div>
<h3 id="haskells-parsing-ecosystem">24.5 Haskell's parsing ecosystem</h3>
<p>Haskell has several other excellent parsing libraries:</p>
<ul>
<li>parsec - popular</li>
<li>attoparsec - popular</li>
<li>megaparsec</li>
<li>aeson - for json</li>
<li>cassava - for csv</li>
</ul>
<p>We're using trifecta in this chapter because it has great error messages.<br />
If doing parsing in production, where speed is paramount, <code>attoparsec</code> is a good option.</p>
<h4 id="typeclasses-of-parsers">Typeclasses of Parsers</h4>
<p>The <code>Parsing</code> typeclass has <code>Alternative</code> as a superclass and is provided for functionality needed to describe parsers independent of input type.<br />
Minimally, we must define <code>try</code>, <code>(&lt;?&gt;)</code>, and <code>notFollowedBy</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Text.Parser.Combinators</span>
<span class="kw">class</span> <span class="dt">Alternative</span> m <span class="ot">=&gt;</span> <span class="dt">Parsing</span> m <span class="kw">where</span>
  <span class="ot">{-# MINIMAL try, (&lt;?&gt;), notFollowedBy #-}</span>
<span class="ot">  try ::</span> m a <span class="ot">-&gt;</span> m a
<span class="ot">  (&lt;?&gt;) ::</span> m a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a
<span class="ot">  notFollowedBy ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m ()
<span class="ot">  skipMany ::</span> m a <span class="ot">-&gt;</span> m ()
<span class="ot">  skipSome ::</span> m a <span class="ot">-&gt;</span> m ()
<span class="ot">  unexpected ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a
<span class="ot">  eof ::</span> m ()</code></pre></div>
<ol>
<li><code>try</code>: takes a parser that may consume input, and on failure goes back to where it started, and fails if we didn't consume input.</li>
<li><code>notFollowedBy</code>: does not consume input, but allows us to specify that a successful match is one <em>not followed by</em> other input.</li>
</ol>
<p><code>haskell   λ&gt; print $ parseString (integer &lt;* notFollowedBy  eof) mempty &quot;123abc&quot;   Success 123   λ&gt; print $ parseString (integer &lt;* notFollowedBy  eof) mempty &quot;123&quot;   Failure (..)</code></p>
<ol>
<li><code>unexpected</code>: signals error</li>
<li><code>eof</code>: only succeeds at end of input</li>
</ol>
<p>The library also defines <code>CharParsing</code>, which has <code>Parsing</code> as a superclass, and exists to parse individual characters.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Text.Parser.Char</span>
<span class="kw">class</span> <span class="dt">Parsing</span> m <span class="ot">=&gt;</span> <span class="dt">CharParsing</span> (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">  char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> m <span class="dt">Char</span>
<span class="ot">  notChar ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> m <span class="dt">Char</span>
<span class="ot">  anyChar ::</span> m <span class="dt">Char</span>
<span class="ot">  string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m <span class="dt">String</span>
<span class="ot">  text ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m <span class="dt">Text</span>
<span class="ot">  satisfy ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> m <span class="dt">Char</span></code></pre></div>
<ol>
<li><code>char</code>: parses and returns a single character equal to the one provided</li>
<li><code>notChar</code>: parses and returns any single character not equal to the one provided</li>
<li><code>anyChar</code>: succeeds for any character, returns the character parsed</li>
<li><code>string</code>: parses a sequence of characters, returns the string parsed</li>
<li><code>text</code>: parses sequence of characters represented by Text value, returns parsed Text fragment</li>
</ol>
<p>A reminder: this barely scratches the surface of these libraries.<br />
Some documentation spelunking is in order.</p>
<h3 id="alternative">24.6 Alternative</h3>
<p>Alternative is pretty much exactly what it sounds like.<br />
Here's the definition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> f <span class="kw">where</span>
  <span class="co">-- | The identity of &#39;&lt;|&gt;&#39;</span>
<span class="ot">  empty ::</span> f a

  <span class="co">-- | An associative binary operation</span>
<span class="ot">  (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a

  <span class="co">-- | One or more.</span>
<span class="ot">  some ::</span> f a <span class="ot">-&gt;</span> f [a]
  some v <span class="fu">=</span> some_v
    <span class="kw">where</span>
      many_v <span class="fu">=</span> some_v <span class="fu">&lt;|&gt;</span> pure []
      some_v <span class="fu">=</span> (fmap (<span class="fu">:</span>) v) <span class="fu">&lt;*&gt;</span> many_v

  <span class="co">-- | Zero or more.</span>
<span class="ot">  many ::</span> f a <span class="ot">-&gt;</span> f [a]
  many v <span class="fu">=</span> many_v
    <span class="kw">where</span>
      many_v <span class="fu">=</span> some_v <span class="fu">&lt;|&gt;</span> pure []
      some_v <span class="fu">=</span> (fmap (<span class="fu">:</span>) v) <span class="fu">&lt;*&gt;</span> many_v</code></pre></div>
<p>Let's check out a demo (source <a href="./AltParsing.hs">AltParsing.hs</a>):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseNos ::</span> <span class="dt">Parser</span> <span class="dt">NumberOrString</span>
parseNos <span class="fu">=</span>
      (<span class="dt">Left</span> <span class="fu">&lt;$&gt;</span> integer)
  <span class="fu">&lt;|&gt;</span> (<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> some letter)</code></pre></div>
<p>So <code>&lt;|&gt;</code> is acting as a disjunction of the two parsers.<br />
The Alternative typeclass also includes <code>many</code> and <code>some</code>,<br />
which essentially mean &quot;zero or more&quot; and &quot;one or more&quot; respectively.</p>
<p><a href="http://stackoverflow.com/questions/7671009/functions-from-alternative-type-class/7681283#7681283">This</a> is a great explanation of this typeclass.<br />
The <code>some</code> and <code>many</code> functions are not useful (and indeed barely make sense) in common types<br />
such as <code>[]</code> and <code>Maybe</code>.<br />
We need a type that has a sensible notion of <em>failure</em> context and a <em>retry</em>'s,<br />
which is why it makes so much sense when parsing (keep trying as we traverse the input).</p>
<h4 id="quasiquotes">QuasiQuotes</h4>
<p>We can use the <code>QuasiQuotes</code> language pragma to write multiline strings without newline separators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="kw">import </span><span class="dt">Text.RawString.QQ</span>

<span class="ot">eitherOr ::</span> <span class="dt">String</span>
eitherOr <span class="fu">=</span> [r|
123
abc
456
def
|]</code></pre></div>
<p>The <code>[r|</code> is beginning a quasiquoted section, using quasiquoter named <code>r :: QuasiQuoter</code>,<br />
defined in Text.RawString.QQ.</p>
<h4 id="exercise-try-try">Exercise: Try Try</h4>
<p>Fairly bombproof solution:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Taken from TextFraction.hs</span>
<span class="ot">parseFraction ::</span> <span class="dt">Parser</span> <span class="dt">Rational</span>
parseFraction <span class="fu">=</span> <span class="kw">do</span>
  numerator <span class="ot">&lt;-</span> decimal
  char <span class="ch">&#39;/&#39;</span>
  denominator <span class="ot">&lt;-</span> decimal
  eof
  <span class="kw">case</span> denominator <span class="kw">of</span>
    <span class="dv">0</span> <span class="ot">-&gt;</span> fail <span class="st">&quot;Denominator cannot be zero&quot;</span>
    _ <span class="ot">-&gt;</span> return (numerator <span class="fu">%</span> denominator)

<span class="co">-- Allows for .X or X. by assuming 0.X and X.0 respectively.</span>
<span class="ot">parseDecimal ::</span> <span class="dt">Parser</span> <span class="dt">Rational</span>
parseDecimal <span class="fu">=</span> <span class="kw">do</span>
  wholeNum   <span class="ot">&lt;-</span> fromIntegral <span class="fu">&lt;$$&gt;</span> optional decimal
  decimalNum <span class="ot">&lt;-</span> fromIntegral <span class="fu">&lt;$$&gt;</span> optional (char <span class="ch">&#39;.&#39;</span> <span class="fu">&gt;&gt;</span> decimal)
  eof
  <span class="kw">if</span> and <span class="fu">$</span> isNothing <span class="fu">&lt;$&gt;</span> [wholeNum, decimalNum]
     <span class="kw">then</span> unexpected <span class="st">&quot;decimal not found&quot;</span>
     <span class="kw">else</span> return <span class="fu">$</span> (fromMaybe <span class="dv">0</span> wholeNum) <span class="fu">+</span> (maybe <span class="dv">0</span> mkDec decimalNum)
       <span class="kw">where</span>
         mkDec x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">&lt;</span> <span class="dv">1</span> <span class="kw">then</span> x <span class="kw">else</span> mkDec (x <span class="fu">/</span> <span class="dv">10</span>)
         (<span class="fu">&lt;$$&gt;</span>)  <span class="fu">=</span> fmap <span class="fu">.</span> fmap

<span class="co">-- Note that parseFraction &lt;|&gt; parseDecimal alone will cause errors because</span>
<span class="co">-- parseFraction will start to consume &quot;1.234&quot; and then error on unexpected &#39;.&#39;</span>
<span class="ot">parseRational ::</span> <span class="dt">Parser</span> <span class="dt">Rational</span>
parseRational <span class="fu">=</span> try parseFraction <span class="fu">&lt;|&gt;</span> parseDecimal</code></pre></div>
<p>Some fixtures/examples are located in <a href="./TryTry.hs">TryTry.hs</a>.</p>
<h3 id="parsing-configuration-files">24.7 Parsing configuration files</h3>
<p>What a coinkydink. I was planning to do this for <a href="https://github.com/SamTay/conman">conman</a>.<br />
Great practical example in any case. A complete single-file program <a href="./DataIni.hs">Data.Ini</a>.</p>
<h3 id="character-and-token-parsers">24.8 Character and token parsers</h3>
<p>Traditionally, parsing has been done in two stages, <em>lexing</em> and <em>parsing</em>.<br />
Characters from a stream feed into the lexer, which emits <em>tokens</em> to the parser.<br />
The parser then structures the stream of <em>tokens</em> into an <strong>abstract syntax tree</strong> (AST).</p>
<p>Lexers are simpler and typically don't look ahead into the input stream by more than one character/token at a time.<br />
Sometimes they are also called tokenizers.<br />
Lexers are also sometimes done with regexes,<br />
but typically parsing libraries in Haskell intend for lexing and parsing to be done with the same API.</p>
<p>Instead of handling all kinds of whitespace manually, we can leverage existing tokenizers.<br />
Notice the difference between CharParsing and TokenParsing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">digit ::</span> <span class="dt">CharParsing</span> m <span class="ot">=&gt;</span> m <span class="dt">Char</span>
λ<span class="fu">&gt;</span> parseString (some digit) mempty <span class="st">&quot;123 456&quot;</span>
<span class="dt">Success</span> <span class="st">&quot;123&quot;</span>
λ<span class="fu">&gt;</span> parseString (some (some digit)) mempty <span class="st">&quot;123 456&quot;</span>
<span class="dt">Success</span> [<span class="st">&quot;123&quot;</span>]

<span class="ot">integer ::</span> <span class="dt">TokenParsing</span> m <span class="ot">=&gt;</span> m <span class="dt">Integer</span>
λ<span class="fu">&gt;</span> parseString (some integer) mempty <span class="st">&quot;123 456&quot;</span>
<span class="dt">Success</span> [<span class="dv">123</span>,<span class="dv">456</span>]
λ<span class="fu">&gt;</span> parseString (some integer) mempty <span class="st">&quot;123 \n\n \n \n 456&quot;</span>
<span class="dt">Success</span> [<span class="dv">123</span>,<span class="dv">456</span>]</code></pre></div>
<p>We can turn <code>digit</code> into a token parser via <code>token :: TokenParsing m =&gt; m a -&gt; m a</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>t integer
<span class="ot">integer ::</span> <span class="dt">TokenParsing</span> m <span class="ot">=&gt;</span> m <span class="dt">Integer</span>
<span class="ot">        ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span> <span class="co">-- specialized</span>

λ<span class="fu">&gt;</span> <span class="fu">:</span>t read <span class="fu">&lt;$&gt;</span> (token <span class="fu">.</span> some)<span class="ot"> digit ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span>
read <span class="fu">&lt;$&gt;</span> (token <span class="fu">.</span> some)<span class="ot"> digit ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span></code></pre></div>
<h4 id="tokenizing-scope-examples">Tokenizing scope examples</h4>
<p>Here, <code>tknWhole</code> consumes as a single <em>token</em> the sequence <code>&quot;ab&quot;</code>.<br />
So it fails if it finds <code>'a'</code> followed by whitespace, but is fine if <code>&quot;ab&quot;</code> is followed by whitespace:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> tknWhole <span class="fu">=</span> token <span class="fu">$</span> char <span class="ch">&#39;a&#39;</span> <span class="fu">&gt;&gt;</span> char <span class="ch">&#39;b&#39;</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> parseString tknWhole mempty <span class="st">&quot;a b&quot;</span>
<span class="dt">Failure</span> (interactive)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span> error<span class="fu">:</span> expected<span class="fu">:</span> <span class="st">&quot;b&quot;</span>
a b<span class="fu">&lt;</span><span class="dt">EOF</span><span class="fu">&gt;</span>
<span class="fu">^</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> parseString tknWhole mempty <span class="st">&quot;ab ab&quot;</span>
<span class="dt">Success</span> <span class="ch">&#39;b&#39;</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> parseString (some tknWhole) mempty <span class="st">&quot;ab ab&quot;</span>
<span class="dt">Success</span> <span class="st">&quot;bb&quot;</span></code></pre></div>
<p>On the other hand, to make the parse successful for <code>&quot;a b&quot;</code>, we can tokenize the parsing of <code>'a'</code> and then parse <code>'b'</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> tknCharA <span class="fu">=</span> (token (char <span class="ch">&#39;a&#39;</span>)) <span class="fu">&gt;&gt;</span> char <span class="ch">&#39;b&#39;</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> parseString tknCharA mempty <span class="st">&quot;a b&quot;</span>
<span class="dt">Success</span> <span class="ch">&#39;b&#39;</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> parseString (some tknCharA) mempty <span class="st">&quot;a ba b&quot;</span>
<span class="dt">Success</span> <span class="st">&quot;bb&quot;</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> parseString (some tknCharA) mempty <span class="st">&quot;a b a b&quot;</span>
<span class="dt">Success</span> <span class="st">&quot;b&quot;</span></code></pre></div>
<p>The last example only parses the first pair because tokenization handles <strong>trailing</strong> whitespace, not leading whitespace.<br />
Therefore the second space character causes the rest of the parse to fail.<br />
This is readily verified by running:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> parseString (some tknCharA) mempty <span class="st">&quot; a b&quot;</span>
<span class="dt">Failure</span> (<span class="dt">ErrInfo</span> {_errDoc <span class="fu">=</span> (interactive)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span> expected<span class="fu">:</span> <span class="st">&quot;a&quot;</span>
 a b<span class="fu">&lt;</span><span class="dt">EOF</span><span class="fu">&gt;</span>
<span class="fu">^</span>         , _errDeltas <span class="fu">=</span> [<span class="dt">Columns</span> <span class="dv">0</span> <span class="dv">0</span>]})</code></pre></div>
<p>In general, Chris advises not to go crazy with tokenization.<br />
Overuse or messy mixture with character parsers can slow down parsers and make them less readable.<br />
Tokenization is <em>not</em> just about whitespace, but about generally igorning noise.</p>
<h3 id="polymorphic-parsers">24.9 Polymorphic parsers</h3>
<p>To avoid confusing error messages when backtracing (that is, when using <code>try</code>),<br />
we can as a rule of thumb combine this with the <code>&lt;?&gt;</code> operator to annotate parsing rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tryAnnot ::</span> (<span class="dt">Monad</span> f, <span class="dt">CharParsing</span> f) <span class="ot">=&gt;</span> f <span class="dt">Char</span>
tryAnnot <span class="fu">=</span>
      (try (char <span class="ch">&#39;1&#39;</span> <span class="fu">&gt;&gt;</span> char <span class="ch">&#39;2&#39;</span>)
      <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Tried 12 for the initial part&quot;</span>)
  <span class="fu">&lt;|&gt;</span> (char <span class="ch">&#39;3&#39;</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Tried 3 as a fallback&quot;</span>)</code></pre></div>
<h3 id="marshalling-from-an-ast-to-a-datatype">24.10 Marshalling from an AST to a datatype</h3>
<p>Typically a program has input / output in some form of &quot;text&quot;.<br />
For this text to make sense and be useful for our program, we need a two-stage transformation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">input ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Structure</span> <span class="ot">-&gt;</span> <span class="dt">Meaning</span>
input <span class="fu">=</span> unmarshall <span class="fu">.</span> parse

<span class="ot">output ::</span> <span class="dt">Meaning</span> <span class="ot">-&gt;</span> <span class="dt">Structure</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>
output <span class="fu">=</span> serialize <span class="fu">.</span> marshall</code></pre></div>
<h4 id="marshalling-and-unmarshalling-json-data">Marshalling and unmarshalling JSON data</h4>
<p><code>aeson</code> is the canonical JSON library in Haskell.<br />
I already have experience using this in my own small projects, so my notes here will be brief.</p>
<p>Types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sectionJson ::</span> <span class="dt">ByteString</span>
sectionJson <span class="fu">=</span> [r|
{ &quot;section&quot;: {&quot;host&quot;: &quot;wikipedia.org&quot;},
  &quot;whatisit&quot;: {&quot;red&quot;: &quot;intoothandclaw&quot;}
}
|]

<span class="kw">data</span> <span class="dt">TestData</span> <span class="fu">=</span>
  <span class="dt">TestData</span> {
<span class="ot">    section ::</span> <span class="dt">Host</span>
  ,<span class="ot"> what ::</span> <span class="dt">Color</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">newtype</span> <span class="dt">Host</span> <span class="fu">=</span>
  <span class="dt">Host</span> <span class="dt">String</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">type</span> <span class="dt">Annotation</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span>
    <span class="dt">Red</span> <span class="dt">Annotation</span>
  <span class="fu">|</span> <span class="dt">Blue</span> <span class="dt">Annotation</span>
  <span class="fu">|</span> <span class="dt">Yellow</span> <span class="dt">Annotation</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Aeson marshalling instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">TestData</span> <span class="kw">where</span>
  parseJSON (<span class="dt">Object</span> v) <span class="fu">=</span>
    <span class="dt">TestData</span> <span class="fu">&lt;$&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;section&quot;</span>
             <span class="fu">&lt;*&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;whatisit&quot;</span>
  parseJSON _ <span class="fu">=</span>
    fail <span class="st">&quot;Expected an object for TestData&quot;</span>

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Host</span> <span class="kw">where</span>
  parseJSON (<span class="dt">Object</span> v) <span class="fu">=</span>
    <span class="dt">Host</span> <span class="fu">&lt;$&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;host&quot;</span>
  parseJSON _ <span class="fu">=</span>
    fail <span class="st">&quot;Expected an object for Host&quot;</span>

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Color</span> <span class="kw">where</span>
  parseJSON (<span class="dt">Object</span> v) <span class="fu">=</span>
        (<span class="dt">Red</span> <span class="fu">&lt;$&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;red&quot;</span>)
    <span class="fu">&lt;|&gt;</span> (<span class="dt">Blue</span> <span class="fu">&lt;$&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;blue&quot;</span>)
    <span class="fu">&lt;|&gt;</span> (<span class="dt">Yellow</span> <span class="fu">&lt;$&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;yellow&quot;</span>)
  parseJSON _ <span class="fu">=</span> fail <span class="st">&quot;Expected an object for Color&quot;</span></code></pre></div>
<p>As of now, aeson defines its JSON AST as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | A JSON value represented as a Haskell value.</span>
<span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">Object</span> <span class="fu">!</span><span class="dt">Object</span>
           <span class="fu">|</span> <span class="dt">Array</span> <span class="fu">!</span><span class="dt">Array</span>
           <span class="fu">|</span> <span class="dt">String</span> <span class="fu">!</span><span class="dt">Text</span>
           <span class="fu">|</span> <span class="dt">Number</span> <span class="fu">!</span><span class="dt">Scientific</span>
           <span class="fu">|</span> <span class="dt">Bool</span> <span class="fu">!</span><span class="dt">Bool</span>
           <span class="fu">|</span> <span class="dt">Null</span>
           <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Typeable</span>, <span class="dt">Data</span>)</code></pre></div>
<p>Here's an example of handling when a single field can be a string <em>or</em> a number:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NumberOrString</span> <span class="fu">=</span>
    <span class="dt">Numba</span> <span class="dt">Integer</span>
  <span class="fu">|</span> <span class="dt">Stringy</span> <span class="dt">Text</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">NumberOrString</span> <span class="kw">where</span>
  parseJSON (<span class="dt">Number</span> i) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Numba</span> i
  parseJSON (<span class="dt">String</span> s) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Stringy</span> s
  parseJSON _ <span class="fu">=</span>
    fail <span class="st">&quot;NumberOrString must be number or string&quot;</span></code></pre></div>
<p>Although, this doesn't work out of the box.<br />
JSON (and JavaScript - yikes) only has <em>one</em> numeric type (called IEEE-754 float), no integral types.<br />
To handle all possible JSON numbers,<br />
aeson uses the Scientific type which allows arbitrary precision.<br />
So to fully fix the above, we need to also convert Scientific to Integer:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Scientific</span> (floatingOrInteger)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">NumberOrString</span> <span class="kw">where</span>
  parseJSON (<span class="dt">Number</span> i) <span class="fu">=</span>
    <span class="kw">case</span> floatingOrInteger i <span class="kw">of</span>
      (<span class="dt">Left</span> _) <span class="ot">-&gt;</span> fail <span class="st">&quot;Must be integral number&quot;</span>
      (<span class="dt">Right</span> integer) <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">Numba</span> integer
  parseJSON (<span class="dt">String</span> s) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Stringy</span> s
  parseJSON _ <span class="fu">=</span>
    fail <span class="st">&quot;NumberOrString must be number or string&quot;</span></code></pre></div>
<h3 id="chapter-exercises-10">24.11 Chapter Exercises</h3>
<ol>
<li><a href="./SemVer.hs">Parse SemVer versions</a></li>
<li>Write a <a href="./Integer.hs">parser for positive integer values</a></li>
<li>Extend posint <a href="./Integer.hs">parser to negatives</a> as well.</li>
<li>Parser for US/Canada <a href="./Phone.hs">phone numbers</a>.</li>
<li>Write a <a href="./logfile/src/Data/Log.hs">parser for log file format</a>.</li>
<li>Write a <a href="./IPv4.hs">parser for IPv4 addresses</a>.</li>
<li>(Skipping IPv6 addresses for now)</li>
<li><p>Write a <a href="./Dot.hs">parser</a> for the <a href="http://www.graphviz.org/doc/info/lang.html">DOT language</a> that Graphviz uses to express graphs in plain-text - WIP.</p>
<h1 id="composing-types">Composing types</h1></li>
</ol>
<p>This and the next chapter are all about <em>monad transformers</em>:<br />
the principles behind them and the practicalities of using them.<br />
These can make or break a great Haskeller - so I'll be thorough in notes &amp; exercises.</p>
<p>Functors and applicatives are <strong>closed under composition</strong>,<br />
however this is not the case for monads.</p>
<p>In real world Haskell, composing monads can be really convenient -<br />
it allows us to build up computations with multiple effects.<br />
For example, stacking IO with Monad allows us to perform IO actions while building up computations with possible failure.</p>
<p>A <strong>monad transformer</strong> is a variant of an ordinary type<br />
that takes an additional monad type argument.<br />
For example, MaybeT is the transformer variant of Maybe.</p>
<h3 id="common-functions-as-types">25.2 Common functions as types</h3>
<p>First, we're going to explore the analog between functions and types, specifically <code>id</code> and <code>.</code>.<br />
These will be used to demonstrate the non-composability of monads.<br />
Monad transformers are conventionally written as newtypes to avoid overhead.<br />
Note that monad transformers are never sum or product types;<br />
they are just a means of wrapping one extra layer of monadic structure around a type.</p>
<h4 id="identity-is-boring">Identity is boring</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span>
  <span class="dt">Identity</span> {<span class="ot"> runIdentity ::</span> a }</code></pre></div>
<p>Note the similarity between <code>id :: a -&gt; a</code> and <code>Identity :: * -&gt; *</code>.</p>
<h4 id="compose">Compose</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Compose</span> f g a <span class="fu">=</span>
  <span class="dt">Compose</span> {<span class="ot"> getCompose ::</span> f (g a) }
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Note the similarity between <code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code><br />
and <code>Compose :: (* -&gt; *) -&gt; (* -&gt; *) -&gt; * -&gt; *</code>.<br />
Here's an example of how the type signature plays out in practice:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">value ::</span> <span class="dt">Compose</span> [] <span class="dt">Maybe</span> <span class="dt">Int</span>
value <span class="fu">=</span> <span class="dt">Compose</span> [<span class="dt">Just</span> <span class="dv">1</span>, <span class="dt">Nothing</span>]</code></pre></div>
<h3 id="two-little-functors-sittin-in-a-tree-l-i-f-t-i-n-g">25.3 Two little functors sittin’ in a tree, L-I-F-T-I-N-G</h3>
<p>Consider this composition of functors:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span>
         <span class="dt">Functor</span> (<span class="dt">Compose</span> f g) <span class="kw">where</span>
  fmap f (<span class="dt">Compose</span> fga) <span class="fu">=</span>
    <span class="dt">Compose</span> <span class="fu">$</span> (fmap <span class="fu">.</span> fmap) f fga</code></pre></div>
<p>Also note that we can nest to arbitrary levels, just using <code>Compose</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v ::</span> <span class="dt">Compose</span> [] <span class="dt">Maybe</span> (<span class="dt">Compose</span> <span class="dt">Maybe</span> [] <span class="dt">Integer</span>)
v <span class="fu">=</span> <span class="dt">Compose</span> [<span class="dt">Just</span> (<span class="dt">Compose</span> <span class="fu">$</span> <span class="dt">Just</span> [<span class="dv">1</span>])]</code></pre></div>
<p>The functor instance can evidently generalize to further nested levels,<br />
implemented by further composing <code>fmap</code>.<br />
Therefore, functors are closed under composition.</p>
<h3 id="twinplicative">25.4 Twinplicative</h3>
<p>As mentioned earlier, applicatives are also closed under composition, and it is up to me to prove it!</p>
<h4 id="exercise-time">Exercise time</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span>
<span class="kw">instance</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> g) <span class="ot">=&gt;</span>
  <span class="dt">Applicative</span> (<span class="dt">Compose</span> f g) <span class="kw">where</span>

<span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Compose</span> f g a
    pure <span class="fu">=</span> <span class="dt">Compose</span> <span class="fu">.</span> pure <span class="fu">.</span> pure

<span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">Compose</span> f g (a <span class="ot">-&gt;</span> b)
          <span class="ot">-&gt;</span> <span class="dt">Compose</span> f g a
          <span class="ot">-&gt;</span> <span class="dt">Compose</span> f g b
    (<span class="dt">Compose</span> fgab) <span class="fu">&lt;*&gt;</span> (<span class="dt">Compose</span> fga) <span class="fu">=</span> <span class="dt">Compose</span> <span class="fu">$</span> liftA2 (<span class="fu">&lt;*&gt;</span>) fgab fga</code></pre></div>
<p>This is another benefit that applicative has over monad,<br />
even though applicative is the &quot;weaker&quot; of the two algebras.</p>
<h3 id="twonad">25.5 Twonad?</h3>
<p>Although we can compose two monads, such as <code>Compose $ [Just 1] :: Compose [] Maybe Int</code>,<br />
the result is <strong>not</strong> a monad.<br />
The problem arises from a lack of information.<br />
When we try to write a single <code>bind</code> out of two polymorphic <code>bind</code>s, we run into trouble:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span>

<span class="co">-- IMPOSSIBLE</span>
<span class="kw">instance</span> (<span class="dt">Monad</span> f, <span class="dt">Monad</span> g) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Compose</span> f g) <span class="kw">where</span>
  return <span class="fu">=</span> pure

<span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">Compose</span> f g a
        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Compose</span> f g b)
        <span class="ot">-&gt;</span> <span class="dt">Compose</span> f g b
  (<span class="dt">Compose</span> fga) <span class="fu">&gt;&gt;=</span> aCfgb <span class="fu">=</span> <span class="co">-- ???</span>

<span class="co">-- We have two available binds</span>
<span class="ot">b1 ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f b
<span class="ot">b2 ::</span> <span class="dt">Monad</span> g <span class="ot">=&gt;</span> g a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> g b) <span class="ot">-&gt;</span> g b

<span class="co">-- and joins</span>
<span class="ot">j1 ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f a
<span class="ot">j2 ::</span> <span class="dt">Monad</span> g <span class="ot">=&gt;</span> g (g a) <span class="ot">-&gt;</span> g a

<span class="co">-- And we need to make a bind</span>
<span class="ot">b3 ::</span> (<span class="dt">Monad</span> f, <span class="dt">Monad</span> g) <span class="ot">=&gt;</span> f (g a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f (g b)) <span class="ot">-&gt;</span> f (g b)

<span class="co">-- or a join</span>
<span class="ot">j3 ::</span> (<span class="dt">Monad</span> f, <span class="dt">Monad</span> g) <span class="ot">=&gt;</span> f (g (f (g a))) <span class="ot">-&gt;</span> f (g a)

<span class="co">-- It&#39;s easier to think about joins, since they are conceptually simpler.</span>
<span class="co">-- Following the technique for fmap and pure, we can try composition:</span>
j <span class="fu">=</span> j2 <span class="fu">.</span> j1 <span class="co">-- DOES NOT TYPE CHECK</span>
<span class="co">-- but we quickly find this doesn&#39;t work, because j1 needs a nest of the **same** monad</span></code></pre></div>
<p>So, we can't get a monad from composing two monads out of the box - we will need some additional<br />
construct linking them together.<br />
This is where <em>monad transformers</em> come into play.<br />
See <a href="http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf">Composing Monads</a> for more information.</p>
<h3 id="exercises-compose-instances">25.6 Exercises: Compose Instances</h3>
<h4 id="compose-foldable">Compose Foldable</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 1 Foldable</span>

<span class="kw">instance</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) <span class="ot">=&gt;</span>
  <span class="dt">Foldable</span> (<span class="dt">Compose</span> f g) <span class="kw">where</span>
    foldMap f (<span class="dt">Compose</span> fga) <span class="fu">=</span> (foldMap <span class="fu">.</span> foldMap) f fga</code></pre></div>
<h4 id="compose-traversable">Compose Traversable</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 2 Traversable</span>

<span class="kw">instance</span> (<span class="dt">Traversable</span> f, <span class="dt">Traversable</span> g) <span class="ot">=&gt;</span>
  <span class="dt">Traversable</span> (<span class="dt">Compose</span> f g) <span class="kw">where</span>
    traverse f (<span class="dt">Compose</span> fga) <span class="fu">=</span>
      <span class="dt">Compose</span>
        <span class="fu">&lt;$&gt;</span> (traverse <span class="fu">.</span> traverse) f fga

<span class="co">-- where</span>
<span class="co">-- traverse . traverse :: (Traversable t, Traversable s, Applicative f)</span>
<span class="co">--                     =&gt; (a -&gt; f b) -&gt; s (t a) -&gt; f (s (t b))</span></code></pre></div>
<h4 id="and-now-for-something-completely-different">And now for something completely different</h4>
<p>Implement Bifunctor instances for the given types, where</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Bifunctor</span> p <span class="kw">where</span>
  <span class="ot">{-# MINIMAL bimap | first, second #-}</span>

<span class="ot">  bimap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b d
  bimap f g <span class="fu">=</span> first f <span class="fu">.</span> second g

<span class="ot">  first ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b c
  first f <span class="fu">=</span> bimap f id

<span class="ot">  second ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c
  second <span class="fu">=</span> bimap id</code></pre></div>
<p>Solutions are <a href="./Bifunctor.hs">here</a>.</p>
<h3 id="monad-transformers">25.7 Monad transformers</h3>
<p>A monad transformer is a type constructor that takes a Monad as an argument and returns another Monad.</p>
<p>In order to compose monads,<br />
we need to reduce the polymorphism (or, generality)<br />
and get concrete information about one of the Monads we're working with.<br />
The types are the trickiest part in all of this.</p>
<h4 id="monadic-stacking">Monadic stacking</h4>
<p>Applicative allows us to apply functions of more than one argument within functorial structure:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- from functor</span>
fmap (<span class="fu">+</span><span class="dv">1</span>) (<span class="dt">Just</span> <span class="dv">1</span>)

<span class="co">-- to applicative</span>
(,,) <span class="fu">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">1</span> <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> <span class="st">&quot;lol&quot;</span> <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">2</span>]</code></pre></div>
<p>In a similar way, sometimes we want a <code>&gt;&gt;=</code> which can address more than one monad at once,<br />
such as a web app combining Reader and IO.<br />
We might want to perform effectul actions via IO and pass around a database connection<br />
via Reader, and might even want more Reader instances to hold HTTP request context, etc.<br />
So, <strong>how do we get one big bind</strong> over a type such as <code>IO (Reader String [a])</code><br />
that can leverage monadic contexts of IO, Reader, and []?</p>
<h4 id="doing-it-badly">Doing it badly</h4>
<p>The first naive solution is to make one-off types for each combination:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">MaybeIO</span> a <span class="fu">=</span>
  <span class="dt">MaybeIO</span> {<span class="ot"> runMaybeIO ::</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a) }</code></pre></div>
<p>but this is obviously not the best solution.<br />
We can instead get a monad for <em>two</em> types,<br />
as long as we know what <em>one</em> of them is.<br />
Transformers are a way of avoiding making these &quot;one-off&quot; monads for every possible combination.</p>
<h3 id="identityt">25.8 IdentityT</h3>
<p>Just as the <code>Identity</code> type has shown us the basic essence of Functor, Applicative, and Monad,<br />
<code>IdentityT</code> will give us a introduction to the fundamentals of monad transformers.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Plain old Identity. &#39;a&#39; can be something with</span>
<span class="co">-- more structure, but it&#39;s not required and</span>
<span class="co">-- Identity won&#39;t know anything about it.</span>
<span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span>
  <span class="dt">Identity</span> {<span class="ot"> runIdentity ::</span> a }
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="co">-- The identity monad transformer, serving only to</span>
<span class="co">-- to specify that additional structure should exist.</span>
<span class="kw">newtype</span> <span class="dt">IdentityT</span> f a <span class="fu">=</span>
  <span class="dt">IdentityT</span> {<span class="ot"> runIdentityT ::</span> f a }
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="co">-- Functor instances</span>
<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span>
  fmap f (<span class="dt">Identity</span> a) <span class="fu">=</span> <span class="dt">Identity</span> (f a)

<span class="kw">instance</span> (<span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">IdentityT</span> m) <span class="kw">where</span>
  fmap f (<span class="dt">IdentityT</span> fa) <span class="fu">=</span> <span class="dt">IdentityT</span> (fmap f fa)

<span class="co">-- Applicative instances</span>
<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Identity</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Identity</span>
  (<span class="dt">Identity</span> f) <span class="fu">&lt;*&gt;</span> (<span class="dt">Identity</span> a) <span class="fu">=</span> <span class="dt">Identity</span> (f a)

<span class="kw">instance</span> (<span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">IdentityT</span> m) <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">IdentityT</span> (pure x)
  (<span class="dt">IdentityT</span> fab) <span class="fu">&lt;*&gt;</span> (<span class="dt">IdentityT</span> fa) <span class="fu">=</span>
    <span class="dt">IdentityT</span> (fab <span class="fu">&lt;*&gt;</span> fa)

<span class="co">-- Finally, Monad instances</span>
<span class="co">-- Remember, functor &amp; applicative can be composed generally, for all instances</span>
<span class="co">-- Monad is where our instances will need particulars to make the types fit</span>
<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Identity</span> <span class="kw">where</span>
  return <span class="fu">=</span> pure
  (<span class="dt">Identity</span> a) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f a

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">IdentityT</span> m) <span class="kw">where</span>
  return <span class="fu">=</span> pure
  (<span class="dt">IdentityT</span> ma) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span>
    <span class="dt">IdentityT</span> <span class="fu">$</span> ma <span class="fu">&gt;&gt;=</span> runIdentityT <span class="fu">.</span> f
<span class="co">--  IdentityT $ join (runIdentityT . f &lt;$&gt; ma)</span>
<span class="co">--  IdentityT $ join (runIdentityT &lt;$&gt; (f &lt;$&gt; ma))</span></code></pre></div>
<p>This shows a <strong>great insight</strong>:<br />
look at the <em>one</em> spot where we needed particular IdentityT info:<br />
<code>ma &gt;&gt;= runIdentityT . f</code>.<br />
To use the abstract monad <code>m</code>'s bind, of type <code>m a -&gt; (a -&gt; m b) -&gt; m b</code>,<br />
we need to make a function with type<br />
<code>runIdentityT . f :: a -&gt; m a</code><br />
as opposed to <code>f :: a -&gt; IdentityT m a</code> alone.<br />
<strong>If</strong> we left that <code>f</code> alone,<br />
this would end up trying to join <code>m (IdentityT m b)</code>, which doesn't work,<br />
and is the <strong>same problem</strong> we discovered above when trying to compose<br />
monads in the abstract.</p>
<h3 id="finding-a-pattern">25.9 Finding a pattern</h3>
<p>Transformers give us a <code>&gt;&gt;=</code> operation over two monad instances.<br />
As should be clear now, if we write some monad <code>m</code>,<br />
we need to create an accompanying transformer to allow it to stack with any other monads,<br />
and that transformer monad instance will handle dealing with the extra structure generated.<br />
&quot;Dealing with&quot; that extra structure is going to look like <em>folding</em>.<br />
In general, this folding will be similar but probably more complicated than the IdentityT case,<br />
which just used the record accessor <code>runIdentityT</code> to fold away the structure.</p>
<p>The <em>very</em> general (not a hard and fast rule at all) pattern of type play looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">goingFrom ::</span> m (n m b)
          <span class="ot">-&gt;</span> m (m b)
          <span class="ot">-&gt;</span> m b
          <span class="ot">-&gt;</span> n m b</code></pre></div>
<h1 id="morra">morra</h1>
<h1 id="monad-transformers-1">Monad transformers</h1>
<p>Chapter <a href="../25_Composing-Types">25</a> demonstrated the need for monad transformers<br />
and what they accomplish.<br />
This chapter is a deeper dive to get more comfortable with them in practice.</p>
<h3 id="maybet">26.2 MaybeT</h3>
<p>Just as the Maybe monad is extremely useful,<br />
its transformer variant MaybeT is an important transformer.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">MaybeT</span> m a <span class="fu">=</span>
  <span class="dt">MaybeT</span> {<span class="ot"> runMaybeT ::</span> m (<span class="dt">Maybe</span> a) }</code></pre></div>
<p>Notice the similarity in the structures of the MaybeT and Compose types;<br />
that structure leads to reusing the same pattern for functor &amp; applicative instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">MaybeT</span> m) <span class="kw">where</span>
  fmap f (<span class="dt">MaybeT</span> ma) <span class="fu">=</span>
    <span class="dt">MaybeT</span> <span class="fu">$</span> (fmap <span class="fu">.</span> fmap) f ma

<span class="kw">instance</span> (<span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">MaybeT</span> m) <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">MaybeT</span> <span class="fu">.</span> pure <span class="fu">.</span> pure
  (<span class="dt">MaybeT</span> mMab) <span class="fu">&lt;*&gt;</span> (<span class="dt">MaybeT</span> mMa) <span class="fu">=</span>
    <span class="dt">MaybeT</span> <span class="fu">$</span> liftA2 (<span class="fu">&lt;*&gt;</span>) mMab mMa
    <span class="co">-- or</span>
    <span class="dt">MaybeT</span> <span class="fu">$</span> (<span class="fu">&lt;*&gt;</span>) <span class="fu">&lt;$&gt;</span> mMab <span class="fu">&lt;*&gt;</span> mMa</code></pre></div>
<p>Again, we only need to do something different once we get to the monad instances,<br />
since functors &amp; applicatives are closed under composition in general.</p>
<h4 id="maybet-monad-instance">MaybeT Monad instance</h4>
<p>Nothing too surprising here:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">MaybeT</span> m) <span class="kw">where</span>
  return <span class="fu">=</span> pure

<span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">MaybeT</span> m a
        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">MaybeT</span> m b)
        <span class="ot">-&gt;</span> <span class="dt">MaybeT</span> m b
  (<span class="dt">MaybeT</span> mMa) <span class="fu">&gt;&gt;=</span> aMmb <span class="fu">=</span>
    <span class="dt">MaybeT</span> <span class="fu">$</span> <span class="kw">do</span>
      <span class="co">-- v :: Maybe a</span>
      v <span class="ot">&lt;-</span> mMa
      <span class="kw">case</span> v <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return <span class="dt">Nothing</span>
        <span class="dt">Just</span> y  <span class="ot">-&gt;</span> runMaybeT <span class="fu">$</span> aMmb y</code></pre></div>
<h3 id="eithert">26.3 EitherT</h3>
<p>This is the newtype for the Either transformer:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">EitherT</span> e m a <span class="fu">=</span>
  <span class="dt">EitherT</span> {<span class="ot"> runEitherT ::</span> m (<span class="dt">EitherT</span> e a) }</code></pre></div>
<h4 id="exercises-eithert">Exercises: EitherT</h4>
<ol>
<li>Write the Functor instance for EitherT.</li>
</ol>
<p><code>haskell   instance (Functor f) =&gt;     Functor (EitherT e f) where       fmap f (EitherT ma) = EitherT $ (fmap . fmap) f ma</code></p>
<ol>
<li>Write the Applicative instance for EitherT.</li>
</ol>
<p>```haskell<br />
instance (Applicative f) =&gt;<br />
Applicative (EitherT e f) where<br />
pure = EitherT . pure . pure</p>
<pre><code>  (EitherT mf) &lt;*&gt; (EitherT ma) =
    EitherT $ (&lt;*&gt;) &lt;$&gt; mf &lt;*&gt; ma</code></pre>
<p>```</p>
<ol>
<li>Write the Monad instance for EitherT.</li>
</ol>
<p>```haskell<br />
instance (Monad m) =&gt;<br />
Monad (EitherT e m) where<br />
return = pure</p>
<pre><code>  (EitherT ma) &gt;&gt;= f = EitherT $ do
    -- a :: Either e a
    a &lt;- ma
    case a of
      Left e  -&gt; return $ Left e
      Right x -&gt; runEitherT $ f x</code></pre>
<p>```</p>
<ol>
<li>Write the <code>swapEitherT</code> helper function for EitherT.</li>
</ol>
<p><code>haskell   swapEitherT :: (Functor m) =&gt; EitherT e m a -&gt; EitherT a m e   swapEitherT (EitherT ma) = EitherT $ swapEither &lt;$&gt; ma</code></p>
<ol>
<li>Write the transformer variant of the <code>either</code> catamorphism.</li>
</ol>
<p><code>haskell   eitherT :: Monad m =&gt; (a -&gt; m c) -&gt; (b -&gt; m c) -&gt; EitherT a m b -&gt; m c   eitherT f g (EitherT ma) = ma &gt;&gt;= either f g</code></p>
<h3 id="readert">26.4 ReaderT</h3>
<p>ReaderT is one of the most common transformers in conventional Haskell.<br />
It's just like Reader, but generating additional structure in the return type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a <span class="fu">=</span>
  <span class="dt">ReaderT</span> {<span class="ot"> runReaderT ::</span> r <span class="ot">-&gt;</span> m a }</code></pre></div>
<p>I decided to write the instances myself,<br />
and they look a bit different than the book's,<br />
but they type check just fine:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Functor</span> m) <span class="ot">=&gt;</span>
  <span class="dt">Functor</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span>
    fmap f (<span class="dt">ReaderT</span> rma) <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="fu">$</span> fmap f <span class="fu">.</span> rma

<span class="kw">instance</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span>
  <span class="dt">Applicative</span> (<span class="dt">ReaderT</span> e f) <span class="kw">where</span>
    pure x <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="fu">$</span> const (pure x)

<span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">ReaderT</span> r f (a <span class="ot">-&gt;</span> b)
          <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r f a
          <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r f b
    (<span class="dt">ReaderT</span> mf) <span class="fu">&lt;*&gt;</span> (<span class="dt">ReaderT</span> ma) <span class="fu">=</span>
      <span class="dt">ReaderT</span> <span class="fu">$</span> \r <span class="ot">-&gt;</span> (mf r) <span class="fu">&lt;*&gt;</span> (ma r)

<span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span>
  return <span class="fu">=</span> pure

<span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">ReaderT</span> r m a
        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m b)
        <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m b
  (<span class="dt">ReaderT</span> ma) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span>
    <span class="dt">ReaderT</span> <span class="fu">$</span> \r <span class="ot">-&gt;</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> ma r
    runReaderT (f a) r</code></pre></div>
<h3 id="statet">26.5 StateT</h3>
<p>StateT is State with additional monadic structure around the function result, just like Reader and ReaderT.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span>
  <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</code></pre></div>
<h4 id="exercises-statet">Exercises: StateT</h4>
<p>We're implementing the strict variant (as opposed to lazy), which is the &quot;obvious&quot; implementation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Functor</span> m) <span class="ot">=&gt;</span>
  <span class="dt">Functor</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
    fmap f (<span class="dt">StateT</span> smf) <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span>
      fmap (\(x, s1) <span class="ot">-&gt;</span> (f x, s1)) (smf s)

<span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span>
  <span class="dt">Applicative</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
    pure x <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> pure (x, s)

<span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">StateT</span> s m (a <span class="ot">-&gt;</span> b)
          <span class="ot">-&gt;</span> <span class="dt">StateT</span> s m a
          <span class="ot">-&gt;</span> <span class="dt">StateT</span> s m b
    (<span class="dt">StateT</span> smf) <span class="fu">&lt;*&gt;</span> (<span class="dt">StateT</span> sma) <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s1 <span class="ot">-&gt;</span> <span class="kw">do</span>
      (ab, s2) <span class="ot">&lt;-</span> smf s1
      (a, s3)  <span class="ot">&lt;-</span> sma s2
      return (ab a, s3)

<span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
  return <span class="fu">=</span> pure

<span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">StateT</span> s m a
        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">StateT</span> s m b)
        <span class="ot">-&gt;</span> <span class="dt">StateT</span> s m b
  (<span class="dt">StateT</span> sma) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s1 <span class="ot">-&gt;</span> <span class="kw">do</span>
    (a, s2) <span class="ot">&lt;-</span> sma s1
    (runStateT (f a)) s2</code></pre></div>
<p>Notice we need a monadic constraint for the applicative instance;<br />
this is needed to feed the successive states through each computation,<br />
as opposed to just feeding the initial state through each computation.</p>
<h3 id="types-you-probably-dont-want-to-use">26.6 Types you probably don't want to use</h3>
<p>Not every type will necessarily be performant or make sense, such as ListT and Writer/WriterT.</p>
<h4 id="why-not-use-writer-or-writert">Why not use Writer or WriterT?</h4>
<p>First of all, State can do what Writer can do plus more.<br />
In addition, it is commonly too lazy or too strict for a given problem,<br />
which results in too much memory usage.<br />
Writer can accumulate unevaluated thunks, causing memory leaks.<br />
For example, it is inappropriate for logging in long-running processes,<br />
since the logged values can't be retrieved until the computation is complete.</p>
<h4 id="the-listt-you-want-isnt-made-from-the-list-type">The ListT you want isn't made from the List type</h4>
<p>The obvious implementation of ListT is generally not recommended because:</p>
<ol>
<li>The obvious obvious attempt isn't associative.</li>
<li>It's not very fast.</li>
<li>Streaming libraries like <a href="http://hackage.haskell.org/package/pipes">pipes</a> and <a href="http://hackage.haskell.org/package/conduit">conduit</a> do it better for most cases.</li>
</ol>
<p>Lists in Haskell are as much a control structure as they are a data structure,<br />
so streaming libraries generally suffice when we need transformers.</p>
<h3 id="recovering-an-ordinary-type-from-a-transformer">26.7 Recovering an ordinary type from a transformer</h3>
<p>We can use the <code>Identity</code> type to recover non-transformer versions of transformer variants:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyIdentity</span> a <span class="fu">=</span> <span class="dt">IdentityT</span> <span class="dt">Identity</span> a
<span class="kw">type</span> <span class="dt">Maybe</span> a      <span class="fu">=</span> <span class="dt">MaybeT</span> <span class="dt">Identity</span> a
<span class="kw">type</span> <span class="dt">Either</span> e a   <span class="fu">=</span> <span class="dt">EitherT</span> e <span class="dt">Identity</span> a
<span class="kw">type</span> <span class="dt">Reader</span> r a   <span class="fu">=</span> <span class="dt">ReaderT</span> e <span class="dt">Identity</span> a
<span class="kw">type</span> <span class="dt">State</span> s a    <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span> a</code></pre></div>
<p>We don't ordinarily need to do this for transformers that already have corresponding non-transformer types.<br />
However, <code>ReaderT</code> is part of the Scotty environment and you can't easily retrieve the <code>Reader</code> type out of it<br />
because <code>Reader</code> is not a type that exists on its own.<br />
Thus, it may present a situation where we only need <code>Reader</code>, not <code>ReaderT</code>,<br />
and <code>ReaderT Identity</code> can act as a <code>Reader</code> compatible with Scotty.</p>
<h4 id="the-transformers-library">The transformers library</h4>
<p>In general, we don't need to make these transformer types ourselves -<br />
many of them are in base or the <code>transformers</code> library.</p>
<h4 id="a-note-on-exceptt">A note on ExceptT</h4>
<p>Note that the <code>either</code> library on Hackage provides an <code>EitherT</code> type,<br />
however most Haskellers are moving to the identical <code>ExceptT</code> type in the <code>transformers</code> library.<br />
This is mainly because <code>transformers</code> comes packaged with GHC already.</p>
<h3 id="lexically-inner-is-structurally-outer">26.8 Lexically inner is structurally outer</h3>
<p>One tricky part about monad transformers:<br />
the <strong>lexical representation</strong> of the types are <em>counterintuitive</em><br />
with respect to the <strong>structure of their values</strong>.<br />
Consider the definitions of these transfomer types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ExceptT</span> e m a <span class="fu">=</span>
  <span class="dt">ExceptT</span> {<span class="ot"> runExceptT ::</span> m (<span class="dt">Either</span> e a)) }
<span class="kw">newtype</span> <span class="dt">MaybeT</span> m a <span class="fu">=</span>
  <span class="dt">MaybeT</span> {<span class="ot"> runMaybeT ::</span> m (<span class="dt">Maybe</span> a) }
<span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a <span class="fu">=</span>
  <span class="dt">ReaderT</span> {<span class="ot"> runReaderT ::</span> r <span class="ot">-&gt;</span> m a }</code></pre></div>
<p>Note that the additional structure <code>m</code> is always wrapped <em>around</em> the value.<br />
It's only wrapped around things we can <strong>have</strong>, not things we <strong>need</strong>,<br />
as can be seen in <code>ReaderT</code>.<br />
Consequentially, a series of monad transformers will begin with the innermost type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Trans.Except</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Maybe</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Reader</span>

<span class="co">-- We only need to use return once because it&#39;s one big Monad</span>
<span class="ot">embedded ::</span> <span class="dt">MaybeT</span> (<span class="dt">ExceptT</span> <span class="dt">String</span> (<span class="dt">ReaderT</span> () <span class="dt">IO</span>)) <span class="dt">Int</span>
embedded <span class="fu">=</span> return <span class="dv">1</span>

<span class="ot">unwrap ::</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>))
unwrap <span class="fu">=</span> (runReaderT <span class="fu">.</span> runExceptT <span class="fu">.</span> runMaybeT) embedded

λ<span class="fu">&gt;</span> unwrap ()
<span class="dt">Right</span> (<span class="dt">Just</span> <span class="dv">1</span>)</code></pre></div>
<p>See how the structure of the values (<code>Right (Just x))</code>) is the reverse of the type compositions<br />
(<code>MaybeT (ExceptT x y)</code>).<br />
When we say <strong>base monad</strong> we mean the structurally outermost monad.<br />
In the example above the base monad of <code>embedded</code> is Reader,<br />
and the base monad of <code>unwrap ()</code> is Either.</p>
<h3 id="monadtrans">26.9 MonadTrans</h3>
<p>We often want to lift functions into a larger context:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span>      (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">liftA ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">liftM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span>       (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m r</code></pre></div>
<p>but sometimes we need to lift over more structure than these types permit,<br />
such as the innermost position in a stack of monad transformers.</p>
<h4 id="the-typeclass-that-lifts">The typeclass that lifts</h4>
<p>MonadTrans is a typeclass with one core method: <code>lift</code>.<br />
It is for lifting actions in some Monad over a transformer type<br />
which wraps itself in the original monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadTrans</span> t <span class="kw">where</span>
<span class="ot">  lift ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</code></pre></div>
<p>Let's motivate this with a simple example:</p>
<h4 id="motivating-monadtrans">Motivating MonadTrans</h4>
<p>Scotty has monad transformers that are themselves newtypes for monad transformer stacks:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ScottyT</span> e m a <span class="fu">=</span>
  <span class="dt">ScottyT</span> {<span class="ot"> runS ::</span> <span class="dt">State</span> (<span class="dt">ScottyState</span> e m) a }
  <span class="kw">deriving</span> ( <span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span> )
<span class="kw">newtype</span> <span class="dt">ActionT</span> e m a <span class="fu">=</span>
  <span class="dt">ActionT</span> {<span class="ot"> runAM ::</span> <span class="dt">ExceptT</span> (<span class="dt">ActionError</span> e)
                             (<span class="dt">ReaderT</span> <span class="dt">ActionEnv</span>
                             (<span class="dt">StateT</span> <span class="dt">ScottyResponse</span> m)) a }
  <span class="kw">deriving</span> ( <span class="dt">Functor</span>, <span class="dt">Applicative</span> )
<span class="kw">type</span> <span class="dt">ScottyM</span> <span class="fu">=</span> <span class="dt">ScottyT</span> <span class="dt">Text</span> <span class="dt">IO</span>
<span class="kw">type</span> <span class="dt">ActionM</span> <span class="fu">=</span> <span class="dt">ActionT</span> <span class="dt">Text</span> <span class="dt">IO</span></code></pre></div>
<p>And this is a hello world example <strong>with a type error</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> scotty <span class="dv">3000</span> <span class="fu">$</span> <span class="kw">do</span>
  get <span class="st">&quot;/:word&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    beam <span class="ot">&lt;-</span> param <span class="st">&quot;word&quot;</span>
    <span class="co">-- we cant use IO willy nilly here</span>
    putStrLn <span class="st">&quot;hello&quot;</span>
    html <span class="fu">$</span> mconcat [<span class="st">&quot;&lt;h1&gt;Scotty, &quot;</span>, beam, <span class="st">&quot; me up!&lt;/h1&gt;&quot;</span>]</code></pre></div>
<p>We can't use <code>putStrLn :: IO ()</code> because the <code>do</code> block has type <code>ActionM ()</code>.<br />
Instead, we can lift:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Trans.Class</span>
lift <span class="fu">$</span> putStrLn <span class="st">&quot;hello&quot;</span></code></pre></div>
<p>Note that <code>lift</code> is leveraging the <code>MonadTrans</code> instance of <code>ActionT e</code>,<br />
hence <code>lift :: (MonadTrans t) =&gt; IO a -&gt; t IO a</code> specializes to<br />
<code>lift :: IO a -&gt; ActionM a</code>.<br />
Running <code>main</code> in GHCi and navigating to <code>http://localhost:3000/beam</code><br />
results in both &quot;Scotty, beam me up!&quot; in the browser and &quot;hello&quot; in the terminal.</p>
<p>Since <code>ActionT</code> is itself defined in terms of three more monad transformers,<br />
it can simply wrap around composed <code>lift</code>s:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">ActionT</span> e) <span class="kw">where</span>
  lift <span class="fu">=</span> <span class="dt">ActionT</span> <span class="fu">.</span> lift <span class="fu">.</span> lift <span class="fu">.</span> lift</code></pre></div>
<p>Now, if we take all of the individual implementations of those <code>lift</code> functions,<br />
we can see the benefit of this typeclass and how much terseness we gain:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> scotty <span class="dv">3000</span> <span class="fu">$</span> <span class="kw">do</span>
  get <span class="st">&quot;/:word&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    beam <span class="ot">&lt;-</span> param <span class="st">&quot;word&quot;</span>
      (<span class="dt">ActionT</span>
      <span class="fu">.</span> (<span class="dt">ExceptT</span> <span class="fu">.</span> fmap <span class="dt">Right</span>)
      <span class="fu">.</span> <span class="dt">ReaderT</span> <span class="fu">.</span> const
      <span class="fu">.</span> \m <span class="ot">-&gt;</span> <span class="dt">StateT</span> (\s <span class="ot">-&gt;</span> <span class="kw">do</span>
                         a <span class="ot">&lt;-</span> m
                         return (a, s))
      ) (putStrLn <span class="st">&quot;hello&quot;</span>)
    html <span class="fu">$</span> mconcat [<span class="st">&quot;&lt;h1&gt;Scotty, &quot;</span>, beam, <span class="st">&quot; me up!&lt;/h1&gt;&quot;</span>]</code></pre></div>
<p>To summarize, lifting is embedding an expression within a larger context<br />
by adding structure that doesn't do anything.</p>
<h4 id="monadtrans-instances">MonadTrans instances</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- IdentityT</span>
<span class="kw">instance</span> <span class="dt">MonadTrans</span> <span class="dt">IdentityT</span> <span class="kw">where</span>
  lift <span class="fu">=</span> <span class="dt">IdentityT</span>

<span class="co">-- MaybeT</span>
<span class="kw">instance</span> <span class="dt">MonadTrans</span> <span class="dt">MaybeT</span> <span class="kw">where</span>
  lift <span class="fu">=</span> <span class="dt">MaybeT</span> <span class="fu">.</span> liftM <span class="dt">Just</span>

<span class="co">-- ReaderT</span>
<span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">ReaderT</span> r) <span class="kw">where</span>
  lift <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="fu">.</span> const

<span class="co">-- 1. EitherT</span>
<span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">EitherT</span> e) <span class="kw">where</span>
  lift <span class="fu">=</span> <span class="dt">EitherT</span> <span class="fu">.</span> liftM <span class="dt">Right</span>

<span class="co">-- 2. StateT</span>
<span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">StateT</span> s) <span class="kw">where</span>
  lift ma <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> ma
    return (a, s)</code></pre></div>
<h4 id="prolific-lifting-is-the-failure-mode">Prolific lifting is the failure mode</h4>
<p>Sometimes with conrete, explicitly typed monad transformers you see this hell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">addSubWidget sub w <span class="fu">=</span>
  <span class="kw">do</span> master <span class="ot">&lt;-</span> liftHandler getYesod
    <span class="kw">let</span> sr <span class="fu">=</span> fromSubRoute sub master
    i <span class="ot">&lt;-</span> <span class="dt">GWidget</span> <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> lift
                 <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> lift get
    w&#39; <span class="ot">&lt;-</span> liftHandler
          <span class="fu">$</span> toMasterHandlerMaybe sr (const sub) <span class="dt">Nothing</span>
          <span class="fu">$</span> flip runStateT i <span class="fu">$</span> runWriterT <span class="fu">$</span> runWriterT
          <span class="fu">$</span> runWriterT <span class="fu">$</span> runWriterT <span class="fu">$</span> runWriterT
          <span class="fu">$</span> runWriterT <span class="fu">$</span> runWriterT <span class="fu">$</span> unGWidget w
    <span class="kw">let</span> ((((((((a,
                body),
               title),
              scripts),
             stylesheets),
            style),
           jscript),
          h),
         i&#39;) <span class="fu">=</span> w&#39;
    <span class="dt">GWidget</span> <span class="fu">$</span> <span class="kw">do</span>
      tell body
      lift <span class="fu">$</span> tell title
      lift <span class="fu">$</span> lift <span class="fu">$</span> tell scripts
      lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> tell stylesheets
      lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> tell style
      lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> tell jscript
      lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> tell h
      lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> lift
           <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> lift <span class="fu">$</span> put i&#39;
      return a</code></pre></div>
<p>Do <strong>not</strong> write code like this.</p>
<h4 id="wrap-it-smack-it-pre-lift-it.">Wrap it, smack it, pre-lift it.</h4>
<p>There are many ways to avoid this hell,<br />
but one of the most robust and common is<br />
newtyping your Monad stack and abstracting away the representation,<br />
then provide functionality leveraging the representation as part of your API.<br />
Scotty does this well:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Web.Scotty</span>
λ<span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">ActionM</span>
<span class="dt">Web.Scotty.Internal.Types.ActionT</span> <span class="dt">Text</span> <span class="dt">IO</span></code></pre></div>
<p>Scotty hides the underlying type in an Internal module<br />
because normally developers don't need to worry about it when using the library.<br />
If they do happen to need it, they can just import the Internal module:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Web.Scotty.Internal.Types</span>
λ<span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">ActionT</span>
<span class="kw">newtype</span> <span class="dt">ActionT</span> e (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) a
  <span class="fu">=</span> <span class="dt">ActionT</span> {<span class="ot">runAM ::</span> <span class="dt">ExceptT</span>
                      (<span class="dt">ActionError</span> e)
                      (<span class="dt">ReaderT</span> <span class="dt">ActionEnv</span> (<span class="dt">StateT</span> <span class="dt">ScottyResponse</span> m))
                      a}</code></pre></div>
<p>This is good practice;<br />
it hides unnecessary noise from consumers of the library<br />
and also reduces manual lifting within the Monad.<br />
For example, above we only needed one <code>lift</code> to perform an IO action in <code>ActionM</code><br />
even though the underlying implementation has a bunch of transformers in the stack.</p>
<h3 id="monadio-aka-zoom-zoom">26.10 MonadIO aka zoom-zoom</h3>
<p>MonadIO is yet another way to lift an action over additional structure.<br />
MonadIO is different from MonadTrans because rather than lifting through one layer at a time,<br />
MonadIO keeps lifting your IO action until it is lifted over <em>all</em> structure embedded<br />
within the the outermost IO type.<br />
Thus, this class is for monads in which IO computations may be embedded.<br />
<em>Any</em> monad built by applying a sequence of monad transformers to the IO monad<br />
can be an instance of this class.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> m <span class="kw">where</span>
<span class="ot">  liftIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a

<span class="co">-- Laws</span>

<span class="co">-- 1 --</span>
liftIO <span class="fu">.</span> return <span class="fu">=</span> return

<span class="co">-- 2 --</span>
liftIO (m <span class="fu">&gt;&gt;=</span> f) <span class="fu">=</span> liftIO m <span class="fu">&gt;&gt;=</span> (liftIO <span class="fu">.</span> f)</code></pre></div>
<p>We can modify the previous Scotty example</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.IO.Class</span>
liftIO (putStrLn <span class="st">&quot;hello&quot;</span>)</code></pre></div>
<h4 id="monadio-instances">MonadIO instances</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- IdentityT</span>
<span class="kw">instance</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> (<span class="dt">IdentityT</span> m) <span class="kw">where</span>
  liftIO <span class="fu">=</span> <span class="dt">IdentityT</span> <span class="fu">.</span> liftIO

<span class="co">-- EitherT</span>
<span class="kw">instance</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> (<span class="dt">EitherT</span> e m) <span class="kw">where</span>
  liftIO <span class="fu">=</span> lift <span class="fu">.</span> liftIO

<span class="co">-- 1. MaybeT</span>
<span class="kw">instance</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> (<span class="dt">MaybeT</span> m) <span class="kw">where</span>
  liftIO <span class="fu">=</span> lift <span class="fu">.</span> liftIO

<span class="co">-- 2. ReaderT</span>
<span class="kw">instance</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span>
  liftIO <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="fu">.</span> const <span class="fu">.</span> liftIO

<span class="co">-- 3. StateT</span>
<span class="kw">instance</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
  liftIO x <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> liftIO x
    return (a, s)</code></pre></div>
<h3 id="monads-do-not-commute">26.12 Monads do not commute</h3>
<p>In general, monads do not commute.<br />
Some type combinations will not be sensible,<br />
so we still have to <em>think</em> before constructing willy nilly.</p>
<p>For example, take a look at two simple examples of a <code>ReaderT r Maybe</code> value<br />
compared with a <code>MaybeT (Reader r)</code> value:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">ReaderT</span> <span class="dt">String</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
f <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="fu">$</span> \r <span class="ot">-&gt;</span> <span class="dt">Just</span> (length r)

<span class="ot">g ::</span> <span class="dt">MaybeT</span> (<span class="dt">Reader</span> <span class="dt">String</span>) <span class="dt">Int</span>
g <span class="fu">=</span> <span class="dt">MaybeT</span> <span class="fu">.</span> <span class="dt">ReaderT</span> <span class="fu">$</span> \r <span class="ot">-&gt;</span> <span class="dt">Identity</span> (<span class="dt">Just</span> (length r))</code></pre></div>
<p>For this very simple example, yes we can create a reader of string values<br />
and return the length of said string, but it is clear from the implementations<br />
that these are <em>very</em> different types.<br />
I don't know how to prove this exactly, but intuition leans towards inequality.</p>
<h3 id="transform-if-you-want-to">26.13 Transform if you want to</h3>
<p>According to Chris, most of the time you can get by with<br />
<code>liftIO</code>, plain IO actions and nontransformer types,<br />
so don't force monad transformers if implementing them is impeding progress.<br />
When first mapping out something new or unfamiliar,<br />
do the simplest thing first<br />
and let more structured formulations fall out naturally.<br />
Remember, being happy and productive is better than being fancy.</p>
<h3 id="chapter-exercises-11">26.14 Chapter Exercises</h3>
<ol>
<li><a href="./WriteTheCode.hs">Write the code</a></li>
<li><a href="./FixTheCode.hs">Fix the code</a></li>
<li><a href="./HitCounter.hs">Hit counter</a></li>
<li><p><a href="./morra/src/Main.hs">Morra</a></p>
<h1 id="non-strictness">Non-strictness</h1></li>
</ol>
<p>Technically, Haskell is &quot;non-strict&quot; and not &quot;lazy&quot;.<br />
In a nutshell, expressions are reduced when necessary,<br />
and when the reduction (evaluation) begins, a <strong>thunk</strong> is created for each expression.<br />
The thunk acts like a placeholder in the underlying graph of the program.<br />
It can be evaluated when necessary, but if it's never needed,<br />
it never gets reduced and the garbage collector sweeps it away.<br />
Once it is evaluated, it is usually shared;<br />
that is if <code>x</code> is needed twice and <code>x = 1 + 1</code>, the second time it does not need to be recomputed.<br />
This fits with my overall intuition so far.</p>
<p>A truly <strong>lazy</strong> language memoizes the results of all functions it evaluates.<br />
For larger programs, this results in unacceptably large amounts of memory.<br />
Implementations of Haskell such as GHC are only obligated to be non-strict with respect to bottom.<br />
Basically, any given implementation of non-strictness is acceptable<br />
as long as it respects when it's supposed to return a value successfully or bottom out.</p>
<h3 id="outside-in-inside-out">27.3 Outside in, inside out</h3>
<p>Strict languages evaluate <em>inside out</em>, while non-strict languages evaluate <em>outside in</em>.<br />
The order of evaluation can depend on which values are being forced.<br />
We've seen this from playing with evaluations such as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> const <span class="ch">&#39;a&#39;</span> undefined
<span class="ch">&#39;a&#39;</span>

λ<span class="fu">&gt;</span> snd (putStrLn <span class="st">&quot;hello&quot;</span>, putStrLn <span class="st">&quot;world&quot;</span>)
world</code></pre></div>
<h3 id="what-does-the-other-way-look-like">27.4 What does the other way look like?</h3>
<p>And we can get away with defining arbitrary bindings to bottom:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hypo ::</span> <span class="dt">IO</span> ()
hypo <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span><span class="ot"> x ::</span> <span class="dt">Int</span>
      x <span class="fu">=</span> undefined
  s <span class="ot">&lt;-</span> getLine
  <span class="kw">case</span> s <span class="kw">of</span>
    <span class="st">&quot;hi&quot;</span> <span class="ot">-&gt;</span> print x
    _    <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;hello&quot;</span></code></pre></div>
<p>For strict languages, this is a problem - a strict language will force the bottom before binding <code>x</code>.<br />
In general, it evaluates each binding as it comes into scope, not when the binding is used.</p>
<p>The idea is that evaluation is <strong>driven by demand</strong>, not by <em>construction</em>.</p>
<h4 id="can-we-make-haskell-strict">Can we make Haskell strict?</h4>
<p>Let's try to make Haskell treat <code>hypo</code> as a strict language would:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hypo&#39; ::</span> <span class="dt">IO</span> ()
hypo&#39; <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span><span class="ot"> x ::</span> <span class="dt">Integer</span>
      x <span class="fu">=</span> undefined
  s <span class="ot">&lt;-</span> getLine
  <span class="kw">case</span> x <span class="ot">`seq`</span> s <span class="kw">of</span>
    <span class="st">&quot;hi&quot;</span> <span class="ot">-&gt;</span> print x
    _    <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;hello&quot;</span></code></pre></div>
<p>The <code>seq :: a -&gt; b -&gt; b</code> function magically forces evaluation of the first argument<br />
whenever the second argument has to be evaluated.<br />
Still, this isn't quite strict, since we ran <code>getLine</code> successfully.</p>
<h4 id="seq-and-ye-shall-find"><code>seq</code> and ye shall find</h4>
<p>In old versions of Haskell, <code>seq</code> had type <code>seq :: Eval a =&gt; a -&gt; b -&gt; b</code><br />
and the <code>Eval</code> typeclass had a method for forcing evaluation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">seq bottom b    <span class="fu">=</span> bottom
seq notBottom b <span class="fu">=</span> b</code></pre></div>
<p>We need this evaluator to look <code>const</code>-ish because evaluation is <strong>demand driven</strong>,<br />
so we create links between nodes in the graph of expressions<br />
where forcing one expression will force yet another expression.<br />
Of course, this does mean that we cannot actually guarantee evaluation, ever.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">undefined <span class="ot">`seq`</span> y
<span class="co">-- forcing y -&gt; forces undefined</span>

undefined <span class="ot">`seq`</span> y <span class="ot">`seq`</span> x
<span class="co">-- forcing x -&gt; forces y -&gt; forces undefined</span></code></pre></div>
<h4 id="seq-and-weak-head-normal-form"><code>seq</code> and weak head normal form</h4>
<p><code>seq</code> evaluates your expression up to <strong>weak head normal form</strong>,<br />
which basically means it stops at the first data constructor or lambda<br />
(for more info head to <em>Parallel and Concurrent Programming in Haskell</em>).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> dc <span class="fu">=</span> (,) undefined undefined
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> noDc <span class="fu">=</span> undefined
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> lam <span class="fu">=</span> \_ <span class="ot">-&gt;</span> undefined
<span class="dt">Prelude</span><span class="fu">&gt;</span> dc <span class="ot">`seq`</span> <span class="dv">1</span>
<span class="dv">1</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> lam <span class="ot">`seq`</span> <span class="dv">1</span>
<span class="dv">1</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> noDc <span class="ot">`seq`</span> <span class="dv">1</span>
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.undefined</code></pre></div>
<h4 id="case-matching-also-chains-evaluation">Case matching also chains evaluation</h4>
<p>This is pretty obvious; the values we pattern match on are forced<br />
because Haskell doesn't know which data constructor is relevant until it is evaluated<br />
to the depth required (which is the depth of the data constructors that we pattern match).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Either</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
f (<span class="dt">Left</span> _)  <span class="fu">=</span> <span class="dv">1</span>
f (<span class="dt">Right</span> _) <span class="fu">=</span> <span class="dv">2</span>

λ<span class="fu">&gt;</span> f undefined
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.undefined

λ<span class="fu">&gt;</span> f (<span class="dt">Right</span> undefined)
<span class="dv">2</span></code></pre></div>
<h4 id="core-dump">Core Dump</h4>
<p>So far we've investigated strictness by injecting bottoms<br />
and seeing whether or not they get evaluated.<br />
We can also look at the underlying language that GHC Haskell gets simplified to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- CoreDump.hs</span>
<span class="kw">module</span> <span class="dt">CoreDump</span> <span class="kw">where</span>

<span class="ot">discriminatory ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
discriminatory b <span class="fu">=</span>
  <span class="kw">let</span> x <span class="fu">=</span> undefined
  <span class="kw">case</span> b <span class="kw">of</span>
    <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dv">0</span>
    <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dv">1</span>

λ<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span>ddump<span class="fu">-</span>simpl
λ<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span>dsuppress<span class="fu">-</span>all
λ<span class="fu">&gt;</span> <span class="fu">:</span>l CoreDump.hs

discriminatory
discriminatory <span class="fu">=</span>
  \ b_a2ze <span class="ot">-&gt;</span>
    <span class="kw">case</span> b_a2ze <span class="kw">of</span> _ {
      <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">0</span><span class="fu">#</span>;
      <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">1</span><span class="fu">#</span>
    }</code></pre></div>
<p>We're looking for case expressions in GHC Core, since those must be evaluated.<br />
Note that GHC Core knows we never use <code>x</code> so it drops it off.<br />
Now let's see what <code>seq</code> does:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">discriminatory ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
discriminatory b <span class="fu">=</span>
  <span class="kw">let</span> x <span class="fu">=</span> undefined
  <span class="kw">in</span> <span class="kw">case</span> x <span class="ot">`seq`</span> b <span class="kw">of</span>
    <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dv">0</span>
    <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dv">1</span>

<span class="co">-- GHC Core</span>
discriminatory <span class="fu">=</span>
\ b_a10D <span class="ot">-&gt;</span>
    <span class="kw">let</span> {
      x_a10E
      x_a10E <span class="fu">=</span> undefined } <span class="kw">in</span>
    <span class="kw">case</span>
      <span class="kw">case</span> x_a10E <span class="kw">of</span> _ {
        __DEFAULT <span class="ot">-&gt;</span> b_a10D
      } <span class="kw">of</span> _ {
        <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">0</span>;
        <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">1</span>
      }</code></pre></div>
<p>Now there are <em>two</em> nested case expressions to force <code>x</code> before <code>b</code>.<br />
Notice this is the same as the first except <code>b_a10D</code><br />
is replaced by <code>case x_a10E of _ { __DEFAULT -&gt; b_a10D }</code>.</p>
<h5 id="a-core-difference">A core difference</h5>
<p>In Haskell, only pattern matching on a case is strict up to WHNF<br />
while in Core, cases are always strict regardless of pattern matching:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Haskell</span>
<span class="co">-- does not bottom out</span>
<span class="co">-- Core actually drops this entire case expression during compilation</span>
<span class="kw">case</span> undefined <span class="kw">of</span> { _ <span class="ot">-&gt;</span> <span class="dt">False</span> }

<span class="co">-- Core</span>
<span class="co">-- even with just one case without matching on anything, this evaluates bottom</span>
<span class="kw">case</span> undefined <span class="kw">of</span> { <span class="dt">DEFAULT</span> <span class="ot">-&gt;</span> <span class="dt">False</span> }</code></pre></div>
<p>Keep in mind Core and Haskell are not the same language;<br />
however Core is convenient for seeing if two expressions are equivalent.</p>
<h4 id="exercises-evaluate">Exercises: Evaluate</h4>
<p>What do these evaluate to?</p>
<ol>
<li><code>const 1 undefined</code></li>
</ol>
<p><code>1</code></p>
<ol>
<li><code>const undefined 1</code></li>
</ol>
<p><code>bottom</code></p>
<ol>
<li><code>flip const undefined 1</code></li>
</ol>
<p><code>1</code></p>
<ol>
<li><code>flip const 1 undefined</code></li>
</ol>
<p><code>bottom</code></p>
<ol>
<li><code>const undefined undefined</code></li>
</ol>
<p><code>bottom</code></p>
<ol>
<li><code>foldr const 'z' ['a'..'e']</code></li>
</ol>
<p><code>const 'a' (foldr const 'z' ['b'..'e'])   const 'a' (const 'b' (foldr const 'z' ['c'..'e']))   ...   'a'</code></p>
<ol>
<li><code>foldr (flip const) 'z' ['a'..'e']</code><br />
<code>let f = flip const   f 'a' (foldr f 'z' ['b'..'e'])   f 'a' (f 'b' (foldr f 'z' ['c'..'e']))   ...   f 'a' (.. (.. f 'e' 'z'))   'z'</code></li>
</ol>
<h3 id="thunk-life">27.7 Thunk Life</h3>
<p>A <strong>thunk</strong> is used to reference suspended computations<br />
that may or may not be performed/computed at a later point in the program.</p>
<h4 id="not-all-values-get-thunked">Not all values get thunked</h4>
<p>We'll use GHCi <code>sprint</code>, which shows what has been evaluated.<br />
Unevaluated values are represented as <code>_</code>.<br />
It can be quirky, but this chapter explains the quirks.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> l <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Integer</span>]
λ<span class="fu">&gt;</span> <span class="fu">:</span>sprint l
l <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<p>The list is already fully evaluated! This is due to <strong>opportunistic strictness</strong>.<br />
GHC will not thunk values which are merely data constructors, since data constructors are constant,<br />
so this is better for optimization.<br />
Above, the data constructors are <code>:</code>, <code>[]</code>, and each integer <code>1</code>, <code>2</code>, <code>3</code>.</p>
<p>Since all of those are immediately fully applied, the list is fully evaluated.<br />
However, remember that data constructors are evaluated to <em>weak head normal form</em>, so<br />
the evaluation of data constructors does not continue past WHNF:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> l <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,id <span class="dv">4</span>]<span class="ot"> ::</span> [<span class="dt">Integer</span>]
λ<span class="fu">&gt;</span> <span class="fu">:</span>sprint l
l <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,_]</code></pre></div>
<p>Another thing to keep in mind is that above, <code>l</code> gets evaluated in part because<br />
we already know which data constructors to use.<br />
If we don't specify the type, there will be an implicit function <code>Num a -&gt; a</code><br />
awaiting application and thus the list will get thunked:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> l <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
λ<span class="fu">&gt;</span> <span class="fu">:</span>sprint l
l <span class="fu">=</span> _</code></pre></div>
<p>Lastly, consider what happens when we concat this list with another:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> l <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
λ<span class="fu">&gt;</span> <span class="kw">let</span> l&#39; <span class="fu">=</span> l <span class="fu">++</span> undefined
λ<span class="fu">&gt;</span> <span class="fu">:</span>sprint l&#39;
l&#39; <span class="fu">=</span> _</code></pre></div>
<p>The whole expression gets thunked because the outermost term is now a <em>function</em> <code>(++)</code><br />
instead of a data constructor like <code>(:)</code>.</p>
<h3 id="sharing-is-caring">27.8 Sharing is caring</h3>
<p>Sharing refers to sharing the results of a computation with all references to that name<br />
without re-evaluating it.<br />
This is important because memory is finite.<br />
As mentioned previously, GHC oscillates between call-by-need and call-by-name;<br />
that is, it doesn't share all the time, but shares when it can<br />
and when it thinks it will produce faster code.</p>
<h4 id="using-trace-to-observe-sharing">Using trace to observe sharing</h4>
<p>The <em>base</em> library has a <code>Debug.Trace</code> module that's useful for investigating sharing.<br />
Note: it cheats the type system and uses <code>putStrLn</code> outside of <code>IO</code>.<br />
It should <strong>never</strong> be used in real code, just for experimentation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Debug.Trace</span>
λ<span class="fu">&gt;</span> a <span class="fu">=</span> trace <span class="st">&quot;a&quot;</span> <span class="dv">1</span>
λ<span class="fu">&gt;</span> b <span class="fu">=</span> trace <span class="st">&quot;b&quot;</span> <span class="dv">2</span>
λ<span class="fu">&gt;</span> a <span class="fu">+</span> b
b
a
<span class="dv">3</span></code></pre></div>
<p>Wow. Evaluation of the arguments to addition <code>(+)</code> is not guaranteed.</p>
<h4 id="what-promotes-sharing">What promotes sharing</h4>
<p><strong>Names</strong> promote sharing when possible.<br />
Even if two names are bound to the same value they have to be evaluated separately.<br />
So if we only want to evaluate <code>1 :: Int</code> once, we can name it a single variable:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- two separate &quot;names&quot;</span>
λ<span class="fu">&gt;</span> x <span class="fu">=</span> trace <span class="st">&quot;x&quot;</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)
λ<span class="fu">&gt;</span> y <span class="fu">=</span> trace <span class="st">&quot;y&quot;</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)
λ<span class="fu">&gt;</span> x <span class="fu">+</span> y
x
y
<span class="dv">2</span>

<span class="co">-- just one &quot;name&quot;</span>
λ<span class="fu">&gt;</span> x <span class="fu">=</span> trace <span class="st">&quot;x&quot;</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)
λ<span class="fu">&gt;</span> x
x
<span class="dv">1</span>
λ<span class="fu">&gt;</span> x
<span class="dv">1</span></code></pre></div>
<p>Notice the last three times we used <code>x</code>, its value was already held in memory<br />
and didn't need to be evaluated again.</p>
<p>There are some counterintuitive scenarios though.<br />
One such example is construction of strings: <code>['a']</code> versus <code>&quot;a&quot;</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> a <span class="fu">=</span> <span class="dt">Just</span> [<span class="ch">&#39;a&#39;</span>]
λ<span class="fu">&gt;</span> <span class="fu">:</span>sprint a
a <span class="fu">=</span> <span class="dt">Just</span> <span class="st">&quot;a&quot;</span>

λ<span class="fu">&gt;</span> <span class="kw">let</span> a <span class="fu">=</span> <span class="dt">Just</span> <span class="st">&quot;a&quot;</span>
λ<span class="fu">&gt;</span> <span class="fu">:</span>sprint a
a <span class="fu">=</span> <span class="dt">Just</span> _</code></pre></div>
<p>The two examples above have the same value but are created using different data constructors,<br />
and the GHC optimization analysis is limited to data constructors, not computation.<br />
Of course, this means that the syntactic sugar for strings is represented differently in GHC Core:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Just [&#39;a&#39;]</span>
((<span class="dt">Just</span> (<span class="fu">:</span> (<span class="dt">C</span><span class="fu">#</span> <span class="ch">&#39;a&#39;</span><span class="fu">#</span>) [])) <span class="ot">`cast`</span> <span class="fu">...</span>)

<span class="co">-- Just &quot;a&quot;</span>
((<span class="dt">Just</span> (unpackCString<span class="fu">#</span> <span class="st">&quot;a&quot;</span><span class="fu">#</span>)) <span class="ot">`cast`</span> <span class="fu">...</span>)</code></pre></div>
<p>GHC does this purposefully for more optimization opportunities,<br />
such as converting string literals to ByteString or Text values.</p>
<h4 id="what-prevents-sharing">What prevents sharing</h4>
<p><strong>Inlining expressions</strong> where they get used prevents sharing,<br />
as it creates independent thunks that get computed separately.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> f _ <span class="fu">=</span> trace <span class="st">&quot;f&quot;</span> <span class="dv">1</span>
λ<span class="fu">&gt;</span> f <span class="ch">&#39;a&#39;</span>
f
<span class="dv">1</span>
λ<span class="fu">&gt;</span> f <span class="ch">&#39;a&#39;</span>
f
<span class="dv">1</span></code></pre></div>
<p>When we assign a name to the value of <code>(2 + 2)</code>, it is shared:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span><span class="ot"> a ::</span> <span class="dt">Int</span>; a <span class="fu">=</span> trace <span class="st">&quot;a&quot;</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">2</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> b <span class="fu">=</span> (a <span class="fu">+</span> a)
<span class="dt">Prelude</span><span class="fu">&gt;</span> b
a
<span class="dv">8</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> b
<span class="dv">8</span></code></pre></div>
<p>But inline expressions equivalent to <code>a</code> won't get shared without being bound to the same name:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span><span class="ot"> c ::</span> <span class="dt">Int</span>; c <span class="fu">=</span> (trace <span class="st">&quot;a&quot;</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> (trace <span class="st">&quot;a&quot;</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">2</span>)
<span class="dt">Prelude</span> <span class="dt">Debug.Trace</span>
λ<span class="fu">&gt;</span> c
a
a
<span class="dv">8</span>
<span class="dt">Prelude</span> <span class="dt">Debug.Trace</span>
λ<span class="fu">&gt;</span> c
<span class="dv">8</span></code></pre></div>
<p>Note that a <strong>function with explicit arguments</strong> is not shared.<br />
As noted earlier, Haskell is <em>not fully lazy</em>, so it is not required to remember<br />
the result of function application for a given set of arguments:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> f <span class="fu">=</span> trace <span class="st">&quot;f&quot;</span> const <span class="fu">$</span> <span class="dv">1</span>
λ<span class="fu">&gt;</span> f <span class="ch">&#39;a&#39;</span>
f
<span class="dv">1</span>
λ<span class="fu">&gt;</span> f <span class="ch">&#39;b&#39;</span>
f
<span class="dv">1</span></code></pre></div>
<p>However this is for <strong>explicit arguments</strong>.<br />
Eta reduction to pointfree code (dropping arguments) can change sharing properties<br />
(explained in next chapter).</p>
<p><strong>Typeclass constraints</strong> also prevent sharing.<br />
If we omit the concrete type hints from earlier examples, things get re-evaluated:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> a <span class="fu">=</span> trace <span class="st">&quot;a&quot;</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">2</span>
λ<span class="fu">&gt;</span> <span class="kw">let</span> b <span class="fu">=</span> (a <span class="fu">+</span> a)
λ<span class="fu">&gt;</span> b
a
a
<span class="dv">8</span>
λ<span class="fu">&gt;</span> b
a
a
<span class="dv">8</span></code></pre></div>
<p>This is because typeclass constraints are a function in Core,<br />
awaiting application to become concrete types.</p>
<p>Implicit parameters have a similar effect on sharing to that of typeclass constraints<br />
because both decay into function arguments when compiled.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span><span class="ot"> add ::</span> (<span class="fu">?</span><span class="ot">x ::</span> <span class="dt">Int</span>) <span class="ot">=&gt;</span> <span class="dt">Int</span>; add <span class="fu">=</span> trace <span class="st">&quot;add&quot;</span> <span class="dv">1</span> <span class="fu">+</span> <span class="fu">?</span>x
λ<span class="fu">&gt;</span> <span class="kw">let</span> <span class="fu">?</span>x <span class="fu">=</span> <span class="dv">1</span> <span class="kw">in</span> add
add
<span class="dv">2</span>
λ<span class="fu">&gt;</span> <span class="kw">let</span> <span class="fu">?</span>x <span class="fu">=</span> <span class="dv">1</span> <span class="kw">in</span> add
add
<span class="dv">2</span></code></pre></div>
<h4 id="why-polymorphic-values-never-seem-to-get-forced">Why polymorphic values never seem to get forced</h4>
<p>First let's observe this in action. Leaving the <code>1</code> polymorphic:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> blah <span class="fu">=</span> <span class="dt">Just</span> (trace <span class="st">&quot;evaled 1&quot;</span> <span class="dv">1</span>)
λ<span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) blah
<span class="dt">Just</span> evaled <span class="dv">1</span>
<span class="dv">2</span>
λ<span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) blah
<span class="dt">Just</span> evaled <span class="dv">1</span>
<span class="dv">2</span></code></pre></div>
<p>the <code>blah</code> is evaluated twice, and thus the <code>fmap</code> expression is not shared.<br />
If we make <code>1</code> concrete:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> blah <span class="fu">=</span> <span class="dt">Just</span> (trace <span class="st">&quot;evaled 1&quot;</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>))
λ<span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) blah
<span class="dt">Just</span> evaled <span class="dv">1</span>
<span class="dv">2</span>
λ<span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) blah
<span class="dt">Just</span> <span class="dv">2</span></code></pre></div>
<p>then the <code>fmap</code> expression is shared.</p>
<p>This is because in GHC Core, polymorphic values that have a simple typeclass constraint<br />
such as <code>Num a =&gt; a</code> are represented as lambdas awaiting a typeclass instance argument.<br />
These types can become concrete through assignment or type defaulting,<br />
but if they are not concrete, the lambda will need to be re-evaluated every time<br />
since unapplied functions are not shareable values.<br />
Hence, polymorphic expressions cannot be shared.</p>
<h4 id="preventing-sharing-on-purpose">Preventing sharing on purpose</h4>
<p>We might want to <em>prevent</em> sharing to prevent a large datum in memory<br />
that was calculated to provide a much smaller answer.<br />
It turns out we can do this by adding named arguments, as opposed to pointfree expressions.<br />
Observe:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> f x <span class="fu">=</span> (x <span class="dv">2</span>) <span class="fu">+</span> (x <span class="dv">10</span>)

<span class="co">-- not shared</span>
λ<span class="fu">&gt;</span> g <span class="fu">=</span> \_ <span class="ot">-&gt;</span> trace <span class="st">&quot;hi&quot;</span> <span class="dv">2</span>
λ<span class="fu">&gt;</span> f g
hi
hi
<span class="dv">4</span>

<span class="co">-- shared</span>
λ<span class="fu">&gt;</span> g <span class="fu">=</span> const (trace <span class="st">&quot;hi&quot;</span> <span class="dv">2</span>)
λ<span class="fu">&gt;</span> f g
hi
<span class="dv">4</span></code></pre></div>
<h4 id="forcing-sharing">Forcing sharing</h4>
<p>This one is easy - just give your expression a name. We can use <code>let</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- not shared</span>
λ<span class="fu">&gt;</span> (trace <span class="st">&quot;eval 1 plus 1&quot;</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Int</span>) <span class="fu">+</span> (trace <span class="st">&quot;eval 1 plus 1&quot;</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Int</span>)
eval <span class="dv">1</span> plus <span class="dv">1</span>
eval <span class="dv">1</span> plus <span class="dv">1</span>
<span class="dv">4</span>

<span class="co">-- shared</span>
λ<span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> (trace <span class="st">&quot;eval 1 plus 1&quot;</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Int</span>) <span class="kw">in</span> x <span class="fu">+</span> x
eval <span class="dv">1</span> plus <span class="dv">1</span>
<span class="dv">4</span></code></pre></div>
<p>This is a very important concept to remember for production applications<br />
and any long running process.<br />
For example, look at the <code>forever</code> definition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">forever ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b
forever a <span class="fu">=</span> <span class="kw">let</span> b <span class="fu">=</span> a <span class="fu">&gt;&gt;</span> b <span class="kw">in</span> b</code></pre></div>
<p>The let expression is used because we need to force sharing here.<br />
Without it we'd be leaking memory with each monadic action,<br />
but with it GHC overwrites the thunk of each monadic action.</p>
<h3 id="refutable-and-irrefutable-patterns">27.9 Refutable and irrefutable patterns</h3>
<p>When pattern matching, an <strong>irrefutable</strong> pattern is one that <em>always matches</em>,<br />
and a <strong>refutable</strong> pattern is one with potential failures.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">refutable ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
refutable <span class="dt">True</span> <span class="fu">=</span> <span class="dt">False</span>
refutable <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span>

<span class="ot">irrefutable ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
irrefutable x <span class="fu">=</span> not x

<span class="ot">oneOfEach ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
oneOfEach <span class="dt">True</span> <span class="fu">=</span> <span class="dt">False</span>
oneOfEach _ <span class="fu">=</span> <span class="dt">True</span></code></pre></div>
<h4 id="lazy-patterns">Lazy patterns</h4>
<p>Lazy patterns are irrefutable. We can make a pattern match lazy with <code>~</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lazyPattern ::</span> (a, b) <span class="ot">-&gt;</span> <span class="dt">String</span>
lazyPattern <span class="fu">~</span>(a,b) <span class="fu">=</span> const <span class="st">&quot;Cousin It&quot;</span> a</code></pre></div>
<p>but since it makes an irrefutable match, we can't discriminate against sum types.<br />
So it's really only useful for deconstructing product types that might not get used:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> lazyPattern undefined
<span class="st">&quot;Cousin It&quot;</span></code></pre></div>
<p>The default, without <code>~</code>, just goes ahead and forces it<br />
for more predictable memory usage and performance.</p>
<h3 id="bang-patterns">27.10 Bang-patterns</h3>
<p>Using the pragma <em>BangPatterns</em> we can force evaluation of arguments:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE BangPatterns #-}</span>
<span class="kw">module</span> <span class="dt">Bang</span> <span class="kw">where</span>

<span class="ot">doesntEval ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
doesntEval b <span class="fu">=</span> <span class="dv">1</span>

<span class="ot">manualSeq ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
manualSeq b <span class="fu">=</span> b <span class="ot">`seq`</span> <span class="dv">1</span>

<span class="ot">bang ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
bang <span class="fu">!</span>b <span class="fu">=</span> <span class="dv">1</span></code></pre></div>
<p>Note that <code>manualSeq</code> and <code>bang</code> compile to the <em>same</em> function in GHC Core<br />
and are thus completely equivalent.</p>
<h4 id="bang-patterns-in-data">Bang patterns in data</h4>
<p>Just as we can force evaluation of arguments to functions,<br />
we can force evaluation of arguments to data constructors:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Foo</span> <span class="dt">Int</span> <span class="fu">!</span><span class="dt">Int</span>

first (<span class="dt">Foo</span> x _) <span class="fu">=</span> x
second (<span class="dt">Foo</span> _ y) <span class="fu">=</span> y

λ<span class="fu">&gt;</span> second (<span class="dt">Foo</span> undefined <span class="dv">1</span>)
<span class="dv">1</span>
λ<span class="fu">&gt;</span> first (<span class="dt">Foo</span> <span class="dv">1</span> undefined)
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.undefined</code></pre></div>
<p>We want this capability because <strong>sometimes it's cheaper to just compute something<br />
rather than construct a thunk and evaluate later</strong>.<br />
This is common in numerics, as it's very cheap to individually construct values<br />
of types such as <code>Int</code> and <code>Double</code>.</p>
<p>Again, as mentioned way back, the rule of thumb is<br />
<strong>lazy in the spine, strict in the leaves</strong>.<br />
For example, a strict large list (spine) of 1,000,000 lazy tiny values (integers)<br />
made into less-tiny thunks can result in very excessive memory usage<br />
when we could've just computed them on the spot.</p>
<h3 id="strict-and-strictdata">27.11 Strict and StrictData</h3>
<p>In GHC 8.0 and newer, there are <em>Strict</em> and <em>StrictData</em> pragmas<br />
that help avoid slamming code with <code>seq</code> and bang patterns without<br />
adding any new semantics.<br />
It doesn't make lazy data structures defined elsewhere behave differently,<br />
only the ones defined within the module with the pragma.<br />
We can still have irrefutable patterns be lazy by using the tilde:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Strict #-}</span>
<span class="kw">module</span> <span class="dt">StrictTest</span> <span class="kw">where</span>

<span class="co">-- equivalent to</span>
<span class="co">-- willForce !x = 1</span>
willForce x <span class="fu">=</span> <span class="dv">1</span>

willNotForce <span class="fu">~</span>x <span class="fu">=</span> <span class="dv">1</span></code></pre></div>
<h3 id="chapter-exercises-12">27.13 Chapter Exercises</h3>
<h4 id="what-will-sprint-output">What will <code>:sprint</code> output?</h4>
<ol>
<li><code>let x = 1</code></li>
</ol>
<p><code>haskell   x = _</code></p>
<ol>
<li><code>let x = ['1']</code></li>
</ol>
<p><code>haskell   x = &quot;1&quot;</code></p>
<ol>
<li><code>let x = [1]</code></li>
</ol>
<p><code>haskell   x = _</code></p>
<ol>
<li><code>let x = 1 :: Int</code></li>
</ol>
<p><code>haskell   x = 1</code></p>
<ol>
<li><code>let f = \x -&gt; x</code> and <code>let x = f 1</code></li>
</ol>
<p><code>haskell   f = _   x = _</code></p>
<ol>
<li><code>let f :: Int -&gt; Int; f = \x -&gt; x</code> and <code>let x = f 1</code></li>
</ol>
<p><code>haskell   f = _   x = _</code></p>
<h4 id="will-printing-this-expression-result-in-bottom">Will printing this expression result in bottom?</h4>
<ol>
<li>`snd (undefined, 1)</li>
</ol>
<p><strong>No</strong></p>
<ol>
<li><code>let x = undefined</code> and <code>let y = x</code>seq` 1 in snd (x,y)</li>
</ol>
<p><strong>Yes</strong></p>
<ol>
<li>length $ [1..5] ++ undefined</li>
</ol>
<p><strong>Yes</strong></p>
<ol>
<li>length $ [1..5] ++ [undefined]</li>
</ol>
<p><strong>No</strong></p>
<ol>
<li>const 1 undefined</li>
</ol>
<p><strong>No</strong></p>
<ol>
<li>const 1 (undefined <code>seq</code> 1)</li>
</ol>
<p><strong>No</strong></p>
<ol>
<li>const undefined 1</li>
</ol>
<p><strong>Yes</strong></p>
<h4 id="make-the-expression-bottom">Make the expression bottom</h4>
<p>Using only bang patterns or <code>seq</code>, make the below bottom out when executed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Initial code</span>
x <span class="fu">=</span> undefined
y <span class="fu">=</span> <span class="st">&quot;blah&quot;</span>
main <span class="fu">=</span> <span class="kw">do</span>
  print (snd (x, y))

<span class="co">-- Bottoming code</span>
x <span class="fu">=</span> undefined
y <span class="fu">=</span> <span class="st">&quot;blah&quot;</span>
main <span class="fu">=</span> <span class="kw">do</span>
  print (snd (x, x <span class="ot">`seq`</span> y))</code></pre></div>
<h1 id="basic-libraries">Basic Libraries</h1>
<p>Captain Obvious once said &quot;Data structures are very important&quot;.<br />
It's true. Computers are fast, but CPUs aren't getting much faster.<br />
The structures we choose to represent data directly affect<br />
the speed and memory involved in processing data.</p>
<h3 id="benchmarking-with-criterion">28.2 Benchmarking with Criterion</h3>
<p>Criterion is an easy-to-use library for measuring performance of libraries and arbitrary functions.<br />
It can output concise raw data on the terminal, or nice graphs in HTML.<br />
See an example at <a href="./bench.hs">bench.hs</a>.<br />
Just remember to run it with <code>-O</code> or <code>-O2</code>:</p>
<pre><code>stack ghc -- -O2 bench.hs
./bench</code></pre>
<p>(Note that <code>stack runghc</code> is an &quot;interactive&quot; mode that ignores the optimization flag <code>-O</code>.)</p>
<p>Criterion offers <code>whnf</code> and <code>nf</code> for evaluating to weak head normal form and normal form respectively:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">defaultMain ::</span> [<span class="dt">Benchmark</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">whnf ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Benchmarkable</span>
<span class="ot">nf   ::</span> <span class="dt">Control.DeepSeq.NFData</span> b
     <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Benchmarkable</span></code></pre></div>
<p>Notice we pass the function and its argument separately,<br />
so the result is not shared across benchmarking samples.<br />
In the <code>bench.hs</code> example above, we only need <code>whnf</code><br />
because <code>!!</code> and <code>!?</code> don't return a data constructor until they've already done their work<br />
(the bit in the recursive call).<br />
To use <code>nf</code> we need to write our own <code>NFData</code> instance (there are examples in the deepseq library).</p>
<h4 id="more-on-whnf-and-nf">More on whnf and nf</h4>
<p>We should use <code>whnf</code> when the first data constructor is an indicator<br />
that the work we're profiling is done. This happens pretty often.</p>
<p>One example when <code>whnf</code> is insufficient is for functions using <em>guarded recursion</em>,<br />
where a data constructor is interposed between steps, such as <code>map (+1)</code><br />
(<code>:</code> is between each recursion step for <code>map</code>).</p>
<p>Unlike <code>map</code> which is always guarded, <code>foldr</code> can result in guarded <em>or</em> unguarded recursion<br />
depending on the folding function.</p>
<h3 id="profilng-your-programs">28.3 Profilng your programs</h3>
<p>To profile a program with GHC, first read the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html">GHC User Guide</a>.<br />
This book is actually better used as a reference in this section<br />
for what tools and commands to use for different tasks, so no notes are necessary.</p>
<h3 id="constant-applicative-forms">28.4 Constant applicative forms</h3>
<p>CAFs are expressions that have no free variables and are held in memory<br />
to be shared with all other expressions in a module.<br />
They can be literal values or partially-applied functions,<br />
so long as the arguments aren't named.<br />
The sharing can increase speed by avoiding re-evaluation,<br />
but can become memory intensive very quickly.<br />
This is rarely a problem in real code since most large amounts of data usually come from elsewhere.<br />
If we do see too much memory usage, check for a large CAF like <code>largeCAF</code> below:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- CAF.hs</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="ot">largeCAF ::</span> [<span class="dt">Integer</span>]
largeCAF <span class="fu">=</span> map (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">..</span>]

<span class="ot">notCAF ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
notCAF x <span class="fu">=</span> map (<span class="fu">+</span><span class="dv">1</span>) x

<span class="ot">stillCAF ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
stillCAF <span class="fu">=</span> map (<span class="fu">+</span><span class="dv">1</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> largeCAF <span class="fu">!!</span> <span class="dv">1000</span>
  print <span class="fu">$</span> largeCAF <span class="fu">!!</span> <span class="dv">9000</span>
  print <span class="fu">$</span> notCAF [<span class="dv">1</span><span class="fu">..</span>] <span class="fu">!!</span> <span class="dv">1000</span>
  print <span class="fu">$</span> notCAF [<span class="dv">1</span><span class="fu">..</span>] <span class="fu">!!</span> <span class="dv">9000</span>
  print <span class="fu">$</span> stillCAF [<span class="dv">1</span><span class="fu">..</span>] <span class="fu">!!</span> <span class="dv">1000</span>
  print <span class="fu">$</span> stillCAF [<span class="dv">1</span><span class="fu">..</span>] <span class="fu">!!</span> <span class="dv">9000</span></code></pre></div>
<p>Then we can view profiling results with these commands:</p>
<pre class="shell"><code>$ stack ghc -- -prof -fprof-auto -rtsopts -O2 CAF.hs
$ ./CAF +RTS -hc -p
$ cat CAF.prof 
COST CENTRE MODULE  %time %alloc

largeCAF    Main     75.0   38.6
notCAF      Main     25.0   21.2
main        Main      0.0   17.9
stillCAF    Main      0.0   21.2
                                                     individual      inherited
COST CENTRE MODULE                no.     entries  %time %alloc   %time %alloc

MAIN        MAIN                   46          0    0.0    0.0   100.0  100.0
 main       Main                   93          0    0.0    0.5     0.0    0.5
 CAF        Main                   91          0    0.0    0.0   100.0   98.4
  stillCAF  Main                   96          1    0.0    0.0     0.0    0.0
  largeCAF  Main                   94          1   75.0   38.6    75.0   38.6
  main      Main                   92          1    0.0   17.4    25.0   59.9
   stillCAF Main                   97          0    0.0   21.2     0.0   21.2
   notCAF   Main                   95          1   25.0   21.2    25.0   21.2
 CAF        GHC.IO.Handle.FD       88          0    0.0    0.9     0.0    0.9
 CAF        GHC.IO.Encoding        84          0    0.0    0.1     0.0    0.1
 CAF        GHC.IO.Handle.Text     83          0    0.0    0.0     0.0    0.0
 CAF        GHC.Conc.Signal        80          0    0.0    0.0     0.0    0.0
 CAF        GHC.IO.Encoding.Iconv  69          0    0.0    0.0     0.0    0.0</code></pre>
<p>We see that <strong>pointfree top-level declarations are CAFs</strong>, while pointful ones are not.<br />
This is important to keep in mind; in particular for lists, which in Haskell<br />
are as much control structures as data structures.<br />
It's <em>very cheap</em> in GHC to construct and throw away lists.<br />
It can affect how much memory is used in <em>total</em>,<br />
but when it's not a CAF,<br />
it won't stay in the heap constantly which can lead to higher peak memory usage.</p>
<h3 id="map">28.5 Map</h3>
<p>Map is defined in the Data.Map module of the<br />
<a href="http://hackage.haskell.org/package/containers"><em>containers</em></a> library as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Map</span> k a
  <span class="fu">=</span> <span class="dt">Bin</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Size</span> <span class="fu">!</span>k a <span class="fu">!</span>(<span class="dt">Map</span> k a) <span class="fu">!</span>(<span class="dt">Map</span> k a)
  <span class="fu">|</span> <span class="dt">Tip</span>
<span class="kw">type</span> <span class="dt">Size</span> <span class="fu">=</span> <span class="dt">Int</span></code></pre></div>
<p>Data.Map.Map <strong>excels</strong> at looking up by key,<br />
however if you are using Int as a key type, you're probably better off<br />
with HashMap, IntMap, or Vector.</p>
<h3 id="set">28.6 Set</h3>
<p>Set also lives in <em>containers</em>. It's like Map, but it's only the <em>key</em> part of <em>key,value</em> pairs.<br />
Or, just ordered values.<br />
It is equivalent to a Map type with unit values, so it has the same pros and cons as Map.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Set</span> a
  <span class="fu">=</span> <span class="dt">Bin</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Size</span> <span class="fu">!</span>a <span class="fu">!</span>(<span class="dt">Set</span> a) <span class="fu">!</span>(<span class="dt">Set</span> a)
  <span class="fu">|</span> <span class="dt">Tip</span>

<span class="kw">type</span> <span class="dt">Size</span> <span class="fu">=</span> <span class="dt">Int</span></code></pre></div>
<h3 id="sequence">28.7 Sequence</h3>
<p>Sequence, also from <em>containers</em>, is built on finger trees and appends cheaply on front and back.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Seq</span> a <span class="fu">=</span> <span class="dt">Seq</span> (<span class="dt">FingerTree</span> (<span class="dt">Elem</span> a))

<span class="co">-- Elem is so elements and nodes can be</span>
<span class="co">-- distinguished in the types of the</span>
<span class="co">-- implementation. Don&#39;t sweat it.</span>
<span class="kw">newtype</span> <span class="dt">Elem</span> a <span class="fu">=</span> <span class="dt">Elem</span> {<span class="ot"> getElem ::</span> a }

<span class="kw">data</span> <span class="dt">FingerTree</span> a
  <span class="fu">=</span> <span class="dt">Empty</span>
  <span class="fu">|</span> <span class="dt">Single</span> a
  <span class="fu">|</span> <span class="dt">Deep</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> <span class="fu">!</span>(<span class="dt">Digit</span> a)
         (<span class="dt">FingerTree</span> (<span class="dt">Node</span> a)) <span class="fu">!</span>(<span class="dt">Digit</span> a)</code></pre></div>
<p>Updates (cons and append) to both ends of the data structure are where Sequence excels.<br />
If you don't need that and just need consing on the front,<br />
the normal list can compete with this option, especially<br />
when the lists are small.<br />
Also, Sequence is a persistent data structure like Map, so the memory density<br />
isn't as good as it is with Vector.</p>
<h3 id="vector">28.8 Vector</h3>
<p>The Vector type lives in the <em>vectors</em> library.<br />
Vectors are &quot;efficient arrays&quot;. According to Chris, the Array type is rarely used in Haskell,<br />
and we almost always want Vector, which is a slice wrapper of Array:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Boxed vectors, supporting efficient slicing.</span>
<span class="kw">data</span> <span class="dt">Vector</span> a <span class="fu">=</span> <span class="dt">Vector</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>
                       <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>
                       <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Array</span> a)
    <span class="kw">deriving</span> ( <span class="dt">Typeable</span> )</code></pre></div>
<p>Vectors come in boxed, unboxed, immutable, mutable, and storable flavors -- but the plain version<br />
is most common.<br />
&quot;Boxed&quot; vectors can reference any datatype we want,<br />
while &quot;unboxed&quot; represents raw values without pointer indirection,<br />
which can save a lot of memory but is limited to types like<br />
Bool, Char, Double, Float, Int, Word, etc.<br />
Recall newtypes don't introduce pointer indirection, so unboxable types are closed under newtyping.</p>
<p>You want a vector when</p>
<ul>
<li>you need memory efficiency close to theoretical maximum</li>
<li>data access is almost exclusively by indexing via Int values</li>
<li>you want uniform access times for each element in the structure</li>
<li>you construct a Vector <em>once</em> and read it many times (or use mutable version for ongoing updates)</li>
<li>you want efficient slicing</li>
</ul>
<h4 id="updating-vectors">Updating vectors</h4>
<p>In general persistent vectors are not great at handling ongoing updates,<br />
however sometimes <strong>loop fusion</strong> can alleviate this.<br />
Fusion, accomplished via <a href="https://wiki.haskell.org/GHC/Using_rules">GHC Rules</a>,<br />
means that the compiler can fuse several loops into one megaloop and do it in one pass:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span>

<span class="ot">testV ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> <span class="dt">Int</span>
testV n <span class="fu">=</span>
  V.map (<span class="fu">+</span>n) <span class="fu">$</span> V.map (<span class="fu">+</span>n) <span class="fu">$</span>
    V.map (<span class="fu">+</span>n) <span class="fu">$</span> V.map (<span class="fu">+</span>n)
    (V.fromList [<span class="dv">1</span><span class="fu">..</span><span class="dv">10000</span>])

<span class="co">-- turns into</span>

<span class="ot">testV ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> <span class="dt">Int</span>
testV n <span class="fu">=</span>
  V.map ( (<span class="fu">+</span>n) <span class="fu">.</span> (<span class="fu">+</span>n)
        <span class="fu">.</span> (<span class="fu">+</span>n) <span class="fu">.</span> (<span class="fu">+</span>n) ) (V.fromList [<span class="dv">1</span><span class="fu">..</span><span class="dv">10000</span>])</code></pre></div>
<p>However, this won't be best for all situations.<br />
Sometimes we need to update certain elements selectively;<br />
for this, we can use the batch operator <code>//</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">batchList ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> <span class="dt">Int</span>
batchList n <span class="fu">=</span> vec <span class="fu">//</span> updates
  <span class="kw">where</span> updates <span class="fu">=</span> fmap (\n <span class="ot">-&gt;</span> (n, <span class="dv">0</span>)) [<span class="dv">0</span><span class="fu">..</span>n]</code></pre></div>
<p>This is super quick. Also, compiling the <code>updates</code> first and then passing to the batch operation<br />
is about 500-1000x faster than calling <code>//</code> for each element in the <code>updates</code> list.<br />
If you're going to use the batch, make sure you batch!<br />
Furthermore, this can be speeded up by 1.4% by putting the updates in a Vector themselves,<br />
in which case we use <code>V.unsafeUpdate</code> instead of <code>V.//</code>.</p>
<h4 id="mutable-vectors">Mutable Vectors</h4>
<p>We can squeeze even more performance out of vectors, when necessary, by using mutation.<br />
Here are two different methods, IO and ST:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Primitive</span>
<span class="kw">import </span><span class="dt">Control.Monad.ST</span>
<span class="kw">import </span><span class="dt">Criterion.Main</span>
<span class="kw">import qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span>
<span class="kw">import qualified</span> <span class="dt">Data.Vector.Mutable</span> <span class="kw">as</span> <span class="dt">MV</span>
<span class="kw">import qualified</span> <span class="dt">Data.Vector.Generic.Mutable</span> <span class="kw">as</span> <span class="dt">GM</span>

<span class="ot">mutableUpdateIO ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">MV.MVector</span> <span class="dt">RealWorld</span> <span class="dt">Int</span>)
mutableUpdateIO n <span class="fu">=</span> <span class="kw">do</span>
  mvec <span class="ot">&lt;-</span> GM.new (n<span class="fu">+</span><span class="dv">1</span>)
  go n mvec
  <span class="kw">where</span> go <span class="dv">0</span> v <span class="fu">=</span> return v
        go n v <span class="fu">=</span> (MV.write v n <span class="dv">0</span>) <span class="fu">&gt;&gt;</span> go (n<span class="fu">-</span><span class="dv">1</span>) v

<span class="ot">mutableUpdateST ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> <span class="dt">Int</span>
mutableUpdateST n <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span>
  mvec <span class="ot">&lt;-</span> GM.new (n<span class="fu">+</span><span class="dv">1</span>)
  go n mvec
  <span class="kw">where</span> go <span class="dv">0</span> v <span class="fu">=</span> V.freeze v
        go n v <span class="fu">=</span> (MV.write v n <span class="dv">0</span>) <span class="fu">&gt;&gt;</span> go (n<span class="fu">-</span><span class="dv">1</span>) v</code></pre></div>
<p>and the performance results of all these methods, updating a 10,000 element list:</p>
<table>
<thead>
<tr class="header">
<th>Variant</th>
<th>Microseconds</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>slow</td>
<td>133,600</td>
</tr>
<tr class="even">
<td>batchList</td>
<td>244</td>
</tr>
<tr class="odd">
<td>batchVector</td>
<td>176</td>
</tr>
<tr class="even">
<td>mutableUpdateST</td>
<td>32</td>
</tr>
<tr class="odd">
<td>mutableUpdateIO</td>
<td>19</td>
</tr>
</tbody>
</table>
<p>ST is slightly slower than the IO version due to the freezing and unfreezing. The biggest<br />
improvement is from not being an idiot.</p>
<p>ST works by unfreezing data, mutating it, and then refreezing it so that it cannot be mutated further,<br />
and thus manages to maintain referential transparency.<br />
Under the hood it looks like a primitive <code>GHC.Prim.State# s -&gt; (# GHC.Prim.State# s, a #)</code> type.<br />
The state <code>s</code> is not the actual thing we're mutating, and has no value level witness.<br />
The <code>s</code> type enables <code>ST</code> to enforce at compile-time that the mutable references to persistent<br />
immutable data structures are kept within the <code>ST</code> monad, using a trick called<br />
<em>existential quantification</em>.</p>
<p>The thaws and freezes from dipping in and out of ST are costly - if it has to happen often,<br />
it is probably better to just use <code>IO</code>.</p>
<h3 id="string-types">28.9 String types</h3>
<h4 id="string">String</h4>
<p><code>String</code>s in Haskell are okay for demonstrations or toy programs, but the memory usage<br />
for large strings can get out of control rapidly, and most operations<br />
on them have times proportional to the length of the list.</p>
<h4 id="text">Text</h4>
<p><code>Text</code> is good for when we have plain text and need better memory usage performance<br />
and more efficient indexing into the string. However, Text is encoded as<br />
UTF-16, and while this is faster, it can be unexpected since UTF-8 is vastly<br />
more popular.</p>
<h4 id="bytestring">ByteString</h4>
<p>ByteStrings are not necessarily strings/text, but a sequence of bytes represented<br />
as a vector of Word8 values. Note that text on a computer is obviously always<br />
made up of bytes, but needs an encoding in order to be &quot;read&quot; as text (such as<br />
the common ASCII, UTF-8, UTF-16, etc.). As we mentioned, Text uses size 16 to<br />
read larger chunks at a time, increasing performance.</p>
<p>The downside to ByteString is that it encompasses byte data that might not be<br />
&quot;readable&quot; text, which can be a problem if you don't want to permit non-text<br />
byte sequences.</p>
<p>Note that in most cases <strong>Data.ByteString.Char8</strong> is not what you're looking for,<br />
as it doesn't support Unicode, and is <strong>only</strong> for ASCII data.</p>
<h4 id="bytestring-vs.-text">ByteString vs. Text</h4>
<p>Sometimes you'll choose ByteString over Text if you want to keep incoming UTF-8<br />
encoded data in UTF-8, instead of encoding/decoding it out of Text.</p>
<h3 id="chapter-exercises-13">28.10 Chapter Exercises</h3>
<ol>
<li><a href="./DList.hs">Difference list</a>: <strong>note</strong> right now benchmarks don't show improvement:</li>
</ol>
<p>```<br />
benchmarking concat list<br />
time 55.59 ms (54.99 ms .. 56.29 ms)<br />
1.000 R² (0.999 R² .. 1.000 R²)<br />
mean 54.90 ms (54.64 ms .. 55.19 ms)<br />
std dev 492.0 μs (304.4 μs .. 812.6 μs)</p>
<p>benchmarking concat dlist<br />
time 55.12 ms (54.74 ms .. 55.39 ms)<br />
1.000 R² (1.000 R² .. 1.000 R²)<br />
mean 54.87 ms (54.49 ms .. 55.06 ms)<br />
std dev 513.6 μs (83.54 μs .. 905.2 μs)<br />
```</p>
<ol>
<li><a href="./Queue.hs">A simple queue</a>: <strong>note</strong> right now benchmarks don't show improvement:</li>
</ol>
<p>```<br />
benchmarking pop/push list<br />
time 52.62 ms (52.21 ms .. 52.94 ms)<br />
1.000 R² (1.000 R² .. 1.000 R²)<br />
mean 52.46 ms (52.10 ms .. 52.71 ms)<br />
std dev 533.0 μs (345.8 μs .. 838.3 μs)</p>
<p>benchmarking pop/push queue<br />
time 248.4 ms (241.4 ms .. 260.9 ms)<br />
0.999 R² (0.993 R² .. 1.000 R²)<br />
mean 244.8 ms (237.5 ms .. 248.8 ms)<br />
std dev 7.094 ms (465.4 μs .. 9.180 ms)<br />
variance introduced by outliers: 16% (moderately inflated)<br />
```</p>
<h1 id="io">IO</h1>
<p>IO is not as complicated as most explanations suggest. In short, it is a special kind<br />
of datatype that inherently disallows certain types of sharing, thus preventing the<br />
effects of certain functions from percolating throughout a program (similar to the<br />
mutable vector ST from the previous chapter).</p>
<h3 id="where-io-explanations-go-astray">29.2 Where IO explanations go astray</h3>
<p>Of course, IO is more than just a monad. To be precise, however, IO is an instance of<br />
the ST monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">IO</span>
<span class="kw">newtype</span> <span class="dt">IO</span> a
  <span class="fu">=</span> <span class="dt">GHC.Types.IO</span> (<span class="dt">GHC.Prim.State</span><span class="fu">#</span> <span class="dt">GHC.Prim.RealWorld</span>
                  <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">GHC.Prim.State</span><span class="fu">#</span> <span class="dt">GHC.Prim.RealWorld</span>, a <span class="fu">#</span>))
    <span class="co">-- Defined in ‘GHC.Types’</span></code></pre></div>
<p>But thinking of IO in terms of State isn't all that helpful, since you don't<br />
really interact with the underlying State# in IO. The State is just a signalling<br />
mechanism telling GHC what order your IO actions are in and what a unique IO<br />
action is. Its type parameter is only there to keep different state threads separate.<br />
In fact, the RealWorld primitive above is not represented by anything - it uses<br />
zero bits of memory and is erased at compile time.</p>
<p>Anyway, since we can't actually interact with the State on which IO is built,<br />
it doesn't really do us any good to think about IO in terms of State.</p>
<h3 id="the-reason-we-need-this-type">29.3 The reason we need this type</h3>
<p>Instead of considering how IO is defined, let's consider its motivation for us as<br />
programmers. IO primarily exists to let us order operations and disable some of the<br />
sharing mentinoned in the <a href="../27_Non-strictness">Non-Strictness</a> chapter. GHC is<br />
usually free to reorder lots of operations, delaying evaluation, sharing values,<br />
duplicating code via inlining, among other optimizations. The <strong>main</strong> part of the<br />
IO type is that it turns off these abilities.</p>
<p>GHC's implicit reordering is disabled in IO (as in ST) by enclosing IO actions<br />
within nested lambdas (the only way to ensure order within a pure lambda calculus).</p>
<h3 id="sharing">29.4 Sharing</h3>
<p>Usually we are assured that if a function is evaluated at all, it will result in a certain type;<br />
with the IO type, you are not guaranteed anything. So values of type <code>IO a</code> are not an <code>a</code>,<br />
but a description of how you might get an <code>a</code> from the real world, possibly performing<br />
effects on the way. Thus in this environment, where we don't have a value <code>a</code> but only<br />
a means of getting a value <code>a</code>, it doesn't make sense for that value to be shared.</p>
<p>Consider a current time function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- from Data.Time.Clock</span>
<span class="ot">getCurrentTime ::</span> <span class="dt">IO</span> <span class="dt">UTCTime</span></code></pre></div>
<p>of course this couldn't work if we shared the result but needed to check the time twice.</p>
<p>Keep in mind the disabling of sharing is within IO but not <em>everywhere</em> within IO.<br />
This is fairly obvious when you realize that all Haskell functions contained within the<br />
outer <code>main :: IO ()</code> type. To look at exactly where this does and doesn't happen,<br />
let's consider MVar.</p>
<p>The MVar type is a means of synchronizing shared data in Haskell. It can hold one value at a time.<br />
Consider the following code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">WhatHappens</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Concurrent</span>

<span class="ot">myData ::</span> <span class="dt">IO</span> (<span class="dt">MVar</span> <span class="dt">Int</span>)
myData <span class="fu">=</span> newEmptyMVar

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  mv <span class="ot">&lt;-</span> myData
  putMVar mv <span class="dv">0</span>
  mv&#39; <span class="ot">&lt;-</span> myData
  zero <span class="ot">&lt;-</span> takeMVar mv&#39;
  print zero</code></pre></div>
<p>Running this we get locked up:</p>
<pre><code>*** Exception: thread blocked indefinitely in an MVar operation</code></pre>
<p>because <code>newEmptyMVar :: IO MVar a</code> is a <em>recipe</em> for producing empty MVars,<br />
not a reference to a single shared MVar. So the two <code>myData</code> references are <strong>not</strong><br />
referring to the same MVar. And when you try to take a value out of an empty MVar,<br />
the program is blocked until something is put into that MVar, hence the deadlock exception.</p>
<p>The point is, when you see a type like <code>IO String</code> or <code>IO (MVar a)</code>, you don't have a reference<br />
to a single string or shared MVar; you have a recipe for producing a string or an empty MVar.</p>
<h3 id="io-doesnt-disable-sharing-for-everything">29.5 IO doesn't disable sharing for everything</h3>
<p>As mentioned earlier, IO obvoiusly doesn't disable sharing for everything.<br />
It disables sharing for the <strong>terminal values</strong> it reduces to, such as the <code>MVar a</code> in <code>IO MVar a</code>.<br />
Values not dependent on IO for evaluation can still be shared:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">woot ::</span> <span class="dt">IO</span> <span class="dt">String</span>
woot <span class="fu">=</span> return (trace <span class="st">&quot;evaluted woot&quot;</span> <span class="st">&quot;woot&quot;</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  w <span class="ot">&lt;-</span> woot
  putStrLn w
  putStrLn w

<span class="dt">Prelude</span> <span class="dt">Debug.Trace</span>
λ<span class="fu">&gt;</span> main
woot evaluated
woot
woot</code></pre></div>
<p>notice that sharing is not disabled for values not in IO that happen to be used in the course<br />
of running an IO action.</p>
<h3 id="purity-is-losing-meaning">29.6 Purity is losing meaning</h3>
<p>The interpretation of the words &quot;purely functional&quot; have changed over the years.<br />
The phrase used to describe a language whose semantics would be only lambda calculus.<br />
Impure functional languages were more typical, augmenting the calculus to allow for imperitave,<br />
effectful programs.</p>
<p>The mistake poeple make with IO is conflating effects with semantics. We don't lose referential<br />
transparency with the effects allowed in Haskell. A function that returns <code>IO a</code> is still<br />
referentially transparent, because given the same arguments, it will generate the same IO action<br />
every time. A function <code>f :: Bool -&gt; IO [Int]</code> that returns an action which produces<br />
10 random integers might produce different literal values, but it's still returning the same <em>action</em>.<br />
Referential transparency is preserved because we're returning the same <em>IO action</em> or recipe.</p>
<h3 id="ios-functor-applicative-and-monad">29.7 IO's Functor, Applicative, and Monad</h3>
<p>Another common mistake is the &quot;IO is a monad&quot; perspective. Sure it is, but the better<br />
perspective is &quot;IO is a datatype that has a Monad instance, along with Functor and<br />
Applicative instances.&quot; Since IO is a unique type, let's explicitly define what each instance<br />
accomplishes.</p>
<h4 id="the-io-functor">The IO Functor</h4>
<p><code>fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b</code> lifts a function over the effects that we<br />
might perform to obtain the <code>a</code> value. In other words, it produces a new IO action <code>IO b</code> in terms<br />
of the old action <code>IO a</code> by transforming the final result of the <code>IO a</code> action.</p>
<h4 id="the-applicative-io">The Applicative IO</h4>
<p>Similar to the <code>fmap</code> concept, <code>(&lt;*&gt;) :: IO (a -&gt; b) -&gt; IO a -&gt; IO b</code> takes a recipe for producing<br />
a function <code>f :: a -&gt; b</code> and a recipe for producing an <code>a</code> value, and returns a recipe for<br />
performing <code>f</code> on the result of the recipe for <code>a</code>; hence returning <code>IO b</code>.</p>
<h4 id="monad-and-io">Monad and IO</h4>
<p>Think of <code>pure</code>/<code>return</code> as an effect-free way to embed a value in a recipe-creating environment.<br />
The monad instance differs from the applicative in that effects performed by an outer IO action<br />
can influence what recipe we get from the inner portion:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">NestedIO</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Time.Calendar</span>
<span class="kw">import </span><span class="dt">Data.Time.Clock</span>
<span class="kw">import </span><span class="dt">System.Random</span>

<span class="ot">huehue ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> (<span class="dt">IO</span> <span class="dt">Int</span>) (<span class="dt">IO</span> ()))
huehue <span class="fu">=</span> <span class="kw">do</span>
  t <span class="ot">&lt;-</span> getCurrentTime
  <span class="kw">let</span> (_, _, dayOfMonth) <span class="fu">=</span> toGregorian (utctDay t)
  <span class="kw">case</span> even dayOfMonth <span class="kw">of</span>
    <span class="dt">True</span>  <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">Left</span> randomIO
    <span class="dt">False</span> <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">Right</span> (putStrLn <span class="st">&quot;no soup for you&quot;</span>)</code></pre></div>
<p>here the <code>IO</code> returned is dependent on effects from an outer <code>IO</code> action, namely getting the time.<br />
This is inexpressible with Applicative.</p>
<h5 id="monadic-associativity">Monadic associativity</h5>
<p>It's important to keep in mind the &quot;recipe&quot; perspective. The IO bind from its monad instance<br />
is associative, even if IO actions seem to contradict this. It's because we are constructing<br />
recipes, not executing actions. Binding over an IO action does not execute it, it produces a<br />
<em>new</em> IO action in terms of the old one.</p>
<h3 id="well-then-how-do-we-mvar">29.8 Well, then, how do we MVar?</h3>
<p>So, the right way to refer to the MVar in the above example is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  mv <span class="ot">&lt;-</span> newEmptyMVar
  putMVar mv (<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span>)
  zero <span class="ot">&lt;-</span> takeMVar mv
  print zero</code></pre></div>
<p>But we can also do this in a sinister manner via <code>unsafePerformIO</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="kw">import </span><span class="dt">System.IO.Unsafe</span>
<span class="ot">myData ::</span> <span class="dt">MVar</span> <span class="dt">Int</span>
myData <span class="fu">=</span> unsafePerformIO newEmptyMVar
<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  putMVar myData <span class="dv">0</span>
  zero <span class="ot">&lt;-</span> takeMVar myData
  print zero</code></pre></div>
<p>Note that <code>unsafePerformIO :: IO a -&gt; a</code>, which is definitely not a good idea, and can<br />
actually break referential transparency, but it does allow us to accomplish implicit<br />
sharing of the MVar wherever we want. In real code we'd pass references to MVars around<br />
as arguments (typically using Reader monad).</p>
<h3 id="chapter-exercises-14">29.9 Chapter Exercises</h3>
<ol>
<li><a href="./Vigenere/Main.hs">File I/O with Vigenere</a></li>
<li><p><a href="./Config/Main.hs">Config directories</a></p>
<h1 id="when-things-go-wrong">When things go wrong</h1>
<p>We've seen how to <em>explicitly</em> handle error conditions via <code>Either</code> and <code>Maybe</code>,<br />
but sometimes exceptions can be faster by eliding repeated checks for an adverse condition.</p></li>
</ol>
<h3 id="the-exception-class-and-methods">30.2 The Exception class and methods</h3>
<p>Exceptions are normal types and values, but they all have an instance of the Exception typeclass:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Typeable</span> e, <span class="dt">Show</span> e) <span class="ot">=&gt;</span> <span class="dt">Exception</span> e <span class="kw">where</span>
<span class="ot">  toException ::</span> e <span class="ot">-&gt;</span> <span class="dt">SomeException</span>
<span class="ot">  fromException ::</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> e
<span class="ot">  displayException ::</span> e <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<p><code>Typeable</code> defines methods for identifying types at runtime.</p>
<h4 id="but-there-is-something-different-going-on-here">But there is something different going on here</h4>
<p>There are many exception types defined in Control.Exception, and all are defined<br />
totally normally except <code>SomeException</code>. It is at the heart of the <code>Exception</code> typeclass<br />
but it also has an instance of the typeclass.</p>
<h4 id="a-brief-introduction-to-existential-quantification">A brief introduction to existential quantification</h4>
<p><code>SomeException</code> acts as a sort of parent type for all the other exception types,<br />
so we can handle many exceptions at once without having to match all the individual types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeException</span> <span class="kw">where</span>
  <span class="dt">SomeException</span><span class="ot"> ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">SomeException</span></code></pre></div>
<p>This is a Generalized Algebraic Datatype (GADT), and the syntax is hiding something called<br />
<em>existential quantification</em>. Consider the equivalent definition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeException</span> <span class="kw">where</span>
  forall e <span class="fu">.</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">SomeException</span></code></pre></div>
<p>Usually <code>forall</code> quantifies universally as we'd expect. However, note that the<br />
<code>SomeException</code> <em>type constructor</em> doesn't take an argument; the type variable <code>e</code> is<br />
a parameter to the <em>data constructor</em>. Moving the quantifier to the data constructor<br />
limits the scope of its application and changes its meaning from <em>for all e</em> to<br />
<em>there exists some e</em>, hence existential quantification. When the type is existentially<br />
quantified, we can't do much with the polymorphic type variable in its data constructor.<br />
It can't be made concrete, it must remain polymorphic, but that allows us to cram<br />
any value that fits the typeclass constraint into that role.</p>
<p>Here's an example of using existential quantification just like that of <code>SomeException</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>
<span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="kw">module</span> <span class="dt">WhySomeException</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Exception</span> (<span class="dt">ArithException</span>(..), <span class="dt">AsyncException</span>(..))
<span class="kw">import </span><span class="dt">Data.Typeable</span>

<span class="kw">data</span> <span class="dt">MyException</span> <span class="fu">=</span> forall e <span class="fu">.</span> (<span class="dt">Show</span> e, <span class="dt">Typeable</span> e) <span class="ot">=&gt;</span> <span class="dt">MyException</span> e

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">MyException</span> <span class="kw">where</span>
  showsPrec p (<span class="dt">MyException</span> e) <span class="fu">=</span> showsPrec p e

<span class="ot">multiError ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">MyException</span> <span class="dt">Int</span>
multiError n <span class="fu">=</span>
  <span class="kw">case</span> n <span class="kw">of</span>
    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> (<span class="dt">MyException</span> <span class="dt">DivideByZero</span>)
    <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> (<span class="dt">MyException</span> <span class="dt">StackOverflow</span>)
    _ <span class="ot">-&gt;</span> <span class="dt">Right</span> n</code></pre></div>
<p>This allows us to return <code>Left e</code> values where <code>e</code> can inhabit two <em>different</em> types.<br />
The first thought is, well we could just slap a typeclass constraint <code>e :: (Exception e) =&gt; e</code><br />
on this; but that generalizes the function too much. If we wrote<br />
<code>multiError :: Exception e =&gt; Int -&gt; Either e Int</code>, then returning <code>Left DivideByZero</code><br />
wouldn't even typecheck.</p>
<p>Prior to this design, we'd have to have big sum types or strings, neither of which<br />
are extensible to structured, proper data types. But with the combination of <code>SomeException</code><br />
and <code>Typeable</code>, we can throw different exceptions of different types and catch<br />
some or all of them in a handler, without having to wrap them into a parent sum type.</p>
<h4 id="typeable">Typeable</h4>
<p><code>Typeable</code> allows types to be known at runtime, allowing for dynamic type checking.<br />
It has one method:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cast ::</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</code></pre></div>
<p>this is used under the hood in the higher level functions like <code>fromException</code> and <code>catch</code>.</p>
<h3 id="this-machine-kills-programs">30.3 This machine kills programs</h3>
<p>Exceptions can be thrown in pure code (like <code>2 `div` 0</code>), but can only be caught<br />
and handled in <code>IO</code>. Since <code>main</code> is always an <code>IO</code> action, we can handle this in every program.</p>
<h4 id="catch-me-if-you-can">Catch me if you can</h4>
<p>Here's a trivial example of a basic <code>catch :: Exception e =&gt; IO a -&gt; (e -&gt; IO a) -&gt; IO a</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Exception</span>
<span class="kw">import </span><span class="dt">Data.Typeable</span>

<span class="ot">handler ::</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
handler (<span class="dt">SomeException</span> e) <span class="fu">=</span> <span class="kw">do</span>
  print (typeOf e)
  putStrLn (<span class="st">&quot;We errored! It was: &quot;</span> <span class="fu">++</span> show e)

main <span class="fu">=</span>
  writeFile <span class="st">&quot;zzz&quot;</span> <span class="st">&quot;hi&quot;</span>
    <span class="ot">`catch`</span> handler</code></pre></div>
<p>Note that <code>catch</code> only runs if the exception matching the type you specify in the handler is thrown.<br />
While in this case we're just printing the error, we could obviously give any alternate <code>IO a</code>,<br />
like writing to another file.</p>
<p>Here's a real live example from twitter-conduit:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">withCredentials action <span class="fu">=</span> <span class="kw">do</span>
  twinfo <span class="ot">&lt;-</span> loadCredentials <span class="ot">`catch`</span> handleMissing
  <span class="kw">case</span> twinfo <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> getTWInfo <span class="fu">&gt;&gt;=</span> saveCredentials
    <span class="dt">Just</span> twinfo <span class="ot">-&gt;</span> action twinfo
  <span class="kw">where</span><span class="ot"> handleMissing ::</span> <span class="dt">IOException</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">TWInfo</span>)
        handleMissing _ <span class="fu">=</span> return <span class="dt">Nothing</span></code></pre></div>
<h3 id="want-either-try">30.4 Want either? Try!</h3>
<p>We can lift exceptions into explicit <code>Either</code> values via</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">try ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> e a)</code></pre></div>
<p>however we are restricted to acting within IO.</p>
<p>Just like most other languages, exceptions in Haskell are <em>imprecise</em>.<br />
Exception types not caught by a particular handler will roll up until explicitly caught<br />
by another, or until it kills the program.</p>
<h3 id="the-unbearable-imprecision-of-trying">30.5 The unbearable imprecision of trying</h3>
<p>Let's throw exceptions manually and see what we can catch:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tryToCatch ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">ArithException</span> ())
tryToCatch e <span class="fu">=</span> try <span class="fu">$</span> throwIO e

<span class="co">-- where</span>
<span class="ot">throwIO ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">IO</span> a

<span class="co">-- repl</span>
λ<span class="fu">&gt;</span> tryToCatch <span class="dt">DivideByZero</span>
<span class="dt">Left</span> divide by zero
λ<span class="fu">&gt;</span> tryToCatch <span class="dt">StackOverflow</span>
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> stack overflow</code></pre></div>
<p>This is probably what we expected - we're only going to catch the <code>ArithException</code> that we specified.</p>
<p>See <a href="./StoppingTheParty.hs">StoppingTheParty</a> for an example of how to catch more<br />
than one exception, and the limitations of general <code>Exception</code> typeclass constraints.</p>
<h3 id="why-throwio">30.6 Why throwIO?</h3>
<p>There is also <code>throw :: Exception e =&gt; e -&gt; a</code> that can be used outside of IO,<br />
but unless writing a library it shouldn't be used, as it obscures possible effects<br />
that should be explicit in types.<br />
Haskell enforces that you handle exceptions in <code>IO</code> even if they were thrown<br />
without the <code>IO</code> type; if it didn't, we'd break referential transparency!</p>
<p>Both <code>throw</code> and <code>throwIO</code> are often called behind the scenes in library functions.<br />
Here's an example from http-client:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">connectionReadLine ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ByteString</span>
connectionReadLine conn <span class="fu">=</span> <span class="kw">do</span>
  bs <span class="ot">&lt;-</span> connectionRead conn
  when (S.null bs) <span class="fu">$</span> throwIO <span class="dt">IncompleteHeaders</span>
  connectionReadLineWith conn bs</code></pre></div>
<h3 id="making-our-own-exception-types">30.7 Making our own exception types</h3>
<p>A trivial example for ensuring even numbers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NotEven</span> <span class="fu">=</span> <span class="dt">NotEven</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">NotEven</span>

<span class="ot">ensureEven ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>
ensureEven i
  <span class="fu">|</span> odd i     <span class="fu">=</span> throwIO <span class="dt">NotEven</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> return i</code></pre></div>
<p>But what if we want the context of how the error was caused? A well-named exception<br />
only goes so far:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NotEven</span> <span class="fu">=</span> <span class="dt">NotEven</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">NotEven</span>

<span class="ot">ensureEven ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>
ensureEven i
  <span class="fu">|</span> odd i     <span class="fu">=</span> throwIO (<span class="dt">NotEven</span> i)
  <span class="fu">|</span> otherwise <span class="fu">=</span> return i</code></pre></div>
<p>This ensures the bad input gets included in the exception data.</p>
<p>If we want to also handle a custom <code>NotZero</code> exception, we can use <code>catches</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">catches ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> [<span class="dt">Handler</span> a] <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="co">-- where</span>
<span class="kw">data</span> <span class="dt">Handler</span> a <span class="kw">where</span>
  <span class="dt">Handler</span><span class="ot"> ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">Handler</span> a</code></pre></div>
<p>The <code>Handler</code> type uses the same existential quantification technique as <code>Exception</code>,<br />
allowing us to specify a single typed list of handlers for different exceptions.</p>
<p>Of course, if our exceptions are very related, we can always define them as separate values<br />
of a single sum type as well.</p>
<h3 id="surprising-interaction-with-bottom">30.8 Surprising interaction with bottom</h3>
<p>A tricky situation arises when we catch exceptions for values that might be bottom.<br />
Due to non-strictness, evaluation of bottom in different places can cause implicit<br />
unwanted behavior:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">worksFine ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> ())
worksFine <span class="fu">=</span> try undefined

<span class="ot">damnBug ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> ())
damnBug <span class="fu">=</span> try <span class="fu">$</span> return undefined

<span class="dt">Prelude</span><span class="fu">&gt;</span> worksFine
<span class="dt">Left</span> Prelude.undefined
<span class="dt">Prelude</span><span class="fu">&gt;</span> damnBug
<span class="dt">Right</span> <span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.undefined</code></pre></div>
<p>Non-strictness means burying the bottom in <code>return</code> causes bottom to not get forced until<br />
evaluation is <em>past</em> the <code>try</code>; thus resulting in an uncaught error passed to <code>Right</code>.</p>
<p>Keep in mind:</p>
<ul>
<li><strong>Exception handling is not for catching bottoms.</strong></li>
<li>Just squelching an exception, even <code>SomeException</code>, <strong>doesn't mean the program won't fail</strong>.</li>
</ul>
<p>Unfortunately, bottoms aren't the only thing that can get past catching <code>SomeException</code>.</p>
<h3 id="asynchronous-exceptions">30.9 Asynchronous Exceptions</h3>
<p>Here we'll try to kill a forked IO process:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Concurrent</span> (forkIO, threadDelay)
<span class="kw">import </span><span class="dt">Control.Exception</span>
<span class="kw">import </span><span class="dt">System.IO</span>

<span class="ot">openAndWrite ::</span> <span class="dt">IO</span> ()
openAndWrite <span class="fu">=</span> <span class="kw">do</span>
  h <span class="ot">&lt;-</span> openFile <span class="st">&quot;test.dat&quot;</span> <span class="dt">WriteMode</span>
  threadDelay <span class="dv">1000</span>
  hPutStr h (replicate <span class="dv">100000000</span> <span class="ch">&#39;0&#39;</span> <span class="fu">++</span> <span class="st">&quot;abc&quot;</span>)
  hClose h

<span class="kw">data</span> <span class="dt">PleaseDie</span> <span class="fu">=</span> <span class="dt">PleaseDie</span> <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">PleaseDie</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  threadId <span class="ot">&lt;-</span> forkIO openAndWrite
  threadDelay <span class="dv">2000</span>
  throwTo threadId <span class="dt">PleaseDie</span></code></pre></div>
<p>(<strong>Note</strong> this didn't work for me. Never got any zeroes to write to test.dat. But I<br />
understand what the authors were demonstrating, so... anyway...)</p>
<p>Asynchronous exceptions are exceptions raised from a different thread that the one<br />
receiving the error. This is always a real threat, for example if the Haskell program<br />
process was killed by the operating system. In some cases, like when a file handle or database<br />
connection is open, if possible we'd like to ignore the exception until we've had a chance<br />
to close the connection so we can avoid resource leaks or corrupted files, etc.</p>
<p>Fortunately, <code>Control.Exception</code> exports <code>mask_</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- ... same as above</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  threadId <span class="ot">&lt;-</span> forkIO (mask_ openAndWrite)
  threadDelay <span class="dv">2000</span>
  throwTo threadId <span class="dt">PleaseDie</span></code></pre></div>
<p><code>mask_</code> masks or delays exceptions thrown to the child thread until the <code>openAndWrite</code><br />
action is complete. Since the end of the mask is the end of the child thread action,<br />
the exception ends up being thrown in the main thread.</p>
<h1 id="final-project">Final Project</h1>
<p>Finger Daemons!</p>
<h3 id="fingerd">31.2 fingerd</h3>
<p>The <em>finger</em> service is a means of figuring out how to contact people<br />
on the same computer network and has been around since the pre-internet era.<br />
It looks like this:</p>
<pre class="shell"><code>❯ finger samtay
Login: samtay                   Name: (null)
Directory: /home/samtay                 Shell: /usr/bin/zsh
On since Mon May 22 23:37 (EDT) on tty1   2 days 20 hours idle
     (messages off)
No mail.
No Plan.</code></pre>
<p>The finger protocol operates over TCP (Transmission Control Protocol) just like a web browser.<br />
However, the web has HTTP, an entire application protocol layered atop TCP, whereas<br />
the finger protocol is just a single message text protocol.</p>
<h4 id="debug"><a href="./app/Debug.hs">Debug</a></h4>
<p>The debug program is used to show us what the client sends. It is a TCP server,<br />
similar to a web server that provides a web page, but lower level and limited to<br />
sending raw text back and forth. It's set to run at port 79.</p>
<p>We can run it with sudo access like so:</p>
<pre class="shell"><code>$ sudo $(stack exec which debug)</code></pre>
<p>and in another terminal, open a connection to port 79:</p>
<pre class="shell"><code>$ telnet localhost 79
Trying ::1...
Connection failed: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;^]&#39;.</code></pre>
<p>and then whatever text we send gets sent back to us. Since we <code>cClose soc</code> in the<br />
<code>logAndEcho</code> functino, the telnet connection is closed and needs to be reopened,<br />
but the debug server stays alive.</p>
<p>In addition to telnet we can use a finger client:</p>
<pre class="shell"><code>-- finger client
❯ finger samtay@localhost
[localhost.localdomain]
samtay

-- debug server response
&quot;samtay\r\n&quot;</code></pre>
<p>To recap, the whole purpose of the debug server is so that we know exactly<br />
what information gets sent to the TCP server that we're about to build!</p>
<h3 id="slightly-modernized-fingerd">31.4 Slightly modernized fingerd</h3>
<p>Historically <code>finger</code> returned data about users pertaining to the operating system.<br />
We're going to update the source of data for <code>finger</code> using an embedded SQLite database.</p>
<h3 id="chapter-exercises-15">31.5 Chapter Exercises</h3>
<ol>
<li>Use the <code>sqlite3</code> command line interface to add a new user: <em>easy</em>.</li>
<li>Write another executable that adds users to the database: <a href="./app/AddUser.hs">AddUser</a>.</li>
<li>Add ability to modify existing user: done in <a href="./app/AddUser.hs">AddUser</a>.</li>
<li>Bound on a different port, try creating a “control socket” that permits<br />
inserting new data into the database while the server is running.<br />
For bonus points, write your own client executable that takes the<br />
arguments from the command line as well. See <a href="./src/FingerD.hs">FingerD</a>.</li>
</ol>
</body>
</html>
